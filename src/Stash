<?php

use Antlr\Antlr4\Runtime\ParserRuleContext;
use Antlr\Antlr4\Runtime\Token;
use Antlr\Antlr4\Runtime\Tree\ParseTreeVisitor;
use Antlr\Antlr4\Runtime\Tree\TerminalNode;
use Antlr\Antlr4\Runtime\Tree\ParseTreeListener;
use MySqlParser;
use MySqlParserListener;

class RootContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_root;
    }

    public function EOF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EOF, 0);
    }

    public function sqlStatements(): ?SqlStatementsContext
    {
        return $this->getTypedRuleContext(SqlStatementsContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function MINUS(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::MINUS);
        }

        return $this->getToken(MySqlParser::MINUS, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoot($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoot($this);
        }
    }
}

class SqlStatementsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_sqlStatements;
    }

    /**
     * @return array<SqlStatementContext>|SqlStatementContext|null
     */
    public function sqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SqlStatementContext::class);
        }

        return $this->getTypedRuleContext(SqlStatementContext::class, $index);
    }

    /**
     * @return array<EmptyStatement_Context>|EmptyStatement_Context|null
     */
    public function emptyStatement_(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(EmptyStatement_Context::class);
        }

        return $this->getTypedRuleContext(EmptyStatement_Context::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function SEMI(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::SEMI);
        }

        return $this->getToken(MySqlParser::SEMI, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function MINUS(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::MINUS);
        }

        return $this->getToken(MySqlParser::MINUS, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSqlStatements($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSqlStatements($this);
        }
    }
}

class SqlStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_sqlStatement;
    }

    public function ddlStatement(): ?DdlStatementContext
    {
        return $this->getTypedRuleContext(DdlStatementContext::class, 0);
    }

    public function dmlStatement(): ?DmlStatementContext
    {
        return $this->getTypedRuleContext(DmlStatementContext::class, 0);
    }

    public function transactionStatement(): ?TransactionStatementContext
    {
        return $this->getTypedRuleContext(TransactionStatementContext::class, 0);
    }

    public function replicationStatement(): ?ReplicationStatementContext
    {
        return $this->getTypedRuleContext(ReplicationStatementContext::class, 0);
    }

    public function preparedStatement(): ?PreparedStatementContext
    {
        return $this->getTypedRuleContext(PreparedStatementContext::class, 0);
    }

    public function administrationStatement(): ?AdministrationStatementContext
    {
        return $this->getTypedRuleContext(AdministrationStatementContext::class, 0);
    }

    public function utilityStatement(): ?UtilityStatementContext
    {
        return $this->getTypedRuleContext(UtilityStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSqlStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSqlStatement($this);
        }
    }
}

class EmptyStatement_Context extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_emptyStatement_;
    }

    public function SEMI(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SEMI, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterEmptyStatement_($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitEmptyStatement_($this);
        }
    }
}

class DdlStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_ddlStatement;
    }

    public function createDatabase(): ?CreateDatabaseContext
    {
        return $this->getTypedRuleContext(CreateDatabaseContext::class, 0);
    }

    public function createEvent(): ?CreateEventContext
    {
        return $this->getTypedRuleContext(CreateEventContext::class, 0);
    }

    public function createIndex(): ?CreateIndexContext
    {
        return $this->getTypedRuleContext(CreateIndexContext::class, 0);
    }

    public function createLogfileGroup(): ?CreateLogfileGroupContext
    {
        return $this->getTypedRuleContext(CreateLogfileGroupContext::class, 0);
    }

    public function createProcedure(): ?CreateProcedureContext
    {
        return $this->getTypedRuleContext(CreateProcedureContext::class, 0);
    }

    public function createFunction(): ?CreateFunctionContext
    {
        return $this->getTypedRuleContext(CreateFunctionContext::class, 0);
    }

    public function createServer(): ?CreateServerContext
    {
        return $this->getTypedRuleContext(CreateServerContext::class, 0);
    }

    public function createTable(): ?CreateTableContext
    {
        return $this->getTypedRuleContext(CreateTableContext::class, 0);
    }

    public function createTablespaceInnodb(): ?CreateTablespaceInnodbContext
    {
        return $this->getTypedRuleContext(CreateTablespaceInnodbContext::class, 0);
    }

    public function createTablespaceNdb(): ?CreateTablespaceNdbContext
    {
        return $this->getTypedRuleContext(CreateTablespaceNdbContext::class, 0);
    }

    public function createTrigger(): ?CreateTriggerContext
    {
        return $this->getTypedRuleContext(CreateTriggerContext::class, 0);
    }

    public function createView(): ?CreateViewContext
    {
        return $this->getTypedRuleContext(CreateViewContext::class, 0);
    }

    public function createRole(): ?CreateRoleContext
    {
        return $this->getTypedRuleContext(CreateRoleContext::class, 0);
    }

    public function alterDatabase(): ?AlterDatabaseContext
    {
        return $this->getTypedRuleContext(AlterDatabaseContext::class, 0);
    }

    public function alterEvent(): ?AlterEventContext
    {
        return $this->getTypedRuleContext(AlterEventContext::class, 0);
    }

    public function alterFunction(): ?AlterFunctionContext
    {
        return $this->getTypedRuleContext(AlterFunctionContext::class, 0);
    }

    public function alterInstance(): ?AlterInstanceContext
    {
        return $this->getTypedRuleContext(AlterInstanceContext::class, 0);
    }

    public function alterLogfileGroup(): ?AlterLogfileGroupContext
    {
        return $this->getTypedRuleContext(AlterLogfileGroupContext::class, 0);
    }

    public function alterProcedure(): ?AlterProcedureContext
    {
        return $this->getTypedRuleContext(AlterProcedureContext::class, 0);
    }

    public function alterServer(): ?AlterServerContext
    {
        return $this->getTypedRuleContext(AlterServerContext::class, 0);
    }

    public function alterTable(): ?AlterTableContext
    {
        return $this->getTypedRuleContext(AlterTableContext::class, 0);
    }

    public function alterTablespace(): ?AlterTablespaceContext
    {
        return $this->getTypedRuleContext(AlterTablespaceContext::class, 0);
    }

    public function alterView(): ?AlterViewContext
    {
        return $this->getTypedRuleContext(AlterViewContext::class, 0);
    }

    public function dropDatabase(): ?DropDatabaseContext
    {
        return $this->getTypedRuleContext(DropDatabaseContext::class, 0);
    }

    public function dropEvent(): ?DropEventContext
    {
        return $this->getTypedRuleContext(DropEventContext::class, 0);
    }

    public function dropIndex(): ?DropIndexContext
    {
        return $this->getTypedRuleContext(DropIndexContext::class, 0);
    }

    public function dropLogfileGroup(): ?DropLogfileGroupContext
    {
        return $this->getTypedRuleContext(DropLogfileGroupContext::class, 0);
    }

    public function dropProcedure(): ?DropProcedureContext
    {
        return $this->getTypedRuleContext(DropProcedureContext::class, 0);
    }

    public function dropFunction(): ?DropFunctionContext
    {
        return $this->getTypedRuleContext(DropFunctionContext::class, 0);
    }

    public function dropServer(): ?DropServerContext
    {
        return $this->getTypedRuleContext(DropServerContext::class, 0);
    }

    public function dropTable(): ?DropTableContext
    {
        return $this->getTypedRuleContext(DropTableContext::class, 0);
    }

    public function dropTablespace(): ?DropTablespaceContext
    {
        return $this->getTypedRuleContext(DropTablespaceContext::class, 0);
    }

    public function dropTrigger(): ?DropTriggerContext
    {
        return $this->getTypedRuleContext(DropTriggerContext::class, 0);
    }

    public function dropView(): ?DropViewContext
    {
        return $this->getTypedRuleContext(DropViewContext::class, 0);
    }

    public function dropRole(): ?DropRoleContext
    {
        return $this->getTypedRuleContext(DropRoleContext::class, 0);
    }

    public function setRole(): ?SetRoleContext
    {
        return $this->getTypedRuleContext(SetRoleContext::class, 0);
    }

    public function renameTable(): ?RenameTableContext
    {
        return $this->getTypedRuleContext(RenameTableContext::class, 0);
    }

    public function truncateTable(): ?TruncateTableContext
    {
        return $this->getTypedRuleContext(TruncateTableContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDdlStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDdlStatement($this);
        }
    }
}

class DmlStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dmlStatement;
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function insertStatement(): ?InsertStatementContext
    {
        return $this->getTypedRuleContext(InsertStatementContext::class, 0);
    }

    public function updateStatement(): ?UpdateStatementContext
    {
        return $this->getTypedRuleContext(UpdateStatementContext::class, 0);
    }

    public function deleteStatement(): ?DeleteStatementContext
    {
        return $this->getTypedRuleContext(DeleteStatementContext::class, 0);
    }

    public function replaceStatement(): ?ReplaceStatementContext
    {
        return $this->getTypedRuleContext(ReplaceStatementContext::class, 0);
    }

    public function callStatement(): ?CallStatementContext
    {
        return $this->getTypedRuleContext(CallStatementContext::class, 0);
    }

    public function loadDataStatement(): ?LoadDataStatementContext
    {
        return $this->getTypedRuleContext(LoadDataStatementContext::class, 0);
    }

    public function loadXmlStatement(): ?LoadXmlStatementContext
    {
        return $this->getTypedRuleContext(LoadXmlStatementContext::class, 0);
    }

    public function doStatement(): ?DoStatementContext
    {
        return $this->getTypedRuleContext(DoStatementContext::class, 0);
    }

    public function handlerStatement(): ?HandlerStatementContext
    {
        return $this->getTypedRuleContext(HandlerStatementContext::class, 0);
    }

    public function valuesStatement(): ?ValuesStatementContext
    {
        return $this->getTypedRuleContext(ValuesStatementContext::class, 0);
    }

    public function withStatement(): ?WithStatementContext
    {
        return $this->getTypedRuleContext(WithStatementContext::class, 0);
    }

    public function tableStatement(): ?TableStatementContext
    {
        return $this->getTypedRuleContext(TableStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDmlStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDmlStatement($this);
        }
    }
}

class TransactionStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_transactionStatement;
    }

    public function startTransaction(): ?StartTransactionContext
    {
        return $this->getTypedRuleContext(StartTransactionContext::class, 0);
    }

    public function beginWork(): ?BeginWorkContext
    {
        return $this->getTypedRuleContext(BeginWorkContext::class, 0);
    }

    public function commitWork(): ?CommitWorkContext
    {
        return $this->getTypedRuleContext(CommitWorkContext::class, 0);
    }

    public function rollbackWork(): ?RollbackWorkContext
    {
        return $this->getTypedRuleContext(RollbackWorkContext::class, 0);
    }

    public function savepointStatement(): ?SavepointStatementContext
    {
        return $this->getTypedRuleContext(SavepointStatementContext::class, 0);
    }

    public function rollbackStatement(): ?RollbackStatementContext
    {
        return $this->getTypedRuleContext(RollbackStatementContext::class, 0);
    }

    public function releaseStatement(): ?ReleaseStatementContext
    {
        return $this->getTypedRuleContext(ReleaseStatementContext::class, 0);
    }

    public function lockTables(): ?LockTablesContext
    {
        return $this->getTypedRuleContext(LockTablesContext::class, 0);
    }

    public function unlockTables(): ?UnlockTablesContext
    {
        return $this->getTypedRuleContext(UnlockTablesContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTransactionStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTransactionStatement($this);
        }
    }
}

class ReplicationStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_replicationStatement;
    }

    public function changeMaster(): ?ChangeMasterContext
    {
        return $this->getTypedRuleContext(ChangeMasterContext::class, 0);
    }

    public function changeReplicationFilter(): ?ChangeReplicationFilterContext
    {
        return $this->getTypedRuleContext(ChangeReplicationFilterContext::class, 0);
    }

    public function purgeBinaryLogs(): ?PurgeBinaryLogsContext
    {
        return $this->getTypedRuleContext(PurgeBinaryLogsContext::class, 0);
    }

    public function resetMaster(): ?ResetMasterContext
    {
        return $this->getTypedRuleContext(ResetMasterContext::class, 0);
    }

    public function resetSlave(): ?ResetSlaveContext
    {
        return $this->getTypedRuleContext(ResetSlaveContext::class, 0);
    }

    public function startSlave(): ?StartSlaveContext
    {
        return $this->getTypedRuleContext(StartSlaveContext::class, 0);
    }

    public function stopSlave(): ?StopSlaveContext
    {
        return $this->getTypedRuleContext(StopSlaveContext::class, 0);
    }

    public function startGroupReplication(): ?StartGroupReplicationContext
    {
        return $this->getTypedRuleContext(StartGroupReplicationContext::class, 0);
    }

    public function stopGroupReplication(): ?StopGroupReplicationContext
    {
        return $this->getTypedRuleContext(StopGroupReplicationContext::class, 0);
    }

    public function xaStartTransaction(): ?XaStartTransactionContext
    {
        return $this->getTypedRuleContext(XaStartTransactionContext::class, 0);
    }

    public function xaEndTransaction(): ?XaEndTransactionContext
    {
        return $this->getTypedRuleContext(XaEndTransactionContext::class, 0);
    }

    public function xaPrepareStatement(): ?XaPrepareStatementContext
    {
        return $this->getTypedRuleContext(XaPrepareStatementContext::class, 0);
    }

    public function xaCommitWork(): ?XaCommitWorkContext
    {
        return $this->getTypedRuleContext(XaCommitWorkContext::class, 0);
    }

    public function xaRollbackWork(): ?XaRollbackWorkContext
    {
        return $this->getTypedRuleContext(XaRollbackWorkContext::class, 0);
    }

    public function xaRecoverWork(): ?XaRecoverWorkContext
    {
        return $this->getTypedRuleContext(XaRecoverWorkContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterReplicationStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitReplicationStatement($this);
        }
    }
}

class PreparedStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_preparedStatement;
    }

    public function prepareStatement(): ?PrepareStatementContext
    {
        return $this->getTypedRuleContext(PrepareStatementContext::class, 0);
    }

    public function executeStatement(): ?ExecuteStatementContext
    {
        return $this->getTypedRuleContext(ExecuteStatementContext::class, 0);
    }

    public function deallocatePrepare(): ?DeallocatePrepareContext
    {
        return $this->getTypedRuleContext(DeallocatePrepareContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPreparedStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPreparedStatement($this);
        }
    }
}

class CompoundStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_compoundStatement;
    }

    public function blockStatement(): ?BlockStatementContext
    {
        return $this->getTypedRuleContext(BlockStatementContext::class, 0);
    }

    public function caseStatement(): ?CaseStatementContext
    {
        return $this->getTypedRuleContext(CaseStatementContext::class, 0);
    }

    public function ifStatement(): ?IfStatementContext
    {
        return $this->getTypedRuleContext(IfStatementContext::class, 0);
    }

    public function leaveStatement(): ?LeaveStatementContext
    {
        return $this->getTypedRuleContext(LeaveStatementContext::class, 0);
    }

    public function loopStatement(): ?LoopStatementContext
    {
        return $this->getTypedRuleContext(LoopStatementContext::class, 0);
    }

    public function repeatStatement(): ?RepeatStatementContext
    {
        return $this->getTypedRuleContext(RepeatStatementContext::class, 0);
    }

    public function whileStatement(): ?WhileStatementContext
    {
        return $this->getTypedRuleContext(WhileStatementContext::class, 0);
    }

    public function iterateStatement(): ?IterateStatementContext
    {
        return $this->getTypedRuleContext(IterateStatementContext::class, 0);
    }

    public function returnStatement(): ?ReturnStatementContext
    {
        return $this->getTypedRuleContext(ReturnStatementContext::class, 0);
    }

    public function cursorStatement(): ?CursorStatementContext
    {
        return $this->getTypedRuleContext(CursorStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCompoundStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCompoundStatement($this);
        }
    }
}

class AdministrationStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_administrationStatement;
    }

    public function alterUser(): ?AlterUserContext
    {
        return $this->getTypedRuleContext(AlterUserContext::class, 0);
    }

    public function createUser(): ?CreateUserContext
    {
        return $this->getTypedRuleContext(CreateUserContext::class, 0);
    }

    public function dropUser(): ?DropUserContext
    {
        return $this->getTypedRuleContext(DropUserContext::class, 0);
    }

    public function grantStatement(): ?GrantStatementContext
    {
        return $this->getTypedRuleContext(GrantStatementContext::class, 0);
    }

    public function grantProxy(): ?GrantProxyContext
    {
        return $this->getTypedRuleContext(GrantProxyContext::class, 0);
    }

    public function renameUser(): ?RenameUserContext
    {
        return $this->getTypedRuleContext(RenameUserContext::class, 0);
    }

    public function revokeStatement(): ?RevokeStatementContext
    {
        return $this->getTypedRuleContext(RevokeStatementContext::class, 0);
    }

    public function revokeProxy(): ?RevokeProxyContext
    {
        return $this->getTypedRuleContext(RevokeProxyContext::class, 0);
    }

    public function analyzeTable(): ?AnalyzeTableContext
    {
        return $this->getTypedRuleContext(AnalyzeTableContext::class, 0);
    }

    public function checkTable(): ?CheckTableContext
    {
        return $this->getTypedRuleContext(CheckTableContext::class, 0);
    }

    public function checksumTable(): ?ChecksumTableContext
    {
        return $this->getTypedRuleContext(ChecksumTableContext::class, 0);
    }

    public function optimizeTable(): ?OptimizeTableContext
    {
        return $this->getTypedRuleContext(OptimizeTableContext::class, 0);
    }

    public function repairTable(): ?RepairTableContext
    {
        return $this->getTypedRuleContext(RepairTableContext::class, 0);
    }

    public function createUdfunction(): ?CreateUdfunctionContext
    {
        return $this->getTypedRuleContext(CreateUdfunctionContext::class, 0);
    }

    public function installPlugin(): ?InstallPluginContext
    {
        return $this->getTypedRuleContext(InstallPluginContext::class, 0);
    }

    public function uninstallPlugin(): ?UninstallPluginContext
    {
        return $this->getTypedRuleContext(UninstallPluginContext::class, 0);
    }

    public function setStatement(): ?SetStatementContext
    {
        return $this->getTypedRuleContext(SetStatementContext::class, 0);
    }

    public function showStatement(): ?ShowStatementContext
    {
        return $this->getTypedRuleContext(ShowStatementContext::class, 0);
    }

    public function binlogStatement(): ?BinlogStatementContext
    {
        return $this->getTypedRuleContext(BinlogStatementContext::class, 0);
    }

    public function cacheIndexStatement(): ?CacheIndexStatementContext
    {
        return $this->getTypedRuleContext(CacheIndexStatementContext::class, 0);
    }

    public function flushStatement(): ?FlushStatementContext
    {
        return $this->getTypedRuleContext(FlushStatementContext::class, 0);
    }

    public function killStatement(): ?KillStatementContext
    {
        return $this->getTypedRuleContext(KillStatementContext::class, 0);
    }

    public function loadIndexIntoCache(): ?LoadIndexIntoCacheContext
    {
        return $this->getTypedRuleContext(LoadIndexIntoCacheContext::class, 0);
    }

    public function resetStatement(): ?ResetStatementContext
    {
        return $this->getTypedRuleContext(ResetStatementContext::class, 0);
    }

    public function shutdownStatement(): ?ShutdownStatementContext
    {
        return $this->getTypedRuleContext(ShutdownStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAdministrationStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAdministrationStatement($this);
        }
    }
}

class UtilityStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_utilityStatement;
    }

    public function simpleDescribeStatement(): ?SimpleDescribeStatementContext
    {
        return $this->getTypedRuleContext(SimpleDescribeStatementContext::class, 0);
    }

    public function fullDescribeStatement(): ?FullDescribeStatementContext
    {
        return $this->getTypedRuleContext(FullDescribeStatementContext::class, 0);
    }

    public function helpStatement(): ?HelpStatementContext
    {
        return $this->getTypedRuleContext(HelpStatementContext::class, 0);
    }

    public function useStatement(): ?UseStatementContext
    {
        return $this->getTypedRuleContext(UseStatementContext::class, 0);
    }

    public function signalStatement(): ?SignalStatementContext
    {
        return $this->getTypedRuleContext(SignalStatementContext::class, 0);
    }

    public function resignalStatement(): ?ResignalStatementContext
    {
        return $this->getTypedRuleContext(ResignalStatementContext::class, 0);
    }

    public function diagnosticsStatement(): ?DiagnosticsStatementContext
    {
        return $this->getTypedRuleContext(DiagnosticsStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUtilityStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUtilityStatement($this);
        }
    }
}

class CreateDatabaseContext extends ParserRuleContext
{
    /**
     * @var Token|null $dbFormat
     */
    public $dbFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createDatabase;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function DATABASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASE, 0);
    }

    public function SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA, 0);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    /**
     * @return array<CreateDatabaseOptionContext>|CreateDatabaseOptionContext|null
     */
    public function createDatabaseOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CreateDatabaseOptionContext::class);
        }

        return $this->getTypedRuleContext(CreateDatabaseOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateDatabase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateDatabase($this);
        }
    }
}

class CreateEventContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createEvent;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function EVENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENT, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ON(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ON);
        }

        return $this->getToken(MySqlParser::ON, $index);
    }

    public function SCHEDULE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEDULE, 0);
    }

    public function scheduleExpression(): ?ScheduleExpressionContext
    {
        return $this->getTypedRuleContext(ScheduleExpressionContext::class, 0);
    }

    public function DO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DO, 0);
    }

    public function routineBody(): ?RoutineBodyContext
    {
        return $this->getTypedRuleContext(RoutineBodyContext::class, 0);
    }

    public function ownerStatement(): ?OwnerStatementContext
    {
        return $this->getTypedRuleContext(OwnerStatementContext::class, 0);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    public function COMPLETION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPLETION, 0);
    }

    public function PRESERVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRESERVE, 0);
    }

    public function enableType(): ?EnableTypeContext
    {
        return $this->getTypedRuleContext(EnableTypeContext::class, 0);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateEvent($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateEvent($this);
        }
    }
}

class CreateIndexContext extends ParserRuleContext
{
    /**
     * @var Token|null $intimeAction
     */
    public $intimeAction;

    /**
     * @var Token|null $indexCategory
     */
    public $indexCategory;

    /**
     * @var Token|null $algType
     */
    public $algType;

    /**
     * @var Token|null $lockType
     */
    public $lockType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createIndex;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function indexType(): ?IndexTypeContext
    {
        return $this->getTypedRuleContext(IndexTypeContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ALGORITHM(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ALGORITHM);
        }

        return $this->getToken(MySqlParser::ALGORITHM, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LOCK(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LOCK);
        }

        return $this->getToken(MySqlParser::LOCK, $index);
    }

    public function ONLINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONLINE, 0);
    }

    public function OFFLINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OFFLINE, 0);
    }

    public function UNIQUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNIQUE, 0);
    }

    public function FULLTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FULLTEXT, 0);
    }

    public function SPATIAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SPATIAL, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function DEFAULT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::DEFAULT);
        }

        return $this->getToken(MySqlParser::DEFAULT, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function INPLACE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::INPLACE);
        }

        return $this->getToken(MySqlParser::INPLACE, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COPY(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COPY);
        }

        return $this->getToken(MySqlParser::COPY, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function NONE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::NONE);
        }

        return $this->getToken(MySqlParser::NONE, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function SHARED(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::SHARED);
        }

        return $this->getToken(MySqlParser::SHARED, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EXCLUSIVE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EXCLUSIVE);
        }

        return $this->getToken(MySqlParser::EXCLUSIVE, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateIndex($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateIndex($this);
        }
    }
}

class CreateLogfileGroupContext extends ParserRuleContext
{
    /**
     * @var Token|null $undoFile
     */
    public $undoFile;

    /**
     * @var Token|null $comment
     */
    public $comment;

    /**
     * @var FileSizeLiteralContext|null $initSize
     */
    public $initSize;

    /**
     * @var FileSizeLiteralContext|null $undoSize
     */
    public $undoSize;

    /**
     * @var FileSizeLiteralContext|null $redoSize
     */
    public $redoSize;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createLogfileGroup;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function LOGFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGFILE, 0);
    }

    public function GROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function UNDOFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDOFILE, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STRING_LITERAL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STRING_LITERAL);
        }

        return $this->getToken(MySqlParser::STRING_LITERAL, $index);
    }

    public function INITIAL_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INITIAL_SIZE, 0);
    }

    public function UNDO_BUFFER_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDO_BUFFER_SIZE, 0);
    }

    public function REDO_BUFFER_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REDO_BUFFER_SIZE, 0);
    }

    public function NODEGROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NODEGROUP, 0);
    }

    public function WAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WAIT, 0);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    /**
     * @return array<FileSizeLiteralContext>|FileSizeLiteralContext|null
     */
    public function fileSizeLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FileSizeLiteralContext::class);
        }

        return $this->getTypedRuleContext(FileSizeLiteralContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateLogfileGroup($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateLogfileGroup($this);
        }
    }
}

class CreateProcedureContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createProcedure;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function PROCEDURE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCEDURE, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function routineBody(): ?RoutineBodyContext
    {
        return $this->getTypedRuleContext(RoutineBodyContext::class, 0);
    }

    public function ownerStatement(): ?OwnerStatementContext
    {
        return $this->getTypedRuleContext(OwnerStatementContext::class, 0);
    }

    /**
     * @return array<ProcedureParameterContext>|ProcedureParameterContext|null
     */
    public function procedureParameter(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureParameterContext::class);
        }

        return $this->getTypedRuleContext(ProcedureParameterContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    /**
     * @return array<RoutineOptionContext>|RoutineOptionContext|null
     */
    public function routineOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RoutineOptionContext::class);
        }

        return $this->getTypedRuleContext(RoutineOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateProcedure($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateProcedure($this);
        }
    }
}

class CreateFunctionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createFunction;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function RETURNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RETURNS, 0);
    }

    public function dataType(): ?DataTypeContext
    {
        return $this->getTypedRuleContext(DataTypeContext::class, 0);
    }

    public function routineBody(): ?RoutineBodyContext
    {
        return $this->getTypedRuleContext(RoutineBodyContext::class, 0);
    }

    public function returnStatement(): ?ReturnStatementContext
    {
        return $this->getTypedRuleContext(ReturnStatementContext::class, 0);
    }

    public function ownerStatement(): ?OwnerStatementContext
    {
        return $this->getTypedRuleContext(OwnerStatementContext::class, 0);
    }

    public function AGGREGATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AGGREGATE, 0);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    /**
     * @return array<FunctionParameterContext>|FunctionParameterContext|null
     */
    public function functionParameter(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FunctionParameterContext::class);
        }

        return $this->getTypedRuleContext(FunctionParameterContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    /**
     * @return array<RoutineOptionContext>|RoutineOptionContext|null
     */
    public function routineOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RoutineOptionContext::class);
        }

        return $this->getTypedRuleContext(RoutineOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateFunction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateFunction($this);
        }
    }
}

class CreateRoleContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createRole;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function ROLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE, 0);
    }

    /**
     * @return array<RoleNameContext>|RoleNameContext|null
     */
    public function roleName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RoleNameContext::class);
        }

        return $this->getTypedRuleContext(RoleNameContext::class, $index);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateRole($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateRole($this);
        }
    }
}

class CreateServerContext extends ParserRuleContext
{
    /**
     * @var Token|null $wrapperName
     */
    public $wrapperName;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createServer;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function SERVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERVER, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function FOREIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOREIGN, 0);
    }

    public function DATA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATA, 0);
    }

    public function WRAPPER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WRAPPER, 0);
    }

    public function OPTIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIONS, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<ServerOptionContext>|ServerOptionContext|null
     */
    public function serverOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ServerOptionContext::class);
        }

        return $this->getTypedRuleContext(ServerOptionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function MYSQL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MYSQL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateServer($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateServer($this);
        }
    }
}

class CreateTableContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createTable;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class CopyCreateTableContext extends CreateTableContext
{
    /**
     * @var TableNameContext|null $parenthesisTable
     */
    public $parenthesisTable;

    public function __construct(CreateTableContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    /**
     * @return array<TableNameContext>|TableNameContext|null
     */
    public function tableName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableNameContext::class);
        }

        return $this->getTypedRuleContext(TableNameContext::class, $index);
    }

    public function LIKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIKE, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function TEMPORARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPORARY, 0);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCopyCreateTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCopyCreateTable($this);
        }
    }
}

class ColumnCreateTableContext extends CreateTableContext
{
    public function __construct(CreateTableContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function createDefinitions(): ?CreateDefinitionsContext
    {
        return $this->getTypedRuleContext(CreateDefinitionsContext::class, 0);
    }

    public function TEMPORARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPORARY, 0);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    /**
     * @return array<TableOptionContext>|TableOptionContext|null
     */
    public function tableOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableOptionContext::class);
        }

        return $this->getTypedRuleContext(TableOptionContext::class, $index);
    }

    public function partitionDefinitions(): ?PartitionDefinitionsContext
    {
        return $this->getTypedRuleContext(PartitionDefinitionsContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterColumnCreateTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitColumnCreateTable($this);
        }
    }
}

class QueryCreateTableContext extends CreateTableContext
{
    /**
     * @var Token|null $keyViolate
     */
    public $keyViolate;

    public function __construct(CreateTableContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function TEMPORARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPORARY, 0);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    public function createDefinitions(): ?CreateDefinitionsContext
    {
        return $this->getTypedRuleContext(CreateDefinitionsContext::class, 0);
    }

    /**
     * @return array<TableOptionContext>|TableOptionContext|null
     */
    public function tableOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableOptionContext::class);
        }

        return $this->getTypedRuleContext(TableOptionContext::class, $index);
    }

    public function partitionDefinitions(): ?PartitionDefinitionsContext
    {
        return $this->getTypedRuleContext(PartitionDefinitionsContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    public function REPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLACE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterQueryCreateTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitQueryCreateTable($this);
        }
    }
}

class CreateTablespaceInnodbContext extends ParserRuleContext
{
    /**
     * @var Token|null $datafile
     */
    public $datafile;

    /**
     * @var FileSizeLiteralContext|null $fileBlockSize
     */
    public $fileBlockSize;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createTablespaceInnodb;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function DATAFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATAFILE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function FILE_BLOCK_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FILE_BLOCK_SIZE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    public function fileSizeLiteral(): ?FileSizeLiteralContext
    {
        return $this->getTypedRuleContext(FileSizeLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateTablespaceInnodb($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateTablespaceInnodb($this);
        }
    }
}

class CreateTablespaceNdbContext extends ParserRuleContext
{
    /**
     * @var Token|null $datafile
     */
    public $datafile;

    /**
     * @var Token|null $comment
     */
    public $comment;

    /**
     * @var FileSizeLiteralContext|null $extentSize
     */
    public $extentSize;

    /**
     * @var FileSizeLiteralContext|null $initialSize
     */
    public $initialSize;

    /**
     * @var FileSizeLiteralContext|null $autoextendSize
     */
    public $autoextendSize;

    /**
     * @var FileSizeLiteralContext|null $maxSize
     */
    public $maxSize;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createTablespaceNdb;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function DATAFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATAFILE, 0);
    }

    public function USE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USE, 0);
    }

    public function LOGFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGFILE, 0);
    }

    public function GROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STRING_LITERAL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STRING_LITERAL);
        }

        return $this->getToken(MySqlParser::STRING_LITERAL, $index);
    }

    public function EXTENT_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTENT_SIZE, 0);
    }

    public function INITIAL_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INITIAL_SIZE, 0);
    }

    public function AUTOEXTEND_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTOEXTEND_SIZE, 0);
    }

    public function MAX_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_SIZE, 0);
    }

    public function NODEGROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NODEGROUP, 0);
    }

    public function WAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WAIT, 0);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    /**
     * @return array<FileSizeLiteralContext>|FileSizeLiteralContext|null
     */
    public function fileSizeLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FileSizeLiteralContext::class);
        }

        return $this->getTypedRuleContext(FileSizeLiteralContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateTablespaceNdb($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateTablespaceNdb($this);
        }
    }
}

class CreateTriggerContext extends ParserRuleContext
{
    /**
     * @var Token|null $triggerTime
     */
    public $triggerTime;

    /**
     * @var Token|null $triggerEvent
     */
    public $triggerEvent;

    /**
     * @var Token|null $triggerPlace
     */
    public $triggerPlace;

    /**
     * @var FullIdContext|null $thisTrigger
     */
    public $thisTrigger;

    /**
     * @var FullIdContext|null $otherTrigger
     */
    public $otherTrigger;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createTrigger;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function TRIGGER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRIGGER, 0);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function EACH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EACH, 0);
    }

    public function ROW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW, 0);
    }

    public function routineBody(): ?RoutineBodyContext
    {
        return $this->getTypedRuleContext(RoutineBodyContext::class, 0);
    }

    /**
     * @return array<FullIdContext>|FullIdContext|null
     */
    public function fullId(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FullIdContext::class);
        }

        return $this->getTypedRuleContext(FullIdContext::class, $index);
    }

    public function BEFORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BEFORE, 0);
    }

    public function AFTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AFTER, 0);
    }

    public function INSERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSERT, 0);
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function DELETE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELETE, 0);
    }

    public function ownerStatement(): ?OwnerStatementContext
    {
        return $this->getTypedRuleContext(OwnerStatementContext::class, 0);
    }

    public function FOLLOWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOLLOWS, 0);
    }

    public function PRECEDES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRECEDES, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateTrigger($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateTrigger($this);
        }
    }
}

class WithClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_withClause;
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function commonTableExpressions(): ?CommonTableExpressionsContext
    {
        return $this->getTypedRuleContext(CommonTableExpressionsContext::class, 0);
    }

    public function RECURSIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RECURSIVE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWithClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWithClause($this);
        }
    }
}

class CommonTableExpressionsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_commonTableExpressions;
    }

    public function cteName(): ?CteNameContext
    {
        return $this->getTypedRuleContext(CteNameContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    public function dmlStatement(): ?DmlStatementContext
    {
        return $this->getTypedRuleContext(DmlStatementContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    /**
     * @return array<CteColumnNameContext>|CteColumnNameContext|null
     */
    public function cteColumnName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CteColumnNameContext::class);
        }

        return $this->getTypedRuleContext(CteColumnNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function commonTableExpressions(): ?CommonTableExpressionsContext
    {
        return $this->getTypedRuleContext(CommonTableExpressionsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCommonTableExpressions($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCommonTableExpressions($this);
        }
    }
}

class CteNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_cteName;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCteName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCteName($this);
        }
    }
}

class CteColumnNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_cteColumnName;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCteColumnName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCteColumnName($this);
        }
    }
}

class CreateViewContext extends ParserRuleContext
{
    /**
     * @var Token|null $algType
     */
    public $algType;

    /**
     * @var Token|null $secContext
     */
    public $secContext;

    /**
     * @var Token|null $checkOption
     */
    public $checkOption;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createView;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function VIEW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VIEW, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    public function orReplace(): ?OrReplaceContext
    {
        return $this->getTypedRuleContext(OrReplaceContext::class, 0);
    }

    public function ALGORITHM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALGORITHM, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function ownerStatement(): ?OwnerStatementContext
    {
        return $this->getTypedRuleContext(OwnerStatementContext::class, 0);
    }

    public function SQL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL, 0);
    }

    public function SECURITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECURITY, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function UNDEFINED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDEFINED, 0);
    }

    public function MERGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MERGE, 0);
    }

    public function TEMPTABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPTABLE, 0);
    }

    public function DEFINER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFINER, 0);
    }

    public function INVOKER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVOKER, 0);
    }

    public function withClause(): ?WithClauseContext
    {
        return $this->getTypedRuleContext(WithClauseContext::class, 0);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    public function OPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTION, 0);
    }

    public function CASCADED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CASCADED, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateView($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateView($this);
        }
    }
}

class CreateDatabaseOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createDatabaseOption;
    }

    public function charSet(): ?CharSetContext
    {
        return $this->getTypedRuleContext(CharSetContext::class, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function DEFAULT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::DEFAULT);
        }

        return $this->getToken(MySqlParser::DEFAULT, $index);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function ENCRYPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCRYPTION, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function ONLY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONLY, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateDatabaseOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateDatabaseOption($this);
        }
    }
}

class CharSetContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_charSet;
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function CHARSET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARSET, 0);
    }

    public function CHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCharSet($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCharSet($this);
        }
    }
}

class CurrentUserExpressionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_currentUserExpression;
    }

    public function CURRENT_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_USER, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCurrentUserExpression($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCurrentUserExpression($this);
        }
    }
}

class OwnerStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_ownerStatement;
    }

    public function DEFINER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFINER, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function currentUserExpression(): ?CurrentUserExpressionContext
    {
        return $this->getTypedRuleContext(CurrentUserExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterOwnerStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitOwnerStatement($this);
        }
    }
}

class ScheduleExpressionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_scheduleExpression;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class PreciseScheduleContext extends ScheduleExpressionContext
{
    public function __construct(ScheduleExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function AT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AT, 0);
    }

    public function timestampValue(): ?TimestampValueContext
    {
        return $this->getTypedRuleContext(TimestampValueContext::class, 0);
    }

    /**
     * @return array<IntervalExprContext>|IntervalExprContext|null
     */
    public function intervalExpr(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IntervalExprContext::class);
        }

        return $this->getTypedRuleContext(IntervalExprContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPreciseSchedule($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPreciseSchedule($this);
        }
    }
}

class IntervalScheduleContext extends ScheduleExpressionContext
{
    /**
     * @var TimestampValueContext|null $startTimestamp
     */
    public $startTimestamp;

    /**
     * @var IntervalExprContext|null $intervalExpr
     */
    public $intervalExpr;

    /**
     * @var TimestampValueContext|null $endTimestamp
     */
    public $endTimestamp;

    /**
     * @var array<IntervalExprContext>|null $startIntervals
     */
    public $startIntervals;

    /**
     * @var array<IntervalExprContext>|null $endIntervals
     */
    public $endIntervals;

    public function __construct(ScheduleExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function EVERY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVERY, 0);
    }

    public function intervalType(): ?IntervalTypeContext
    {
        return $this->getTypedRuleContext(IntervalTypeContext::class, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function STARTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STARTS, 0);
    }

    public function ENDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENDS, 0);
    }

    /**
     * @return array<TimestampValueContext>|TimestampValueContext|null
     */
    public function timestampValue(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TimestampValueContext::class);
        }

        return $this->getTypedRuleContext(TimestampValueContext::class, $index);
    }

    /**
     * @return array<IntervalExprContext>|IntervalExprContext|null
     */
    public function intervalExpr(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IntervalExprContext::class);
        }

        return $this->getTypedRuleContext(IntervalExprContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIntervalSchedule($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIntervalSchedule($this);
        }
    }
}

class TimestampValueContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_timestampValue;
    }

    public function CURRENT_TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_TIMESTAMP, 0);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTimestampValue($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTimestampValue($this);
        }
    }
}

class IntervalExprContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_intervalExpr;
    }

    public function PLUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUS, 0);
    }

    public function INTERVAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTERVAL, 0);
    }

    public function intervalType(): ?IntervalTypeContext
    {
        return $this->getTypedRuleContext(IntervalTypeContext::class, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIntervalExpr($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIntervalExpr($this);
        }
    }
}

class IntervalTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_intervalType;
    }

    public function intervalTypeBase(): ?IntervalTypeBaseContext
    {
        return $this->getTypedRuleContext(IntervalTypeBaseContext::class, 0);
    }

    public function YEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::YEAR, 0);
    }

    public function YEAR_MONTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::YEAR_MONTH, 0);
    }

    public function DAY_HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAY_HOUR, 0);
    }

    public function DAY_MINUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAY_MINUTE, 0);
    }

    public function DAY_SECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAY_SECOND, 0);
    }

    public function HOUR_MINUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOUR_MINUTE, 0);
    }

    public function HOUR_SECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOUR_SECOND, 0);
    }

    public function MINUTE_SECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUTE_SECOND, 0);
    }

    public function SECOND_MICROSECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECOND_MICROSECOND, 0);
    }

    public function MINUTE_MICROSECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUTE_MICROSECOND, 0);
    }

    public function HOUR_MICROSECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOUR_MICROSECOND, 0);
    }

    public function DAY_MICROSECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAY_MICROSECOND, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIntervalType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIntervalType($this);
        }
    }
}

class EnableTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_enableType;
    }

    public function ENABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENABLE, 0);
    }

    public function DISABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISABLE, 0);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function SLAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLAVE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterEnableType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitEnableType($this);
        }
    }
}

class IndexTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_indexType;
    }

    public function USING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USING, 0);
    }

    public function BTREE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BTREE, 0);
    }

    public function HASH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HASH, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIndexType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIndexType($this);
        }
    }
}

class IndexOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_indexOption;
    }

    public function KEY_BLOCK_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY_BLOCK_SIZE, 0);
    }

    public function fileSizeLiteral(): ?FileSizeLiteralContext
    {
        return $this->getTypedRuleContext(FileSizeLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function indexType(): ?IndexTypeContext
    {
        return $this->getTypedRuleContext(IndexTypeContext::class, 0);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function PARSER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARSER, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function VISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VISIBLE, 0);
    }

    public function INVISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVISIBLE, 0);
    }

    public function ENGINE_ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE_ATTRIBUTE, 0);
    }

    public function SECONDARY_ENGINE_ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECONDARY_ENGINE_ATTRIBUTE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIndexOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIndexOption($this);
        }
    }
}

class ProcedureParameterContext extends ParserRuleContext
{
    /**
     * @var Token|null $direction
     */
    public $direction;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_procedureParameter;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function dataType(): ?DataTypeContext
    {
        return $this->getTypedRuleContext(DataTypeContext::class, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    public function OUT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OUT, 0);
    }

    public function INOUT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INOUT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterProcedureParameter($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitProcedureParameter($this);
        }
    }
}

class FunctionParameterContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_functionParameter;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function dataType(): ?DataTypeContext
    {
        return $this->getTypedRuleContext(DataTypeContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFunctionParameter($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFunctionParameter($this);
        }
    }
}

class RoutineOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_routineOption;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class RoutineBehaviorContext extends RoutineOptionContext
{
    public function __construct(RoutineOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DETERMINISTIC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DETERMINISTIC, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoutineBehavior($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoutineBehavior($this);
        }
    }
}

class RoutineLanguageContext extends RoutineOptionContext
{
    public function __construct(RoutineOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LANGUAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LANGUAGE, 0);
    }

    public function SQL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoutineLanguage($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoutineLanguage($this);
        }
    }
}

class RoutineCommentContext extends RoutineOptionContext
{
    public function __construct(RoutineOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoutineComment($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoutineComment($this);
        }
    }
}

class RoutineSecurityContext extends RoutineOptionContext
{
    /**
     * @var Token|null $context
     */
    public $context;

    public function __construct(RoutineOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SQL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL, 0);
    }

    public function SECURITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECURITY, 0);
    }

    public function DEFINER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFINER, 0);
    }

    public function INVOKER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVOKER, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoutineSecurity($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoutineSecurity($this);
        }
    }
}

class RoutineDataContext extends RoutineOptionContext
{
    public function __construct(RoutineOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CONTAINS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONTAINS, 0);
    }

    public function SQL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL, 0);
    }

    public function NO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NO, 0);
    }

    public function READS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READS, 0);
    }

    public function DATA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATA, 0);
    }

    public function MODIFIES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MODIFIES, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoutineData($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoutineData($this);
        }
    }
}

class ServerOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_serverOption;
    }

    public function HOST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOST, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function DATABASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASE, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function SOCKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOCKET, 0);
    }

    public function OWNER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OWNER, 0);
    }

    public function PORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PORT, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterServerOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitServerOption($this);
        }
    }
}

class CreateDefinitionsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createDefinitions;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<CreateDefinitionContext>|CreateDefinitionContext|null
     */
    public function createDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CreateDefinitionContext::class);
        }

        return $this->getTypedRuleContext(CreateDefinitionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateDefinitions($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateDefinitions($this);
        }
    }
}

class CreateDefinitionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createDefinition;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class ColumnDeclarationContext extends CreateDefinitionContext
{
    public function __construct(CreateDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function fullColumnName(): ?FullColumnNameContext
    {
        return $this->getTypedRuleContext(FullColumnNameContext::class, 0);
    }

    public function columnDefinition(): ?ColumnDefinitionContext
    {
        return $this->getTypedRuleContext(ColumnDefinitionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterColumnDeclaration($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitColumnDeclaration($this);
        }
    }
}

class ConstraintDeclarationContext extends CreateDefinitionContext
{
    public function __construct(CreateDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function tableConstraint(): ?TableConstraintContext
    {
        return $this->getTypedRuleContext(TableConstraintContext::class, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function ENFORCED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENFORCED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterConstraintDeclaration($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitConstraintDeclaration($this);
        }
    }
}

class IndexDeclarationContext extends CreateDefinitionContext
{
    public function __construct(CreateDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function indexColumnDefinition(): ?IndexColumnDefinitionContext
    {
        return $this->getTypedRuleContext(IndexColumnDefinitionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIndexDeclaration($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIndexDeclaration($this);
        }
    }
}

class ColumnDefinitionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_columnDefinition;
    }

    public function dataType(): ?DataTypeContext
    {
        return $this->getTypedRuleContext(DataTypeContext::class, 0);
    }

    /**
     * @return array<ColumnConstraintContext>|ColumnConstraintContext|null
     */
    public function columnConstraint(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ColumnConstraintContext::class);
        }

        return $this->getTypedRuleContext(ColumnConstraintContext::class, $index);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function ENFORCED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENFORCED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterColumnDefinition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitColumnDefinition($this);
        }
    }
}

class ColumnConstraintContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_columnConstraint;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class StorageColumnConstraintContext extends ColumnConstraintContext
{
    /**
     * @var Token|null $storageval
     */
    public $storageval;

    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function STORAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STORAGE, 0);
    }

    public function DISK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISK, 0);
    }

    public function MEMORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEMORY, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStorageColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStorageColumnConstraint($this);
        }
    }
}

class VisibilityColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function VISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VISIBLE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterVisibilityColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitVisibilityColumnConstraint($this);
        }
    }
}

class AutoIncrementColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function AUTO_INCREMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTO_INCREMENT, 0);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function currentTimestamp(): ?CurrentTimestampContext
    {
        return $this->getTypedRuleContext(CurrentTimestampContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAutoIncrementColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAutoIncrementColumnConstraint($this);
        }
    }
}

class CommentColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCommentColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCommentColumnConstraint($this);
        }
    }
}

class UniqueKeyColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function UNIQUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNIQUE, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUniqueKeyColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUniqueKeyColumnConstraint($this);
        }
    }
}

class SerialDefaultColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SERIAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERIAL, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSerialDefaultColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSerialDefaultColumnConstraint($this);
        }
    }
}

class GeneratedColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function GENERATED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GENERATED, 0);
    }

    public function ALWAYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALWAYS, 0);
    }

    public function VIRTUAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VIRTUAL, 0);
    }

    public function STORED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STORED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGeneratedColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGeneratedColumnConstraint($this);
        }
    }
}

class FormatColumnConstraintContext extends ColumnConstraintContext
{
    /**
     * @var Token|null $colformat
     */
    public $colformat;

    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COLUMN_FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN_FORMAT, 0);
    }

    public function FIXED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIXED, 0);
    }

    public function DYNAMIC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DYNAMIC, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFormatColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFormatColumnConstraint($this);
        }
    }
}

class CollateColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCollateColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCollateColumnConstraint($this);
        }
    }
}

class PrimaryKeyColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function PRIMARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIMARY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPrimaryKeyColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPrimaryKeyColumnConstraint($this);
        }
    }
}

class CheckColumnConstraintContext extends ColumnConstraintContext
{
    /**
     * @var UidContext|null $name
     */
    public $name;

    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCheckColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCheckColumnConstraint($this);
        }
    }
}

class NullColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function nullNotnull(): ?NullNotnullContext
    {
        return $this->getTypedRuleContext(NullNotnullContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNullColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNullColumnConstraint($this);
        }
    }
}

class DefaultColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function defaultValue(): ?DefaultValueContext
    {
        return $this->getTypedRuleContext(DefaultValueContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDefaultColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDefaultColumnConstraint($this);
        }
    }
}

class ReferenceColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function referenceDefinition(): ?ReferenceDefinitionContext
    {
        return $this->getTypedRuleContext(ReferenceDefinitionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterReferenceColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitReferenceColumnConstraint($this);
        }
    }
}

class InvisibilityColumnConstraintContext extends ColumnConstraintContext
{
    public function __construct(ColumnConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function INVISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVISIBLE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterInvisibilityColumnConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitInvisibilityColumnConstraint($this);
        }
    }
}

class TableConstraintContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableConstraint;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class UniqueKeyTableConstraintContext extends TableConstraintContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    /**
     * @var UidContext|null $name
     */
    public $name;

    /**
     * @var UidContext|null $index
     */
    public $index;

    public function __construct(TableConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function UNIQUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNIQUE, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function indexType(): ?IndexTypeContext
    {
        return $this->getTypedRuleContext(IndexTypeContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUniqueKeyTableConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUniqueKeyTableConstraint($this);
        }
    }
}

class CheckTableConstraintContext extends TableConstraintContext
{
    /**
     * @var UidContext|null $name
     */
    public $name;

    public function __construct(TableConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCheckTableConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCheckTableConstraint($this);
        }
    }
}

class PrimaryKeyTableConstraintContext extends TableConstraintContext
{
    /**
     * @var UidContext|null $name
     */
    public $name;

    /**
     * @var UidContext|null $index
     */
    public $index;

    public function __construct(TableConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PRIMARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIMARY, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function indexType(): ?IndexTypeContext
    {
        return $this->getTypedRuleContext(IndexTypeContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPrimaryKeyTableConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPrimaryKeyTableConstraint($this);
        }
    }
}

class ForeignKeyTableConstraintContext extends TableConstraintContext
{
    /**
     * @var UidContext|null $name
     */
    public $name;

    /**
     * @var UidContext|null $index
     */
    public $index;

    public function __construct(TableConstraintContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function FOREIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOREIGN, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function referenceDefinition(): ?ReferenceDefinitionContext
    {
        return $this->getTypedRuleContext(ReferenceDefinitionContext::class, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterForeignKeyTableConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitForeignKeyTableConstraint($this);
        }
    }
}

class ReferenceDefinitionContext extends ParserRuleContext
{
    /**
     * @var Token|null $matchType
     */
    public $matchType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_referenceDefinition;
    }

    public function REFERENCES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REFERENCES, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function MATCH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MATCH, 0);
    }

    public function referenceAction(): ?ReferenceActionContext
    {
        return $this->getTypedRuleContext(ReferenceActionContext::class, 0);
    }

    public function FULL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FULL, 0);
    }

    public function PARTIAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTIAL, 0);
    }

    public function SIMPLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SIMPLE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterReferenceDefinition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitReferenceDefinition($this);
        }
    }
}

class ReferenceActionContext extends ParserRuleContext
{
    /**
     * @var ReferenceControlTypeContext|null $onDelete
     */
    public $onDelete;

    /**
     * @var ReferenceControlTypeContext|null $onUpdate
     */
    public $onUpdate;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_referenceAction;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ON(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ON);
        }

        return $this->getToken(MySqlParser::ON, $index);
    }

    public function DELETE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELETE, 0);
    }

    /**
     * @return array<ReferenceControlTypeContext>|ReferenceControlTypeContext|null
     */
    public function referenceControlType(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ReferenceControlTypeContext::class);
        }

        return $this->getTypedRuleContext(ReferenceControlTypeContext::class, $index);
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterReferenceAction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitReferenceAction($this);
        }
    }
}

class ReferenceControlTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_referenceControlType;
    }

    public function RESTRICT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESTRICT, 0);
    }

    public function CASCADE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CASCADE, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function NULL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULL_LITERAL, 0);
    }

    public function NO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NO, 0);
    }

    public function ACTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ACTION, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterReferenceControlType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitReferenceControlType($this);
        }
    }
}

class IndexColumnDefinitionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_indexColumnDefinition;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SpecialIndexDeclarationContext extends IndexColumnDefinitionContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    public function __construct(IndexColumnDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function FULLTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FULLTEXT, 0);
    }

    public function SPATIAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SPATIAL, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSpecialIndexDeclaration($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSpecialIndexDeclaration($this);
        }
    }
}

class SimpleIndexDeclarationContext extends IndexColumnDefinitionContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    public function __construct(IndexColumnDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function indexType(): ?IndexTypeContext
    {
        return $this->getTypedRuleContext(IndexTypeContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleIndexDeclaration($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleIndexDeclaration($this);
        }
    }
}

class TableOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableOption;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class TableOptionEngineContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionEngine($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionEngine($this);
        }
    }
}

class TableOptionMaxRowsContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function MAX_ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_ROWS, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionMaxRows($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionMaxRows($this);
        }
    }
}

class TableOptionCollateContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionCollate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionCollate($this);
        }
    }
}

class TableOptionPersistentContext extends TableOptionContext
{
    /**
     * @var Token|null $extBoolValue
     */
    public $extBoolValue;

    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function STATS_PERSISTENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATS_PERSISTENT, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionPersistent($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionPersistent($this);
        }
    }
}

class TableOptionTablespaceContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function tablespaceStorage(): ?TablespaceStorageContext
    {
        return $this->getTypedRuleContext(TablespaceStorageContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionTablespace($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionTablespace($this);
        }
    }
}

class TableOptionAutoextendSizeContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function AUTOEXTEND_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTOEXTEND_SIZE, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionAutoextendSize($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionAutoextendSize($this);
        }
    }
}

class TableOptionPageCompressedContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PAGE_COMPRESSED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PAGE_COMPRESSED, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionPageCompressed($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionPageCompressed($this);
        }
    }
}

class TableOptionStartTransactionContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function START(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::START, 0);
    }

    public function TRANSACTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRANSACTION, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionStartTransaction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionStartTransaction($this);
        }
    }
}

class TableOptionPackKeysContext extends TableOptionContext
{
    /**
     * @var Token|null $extBoolValue
     */
    public $extBoolValue;

    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PACK_KEYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PACK_KEYS, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionPackKeys($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionPackKeys($this);
        }
    }
}

class TableOptionPasswordContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionPassword($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionPassword($this);
        }
    }
}

class TableOptionUnionContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function UNION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNION, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionUnion($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionUnion($this);
        }
    }
}

class TableOptionSamplePageContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function STATS_SAMPLE_PAGES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATS_SAMPLE_PAGES, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionSamplePage($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionSamplePage($this);
        }
    }
}

class TableOptionCharsetContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function charSet(): ?CharSetContext
    {
        return $this->getTypedRuleContext(CharSetContext::class, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function DEFAULT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::DEFAULT);
        }

        return $this->getToken(MySqlParser::DEFAULT, $index);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionCharset($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionCharset($this);
        }
    }
}

class TableOptionIndexDirectoryContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function DIRECTORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIRECTORY, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionIndexDirectory($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionIndexDirectory($this);
        }
    }
}

class TableOptionTableTypeContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function TABLE_TYPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE_TYPE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function tableType(): ?TableTypeContext
    {
        return $this->getTypedRuleContext(TableTypeContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionTableType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionTableType($this);
        }
    }
}

class TableOptionKeyBlockSizeContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function KEY_BLOCK_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY_BLOCK_SIZE, 0);
    }

    public function fileSizeLiteral(): ?FileSizeLiteralContext
    {
        return $this->getTypedRuleContext(FileSizeLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionKeyBlockSize($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionKeyBlockSize($this);
        }
    }
}

class TableOptionEncryptionContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ENCRYPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCRYPTION, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionEncryption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionEncryption($this);
        }
    }
}

class TableOptionDataDirectoryContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DIRECTORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIRECTORY, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function DATA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATA, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionDataDirectory($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionDataDirectory($this);
        }
    }
}

class TableOptionRecalculationContext extends TableOptionContext
{
    /**
     * @var Token|null $extBoolValue
     */
    public $extBoolValue;

    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function STATS_AUTO_RECALC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATS_AUTO_RECALC, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionRecalculation($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionRecalculation($this);
        }
    }
}

class TableOptionAutoIncrementContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function AUTO_INCREMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTO_INCREMENT, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionAutoIncrement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionAutoIncrement($this);
        }
    }
}

class TableOptionEncryptionKeyIdContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ENCRYPTION_KEY_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCRYPTION_KEY_ID, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionEncryptionKeyId($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionEncryptionKeyId($this);
        }
    }
}

class TableOptionChecksumContext extends TableOptionContext
{
    /**
     * @var Token|null $boolValue
     */
    public $boolValue;

    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CHECKSUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECKSUM, 0);
    }

    public function PAGE_CHECKSUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PAGE_CHECKSUM, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionChecksum($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionChecksum($this);
        }
    }
}

class TableOptionDelayContext extends TableOptionContext
{
    /**
     * @var Token|null $boolValue
     */
    public $boolValue;

    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DELAY_KEY_WRITE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELAY_KEY_WRITE, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionDelay($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionDelay($this);
        }
    }
}

class TableOptionConnectionContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CONNECTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECTION, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionConnection($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionConnection($this);
        }
    }
}

class TableOptionTransactionalContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function TRANSACTIONAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRANSACTIONAL, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionTransactional($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionTransactional($this);
        }
    }
}

class TableOptionPageCompressionLevelContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function PAGE_COMPRESSION_LEVEL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PAGE_COMPRESSION_LEVEL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionPageCompressionLevel($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionPageCompressionLevel($this);
        }
    }
}

class TableOptionSecondaryEngineAttributeContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SECONDARY_ENGINE_ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECONDARY_ENGINE_ATTRIBUTE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionSecondaryEngineAttribute($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionSecondaryEngineAttribute($this);
        }
    }
}

class TableOptionCommentContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionComment($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionComment($this);
        }
    }
}

class TableOptionAverageContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function AVG_ROW_LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AVG_ROW_LENGTH, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionAverage($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionAverage($this);
        }
    }
}

class TableOptionRowFormatContext extends TableOptionContext
{
    /**
     * @var Token|null $rowFormat
     */
    public $rowFormat;

    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ROW_FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW_FORMAT, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function DYNAMIC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DYNAMIC, 0);
    }

    public function FIXED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIXED, 0);
    }

    public function COMPRESSED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPRESSED, 0);
    }

    public function REDUNDANT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REDUNDANT, 0);
    }

    public function COMPACT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPACT, 0);
    }

    public function ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ID, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionRowFormat($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionRowFormat($this);
        }
    }
}

class TableOptionCompressionContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COMPRESSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPRESSION, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ID, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionCompression($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionCompression($this);
        }
    }
}

class TableOptionInsertMethodContext extends TableOptionContext
{
    /**
     * @var Token|null $insertMethod
     */
    public $insertMethod;

    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function INSERT_METHOD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSERT_METHOD, 0);
    }

    public function NO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NO, 0);
    }

    public function FIRST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST, 0);
    }

    public function LAST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAST, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionInsertMethod($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionInsertMethod($this);
        }
    }
}

class TableOptionEngineAttributeContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ENGINE_ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE_ATTRIBUTE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionEngineAttribute($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionEngineAttribute($this);
        }
    }
}

class TableOptionMinRowsContext extends TableOptionContext
{
    public function __construct(TableOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function MIN_ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MIN_ROWS, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableOptionMinRows($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableOptionMinRows($this);
        }
    }
}

class TableTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableType;
    }

    public function MYSQL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MYSQL, 0);
    }

    public function ODBC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ODBC, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableType($this);
        }
    }
}

class TablespaceStorageContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tablespaceStorage;
    }

    public function STORAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STORAGE, 0);
    }

    public function DISK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISK, 0);
    }

    public function MEMORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEMORY, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTablespaceStorage($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTablespaceStorage($this);
        }
    }
}

class PartitionDefinitionsContext extends ParserRuleContext
{
    /**
     * @var DecimalLiteralContext|null $count
     */
    public $count;

    /**
     * @var DecimalLiteralContext|null $subCount
     */
    public $subCount;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_partitionDefinitions;
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function BY(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::BY);
        }

        return $this->getToken(MySqlParser::BY, $index);
    }

    public function partitionFunctionDefinition(): ?PartitionFunctionDefinitionContext
    {
        return $this->getTypedRuleContext(PartitionFunctionDefinitionContext::class, 0);
    }

    public function PARTITIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITIONS, 0);
    }

    public function SUBPARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBPARTITION, 0);
    }

    public function subpartitionFunctionDefinition(): ?SubpartitionFunctionDefinitionContext
    {
        return $this->getTypedRuleContext(SubpartitionFunctionDefinitionContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<PartitionDefinitionContext>|PartitionDefinitionContext|null
     */
    public function partitionDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionDefinitionContext::class);
        }

        return $this->getTypedRuleContext(PartitionDefinitionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function SUBPARTITIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBPARTITIONS, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionDefinitions($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionDefinitions($this);
        }
    }
}

class PartitionFunctionDefinitionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_partitionFunctionDefinition;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class PartitionFunctionKeyContext extends PartitionFunctionDefinitionContext
{
    /**
     * @var Token|null $algType
     */
    public $algType;

    public function __construct(PartitionFunctionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function LINEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINEAR, 0);
    }

    public function ALGORITHM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALGORITHM, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function TWO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TWO_DECIMAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionFunctionKey($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionFunctionKey($this);
        }
    }
}

class PartitionFunctionHashContext extends PartitionFunctionDefinitionContext
{
    public function __construct(PartitionFunctionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function HASH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HASH, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function LINEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINEAR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionFunctionHash($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionFunctionHash($this);
        }
    }
}

class PartitionFunctionListContext extends PartitionFunctionDefinitionContext
{
    public function __construct(PartitionFunctionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LIST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIST, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function COLUMNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMNS, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionFunctionList($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionFunctionList($this);
        }
    }
}

class PartitionFunctionRangeContext extends PartitionFunctionDefinitionContext
{
    public function __construct(PartitionFunctionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function RANGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RANGE, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function COLUMNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMNS, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionFunctionRange($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionFunctionRange($this);
        }
    }
}

class SubpartitionFunctionDefinitionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_subpartitionFunctionDefinition;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SubPartitionFunctionHashContext extends SubpartitionFunctionDefinitionContext
{
    public function __construct(SubpartitionFunctionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function HASH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HASH, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function LINEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINEAR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSubPartitionFunctionHash($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSubPartitionFunctionHash($this);
        }
    }
}

class SubPartitionFunctionKeyContext extends SubpartitionFunctionDefinitionContext
{
    /**
     * @var Token|null $algType
     */
    public $algType;

    public function __construct(SubpartitionFunctionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function LINEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINEAR, 0);
    }

    public function ALGORITHM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALGORITHM, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function TWO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TWO_DECIMAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSubPartitionFunctionKey($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSubPartitionFunctionKey($this);
        }
    }
}

class PartitionDefinitionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_partitionDefinition;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class PartitionComparisonContext extends PartitionDefinitionContext
{
    public function __construct(PartitionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function VALUES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUES, 0);
    }

    public function LESS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LESS, 0);
    }

    public function THAN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::THAN, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<PartitionDefinerAtomContext>|PartitionDefinerAtomContext|null
     */
    public function partitionDefinerAtom(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionDefinerAtomContext::class);
        }

        return $this->getTypedRuleContext(PartitionDefinerAtomContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    /**
     * @return array<PartitionOptionContext>|PartitionOptionContext|null
     */
    public function partitionOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionOptionContext::class);
        }

        return $this->getTypedRuleContext(PartitionOptionContext::class, $index);
    }

    /**
     * @return array<SubpartitionDefinitionContext>|SubpartitionDefinitionContext|null
     */
    public function subpartitionDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SubpartitionDefinitionContext::class);
        }

        return $this->getTypedRuleContext(SubpartitionDefinitionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionComparison($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionComparison($this);
        }
    }
}

class PartitionListAtomContext extends PartitionDefinitionContext
{
    public function __construct(PartitionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function VALUES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUES, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<PartitionDefinerAtomContext>|PartitionDefinerAtomContext|null
     */
    public function partitionDefinerAtom(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionDefinerAtomContext::class);
        }

        return $this->getTypedRuleContext(PartitionDefinerAtomContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    /**
     * @return array<PartitionOptionContext>|PartitionOptionContext|null
     */
    public function partitionOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionOptionContext::class);
        }

        return $this->getTypedRuleContext(PartitionOptionContext::class, $index);
    }

    /**
     * @return array<SubpartitionDefinitionContext>|SubpartitionDefinitionContext|null
     */
    public function subpartitionDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SubpartitionDefinitionContext::class);
        }

        return $this->getTypedRuleContext(SubpartitionDefinitionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionListAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionListAtom($this);
        }
    }
}

class PartitionListVectorContext extends PartitionDefinitionContext
{
    public function __construct(PartitionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function VALUES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUES, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<PartitionDefinerVectorContext>|PartitionDefinerVectorContext|null
     */
    public function partitionDefinerVector(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionDefinerVectorContext::class);
        }

        return $this->getTypedRuleContext(PartitionDefinerVectorContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    /**
     * @return array<PartitionOptionContext>|PartitionOptionContext|null
     */
    public function partitionOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionOptionContext::class);
        }

        return $this->getTypedRuleContext(PartitionOptionContext::class, $index);
    }

    /**
     * @return array<SubpartitionDefinitionContext>|SubpartitionDefinitionContext|null
     */
    public function subpartitionDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SubpartitionDefinitionContext::class);
        }

        return $this->getTypedRuleContext(SubpartitionDefinitionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionListVector($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionListVector($this);
        }
    }
}

class PartitionSimpleContext extends PartitionDefinitionContext
{
    public function __construct(PartitionDefinitionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<PartitionOptionContext>|PartitionOptionContext|null
     */
    public function partitionOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionOptionContext::class);
        }

        return $this->getTypedRuleContext(PartitionOptionContext::class, $index);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<SubpartitionDefinitionContext>|SubpartitionDefinitionContext|null
     */
    public function subpartitionDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SubpartitionDefinitionContext::class);
        }

        return $this->getTypedRuleContext(SubpartitionDefinitionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionSimple($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionSimple($this);
        }
    }
}

class PartitionDefinerAtomContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_partitionDefinerAtom;
    }

    public function constant(): ?ConstantContext
    {
        return $this->getTypedRuleContext(ConstantContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function MAXVALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAXVALUE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionDefinerAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionDefinerAtom($this);
        }
    }
}

class PartitionDefinerVectorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_partitionDefinerVector;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<PartitionDefinerAtomContext>|PartitionDefinerAtomContext|null
     */
    public function partitionDefinerAtom(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionDefinerAtomContext::class);
        }

        return $this->getTypedRuleContext(PartitionDefinerAtomContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionDefinerVector($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionDefinerVector($this);
        }
    }
}

class SubpartitionDefinitionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_subpartitionDefinition;
    }

    public function SUBPARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBPARTITION, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<PartitionOptionContext>|PartitionOptionContext|null
     */
    public function partitionOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionOptionContext::class);
        }

        return $this->getTypedRuleContext(PartitionOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSubpartitionDefinition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSubpartitionDefinition($this);
        }
    }
}

class PartitionOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_partitionOption;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class PartitionOptionCommentContext extends PartitionOptionContext
{
    /**
     * @var Token|null $comment
     */
    public $comment;

    public function __construct(PartitionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionOptionComment($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionOptionComment($this);
        }
    }
}

class PartitionOptionNodeGroupContext extends PartitionOptionContext
{
    /**
     * @var UidContext|null $nodegroup
     */
    public $nodegroup;

    public function __construct(PartitionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function NODEGROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NODEGROUP, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionOptionNodeGroup($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionOptionNodeGroup($this);
        }
    }
}

class PartitionOptionIndexDirectoryContext extends PartitionOptionContext
{
    /**
     * @var Token|null $indexDirectory
     */
    public $indexDirectory;

    public function __construct(PartitionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function DIRECTORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIRECTORY, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionOptionIndexDirectory($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionOptionIndexDirectory($this);
        }
    }
}

class PartitionOptionMaxRowsContext extends PartitionOptionContext
{
    /**
     * @var DecimalLiteralContext|null $maxRows
     */
    public $maxRows;

    public function __construct(PartitionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function MAX_ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_ROWS, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionOptionMaxRows($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionOptionMaxRows($this);
        }
    }
}

class PartitionOptionTablespaceContext extends PartitionOptionContext
{
    /**
     * @var UidContext|null $tablespace
     */
    public $tablespace;

    public function __construct(PartitionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionOptionTablespace($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionOptionTablespace($this);
        }
    }
}

class PartitionOptionEngineContext extends PartitionOptionContext
{
    public function __construct(PartitionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function STORAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STORAGE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionOptionEngine($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionOptionEngine($this);
        }
    }
}

class PartitionOptionMinRowsContext extends PartitionOptionContext
{
    /**
     * @var DecimalLiteralContext|null $minRows
     */
    public $minRows;

    public function __construct(PartitionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function MIN_ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MIN_ROWS, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionOptionMinRows($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionOptionMinRows($this);
        }
    }
}

class PartitionOptionDataDirectoryContext extends PartitionOptionContext
{
    /**
     * @var Token|null $dataDirectory
     */
    public $dataDirectory;

    public function __construct(PartitionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DATA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATA, 0);
    }

    public function DIRECTORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIRECTORY, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionOptionDataDirectory($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionOptionDataDirectory($this);
        }
    }
}

class AlterDatabaseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterDatabase;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class AlterUpgradeNameContext extends AlterDatabaseContext
{
    /**
     * @var Token|null $dbFormat
     */
    public $dbFormat;

    public function __construct(AlterDatabaseContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function UPGRADE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPGRADE, 0);
    }

    public function DATA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATA, 0);
    }

    public function DIRECTORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIRECTORY, 0);
    }

    public function NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NAME, 0);
    }

    public function DATABASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASE, 0);
    }

    public function SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterUpgradeName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterUpgradeName($this);
        }
    }
}

class AlterSimpleDatabaseContext extends AlterDatabaseContext
{
    /**
     * @var Token|null $dbFormat
     */
    public $dbFormat;

    public function __construct(AlterDatabaseContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function DATABASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASE, 0);
    }

    public function SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<CreateDatabaseOptionContext>|CreateDatabaseOptionContext|null
     */
    public function createDatabaseOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CreateDatabaseOptionContext::class);
        }

        return $this->getTypedRuleContext(CreateDatabaseOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterSimpleDatabase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterSimpleDatabase($this);
        }
    }
}

class AlterEventContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterEvent;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function EVENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENT, 0);
    }

    /**
     * @return array<FullIdContext>|FullIdContext|null
     */
    public function fullId(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FullIdContext::class);
        }

        return $this->getTypedRuleContext(FullIdContext::class, $index);
    }

    public function ownerStatement(): ?OwnerStatementContext
    {
        return $this->getTypedRuleContext(OwnerStatementContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ON(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ON);
        }

        return $this->getToken(MySqlParser::ON, $index);
    }

    public function SCHEDULE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEDULE, 0);
    }

    public function scheduleExpression(): ?ScheduleExpressionContext
    {
        return $this->getTypedRuleContext(ScheduleExpressionContext::class, 0);
    }

    public function COMPLETION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPLETION, 0);
    }

    public function PRESERVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRESERVE, 0);
    }

    public function RENAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RENAME, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    public function enableType(): ?EnableTypeContext
    {
        return $this->getTypedRuleContext(EnableTypeContext::class, 0);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function DO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DO, 0);
    }

    public function routineBody(): ?RoutineBodyContext
    {
        return $this->getTypedRuleContext(RoutineBodyContext::class, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterEvent($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterEvent($this);
        }
    }
}

class AlterFunctionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterFunction;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    /**
     * @return array<RoutineOptionContext>|RoutineOptionContext|null
     */
    public function routineOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RoutineOptionContext::class);
        }

        return $this->getTypedRuleContext(RoutineOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterFunction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterFunction($this);
        }
    }
}

class AlterInstanceContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterInstance;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function INSTANCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSTANCE, 0);
    }

    public function ROTATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROTATE, 0);
    }

    public function INNODB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INNODB, 0);
    }

    public function MASTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterInstance($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterInstance($this);
        }
    }
}

class AlterLogfileGroupContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterLogfileGroup;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function LOGFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGFILE, 0);
    }

    public function GROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function UNDOFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDOFILE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    public function INITIAL_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INITIAL_SIZE, 0);
    }

    public function fileSizeLiteral(): ?FileSizeLiteralContext
    {
        return $this->getTypedRuleContext(FileSizeLiteralContext::class, 0);
    }

    public function WAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WAIT, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterLogfileGroup($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterLogfileGroup($this);
        }
    }
}

class AlterProcedureContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterProcedure;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function PROCEDURE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCEDURE, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    /**
     * @return array<RoutineOptionContext>|RoutineOptionContext|null
     */
    public function routineOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RoutineOptionContext::class);
        }

        return $this->getTypedRuleContext(RoutineOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterProcedure($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterProcedure($this);
        }
    }
}

class AlterServerContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterServer;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function SERVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERVER, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function OPTIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIONS, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<ServerOptionContext>|ServerOptionContext|null
     */
    public function serverOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ServerOptionContext::class);
        }

        return $this->getTypedRuleContext(ServerOptionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterServer($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterServer($this);
        }
    }
}

class AlterTableContext extends ParserRuleContext
{
    /**
     * @var Token|null $intimeAction
     */
    public $intimeAction;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterTable;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    public function waitNowaitClause(): ?WaitNowaitClauseContext
    {
        return $this->getTypedRuleContext(WaitNowaitClauseContext::class, 0);
    }

    /**
     * @return array<AlterSpecificationContext>|AlterSpecificationContext|null
     */
    public function alterSpecification(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(AlterSpecificationContext::class);
        }

        return $this->getTypedRuleContext(AlterSpecificationContext::class, $index);
    }

    public function partitionDefinitions(): ?PartitionDefinitionsContext
    {
        return $this->getTypedRuleContext(PartitionDefinitionsContext::class, 0);
    }

    public function ONLINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONLINE, 0);
    }

    public function OFFLINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OFFLINE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterTable($this);
        }
    }
}

class AlterTablespaceContext extends ParserRuleContext
{
    /**
     * @var Token|null $objectAction
     */
    public $objectAction;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterTablespace;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function DATAFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATAFILE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function INITIAL_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INITIAL_SIZE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function fileSizeLiteral(): ?FileSizeLiteralContext
    {
        return $this->getTypedRuleContext(FileSizeLiteralContext::class, 0);
    }

    public function WAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WAIT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterTablespace($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterTablespace($this);
        }
    }
}

class AlterViewContext extends ParserRuleContext
{
    /**
     * @var Token|null $algType
     */
    public $algType;

    /**
     * @var Token|null $secContext
     */
    public $secContext;

    /**
     * @var Token|null $checkOpt
     */
    public $checkOpt;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterView;
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function VIEW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VIEW, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function ALGORITHM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALGORITHM, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function ownerStatement(): ?OwnerStatementContext
    {
        return $this->getTypedRuleContext(OwnerStatementContext::class, 0);
    }

    public function SQL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL, 0);
    }

    public function SECURITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECURITY, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    public function OPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTION, 0);
    }

    public function UNDEFINED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDEFINED, 0);
    }

    public function MERGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MERGE, 0);
    }

    public function TEMPTABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPTABLE, 0);
    }

    public function DEFINER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFINER, 0);
    }

    public function INVOKER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVOKER, 0);
    }

    public function CASCADED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CASCADED, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterView($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterView($this);
        }
    }
}

class AlterSpecificationContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterSpecification;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class AlterByAlterColumnDefaultContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    public function VISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VISIBLE, 0);
    }

    public function INVISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVISIBLE, 0);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAlterColumnDefault($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAlterColumnDefault($this);
        }
    }
}

class AlterByDisableKeysContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DISABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISABLE, 0);
    }

    public function KEYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEYS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDisableKeys($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDisableKeys($this);
        }
    }
}

class AlterByDefaultCharsetContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDefaultCharset($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDefaultCharset($this);
        }
    }
}

class AlterByRenameColumnContext extends AlterSpecificationContext
{
    /**
     * @var UidContext|null $oldColumn
     */
    public $oldColumn;

    /**
     * @var UidContext|null $newColumn
     */
    public $newColumn;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function RENAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RENAME, 0);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByRenameColumn($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByRenameColumn($this);
        }
    }
}

class AlterByConvertCharsetContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CONVERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONVERT, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function CHARSET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARSET, 0);
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByConvertCharset($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByConvertCharset($this);
        }
    }
}

class AlterByAddForeignKeyContext extends AlterSpecificationContext
{
    /**
     * @var UidContext|null $name
     */
    public $name;

    /**
     * @var UidContext|null $indexName
     */
    public $indexName;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function FOREIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOREIGN, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function referenceDefinition(): ?ReferenceDefinitionContext
    {
        return $this->getTypedRuleContext(ReferenceDefinitionContext::class, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddForeignKey($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddForeignKey($this);
        }
    }
}

class AlterByRenameIndexContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function RENAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RENAME, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByRenameIndex($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByRenameIndex($this);
        }
    }
}

class AlterByRenameContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $renameFormat
     */
    public $renameFormat;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function RENAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RENAME, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByRename($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByRename($this);
        }
    }
}

class AlterByImportTablespaceContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function IMPORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IMPORT, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByImportTablespace($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByImportTablespace($this);
        }
    }
}

class AlterByAddDefinitionsContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<CreateDefinitionContext>|CreateDefinitionContext|null
     */
    public function createDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CreateDefinitionContext::class);
        }

        return $this->getTypedRuleContext(CreateDefinitionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddDefinitions($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddDefinitions($this);
        }
    }
}

class AlterByAlterCheckTableConstraintContext extends AlterSpecificationContext
{
    /**
     * @var UidContext|null $name
     */
    public $name;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function ENFORCED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENFORCED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAlterCheckTableConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAlterCheckTableConstraint($this);
        }
    }
}

class AlterByDropConstraintCheckContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDropConstraintCheck($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDropConstraintCheck($this);
        }
    }
}

class AlterByAddColumnsContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    /**
     * @return array<ColumnDefinitionContext>|ColumnDefinitionContext|null
     */
    public function columnDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ColumnDefinitionContext::class);
        }

        return $this->getTypedRuleContext(ColumnDefinitionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddColumns($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddColumns($this);
        }
    }
}

class AlterByAlterIndexVisibilityContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function VISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VISIBLE, 0);
    }

    public function INVISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVISIBLE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAlterIndexVisibility($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAlterIndexVisibility($this);
        }
    }
}

class AlterByDropForeignKeyContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function FOREIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOREIGN, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDropForeignKey($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDropForeignKey($this);
        }
    }
}

class AlterByAddCheckTableConstraintContext extends AlterSpecificationContext
{
    /**
     * @var UidContext|null $name
     */
    public $name;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function ENFORCED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENFORCED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddCheckTableConstraint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddCheckTableConstraint($this);
        }
    }
}

class AlterPartitionContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function alterPartitionSpecification(): ?AlterPartitionSpecificationContext
    {
        return $this->getTypedRuleContext(AlterPartitionSpecificationContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterPartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterPartition($this);
        }
    }
}

class AlterByAddIndexContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function indexType(): ?IndexTypeContext
    {
        return $this->getTypedRuleContext(IndexTypeContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddIndex($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddIndex($this);
        }
    }
}

class AlterByDropColumnContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    public function RESTRICT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESTRICT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDropColumn($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDropColumn($this);
        }
    }
}

class AlterByChangeDefaultContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function defaultValue(): ?DefaultValueContext
    {
        return $this->getTypedRuleContext(DefaultValueContext::class, 0);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByChangeDefault($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByChangeDefault($this);
        }
    }
}

class AlterByForceContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function FORCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FORCE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByForce($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByForce($this);
        }
    }
}

class AlterByAddSpecialIndexContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $keyType
     */
    public $keyType;

    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function FULLTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FULLTEXT, 0);
    }

    public function SPATIAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SPATIAL, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddSpecialIndex($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddSpecialIndex($this);
        }
    }
}

class AlterByModifyColumnContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function MODIFY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MODIFY, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function columnDefinition(): ?ColumnDefinitionContext
    {
        return $this->getTypedRuleContext(ColumnDefinitionContext::class, 0);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    public function FIRST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST, 0);
    }

    public function AFTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AFTER, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByModifyColumn($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByModifyColumn($this);
        }
    }
}

class AlterByTableOptionContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<TableOptionContext>|TableOptionContext|null
     */
    public function tableOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableOptionContext::class);
        }

        return $this->getTypedRuleContext(TableOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByTableOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByTableOption($this);
        }
    }
}

class AlterByDropPrimaryKeyContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function PRIMARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIMARY, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDropPrimaryKey($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDropPrimaryKey($this);
        }
    }
}

class AlterByLockContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $lockType
     */
    public $lockType;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCK, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function NONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NONE, 0);
    }

    public function SHARED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHARED, 0);
    }

    public function EXCLUSIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCLUSIVE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByLock($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByLock($this);
        }
    }
}

class AlterByDiscardTablespaceContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DISCARD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISCARD, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDiscardTablespace($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDiscardTablespace($this);
        }
    }
}

class AlterByValidateContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $validationFormat
     */
    public $validationFormat;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function VALIDATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALIDATION, 0);
    }

    public function WITHOUT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITHOUT, 0);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByValidate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByValidate($this);
        }
    }
}

class AlterByAddPrimaryKeyContext extends AlterSpecificationContext
{
    /**
     * @var UidContext|null $name
     */
    public $name;

    /**
     * @var UidContext|null $index
     */
    public $index;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function PRIMARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIMARY, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function indexType(): ?IndexTypeContext
    {
        return $this->getTypedRuleContext(IndexTypeContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddPrimaryKey($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddPrimaryKey($this);
        }
    }
}

class AlterByEnableKeysContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ENABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENABLE, 0);
    }

    public function KEYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEYS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByEnableKeys($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByEnableKeys($this);
        }
    }
}

class AlterBySetAlgorithmContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $algType
     */
    public $algType;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALGORITHM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALGORITHM, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function INSTANT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSTANT, 0);
    }

    public function INPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INPLACE, 0);
    }

    public function COPY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COPY, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterBySetAlgorithm($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterBySetAlgorithm($this);
        }
    }
}

class AlterByChangeColumnContext extends AlterSpecificationContext
{
    /**
     * @var UidContext|null $oldColumn
     */
    public $oldColumn;

    /**
     * @var UidContext|null $newColumn
     */
    public $newColumn;

    /**
     * @var UidContext|null $afterColumn
     */
    public $afterColumn;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CHANGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHANGE, 0);
    }

    public function columnDefinition(): ?ColumnDefinitionContext
    {
        return $this->getTypedRuleContext(ColumnDefinitionContext::class, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    public function FIRST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST, 0);
    }

    public function AFTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AFTER, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByChangeColumn($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByChangeColumn($this);
        }
    }
}

class AlterByAddUniqueKeyContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    /**
     * @var UidContext|null $name
     */
    public $name;

    /**
     * @var UidContext|null $indexName
     */
    public $indexName;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function UNIQUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNIQUE, 0);
    }

    public function indexColumnNames(): ?IndexColumnNamesContext
    {
        return $this->getTypedRuleContext(IndexColumnNamesContext::class, 0);
    }

    public function CONSTRAINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT, 0);
    }

    public function indexType(): ?IndexTypeContext
    {
        return $this->getTypedRuleContext(IndexTypeContext::class, 0);
    }

    /**
     * @return array<IndexOptionContext>|IndexOptionContext|null
     */
    public function indexOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexOptionContext::class);
        }

        return $this->getTypedRuleContext(IndexOptionContext::class, $index);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddUniqueKey($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddUniqueKey($this);
        }
    }
}

class AlterByDropIndexContext extends AlterSpecificationContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDropIndex($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDropIndex($this);
        }
    }
}

class AlterByAddColumnContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function columnDefinition(): ?ColumnDefinitionContext
    {
        return $this->getTypedRuleContext(ColumnDefinitionContext::class, 0);
    }

    public function COLUMN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN, 0);
    }

    public function FIRST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST, 0);
    }

    public function AFTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AFTER, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddColumn($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddColumn($this);
        }
    }
}

class AlterByOrderContext extends AlterSpecificationContext
{
    public function __construct(AlterSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ORDER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ORDER, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByOrder($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByOrder($this);
        }
    }
}

class AlterPartitionSpecificationContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterPartitionSpecification;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class AlterByImportPartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function IMPORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IMPORT, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByImportPartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByImportPartition($this);
        }
    }
}

class AlterByDropPartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDropPartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDropPartition($this);
        }
    }
}

class AlterByDiscardPartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DISCARD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISCARD, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByDiscardPartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByDiscardPartition($this);
        }
    }
}

class AlterByAddPartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADD, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<PartitionDefinitionContext>|PartitionDefinitionContext|null
     */
    public function partitionDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionDefinitionContext::class);
        }

        return $this->getTypedRuleContext(PartitionDefinitionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAddPartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAddPartition($this);
        }
    }
}

class AlterByRemovePartitioningContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REMOVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REMOVE, 0);
    }

    public function PARTITIONING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITIONING, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByRemovePartitioning($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByRemovePartitioning($this);
        }
    }
}

class AlterByOptimizePartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function OPTIMIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIMIZE, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByOptimizePartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByOptimizePartition($this);
        }
    }
}

class AlterByCheckPartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByCheckPartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByCheckPartition($this);
        }
    }
}

class AlterByCoalescePartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function COALESCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COALESCE, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByCoalescePartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByCoalescePartition($this);
        }
    }
}

class AlterByReorganizePartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REORGANIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REORGANIZE, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<PartitionDefinitionContext>|PartitionDefinitionContext|null
     */
    public function partitionDefinition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PartitionDefinitionContext::class);
        }

        return $this->getTypedRuleContext(PartitionDefinitionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByReorganizePartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByReorganizePartition($this);
        }
    }
}

class AlterByAnalyzePartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ANALYZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ANALYZE, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByAnalyzePartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByAnalyzePartition($this);
        }
    }
}

class AlterByRebuildPartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REBUILD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REBUILD, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByRebuildPartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByRebuildPartition($this);
        }
    }
}

class AlterByUpgradePartitioningContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function UPGRADE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPGRADE, 0);
    }

    public function PARTITIONING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITIONING, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByUpgradePartitioning($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByUpgradePartitioning($this);
        }
    }
}

class AlterByTruncatePartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function TRUNCATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRUNCATE, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByTruncatePartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByTruncatePartition($this);
        }
    }
}

class AlterByRepairPartitionContext extends AlterPartitionSpecificationContext
{
    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REPAIR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPAIR, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByRepairPartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByRepairPartition($this);
        }
    }
}

class AlterByExchangePartitionContext extends AlterPartitionSpecificationContext
{
    /**
     * @var Token|null $validationFormat
     */
    public $validationFormat;

    public function __construct(AlterPartitionSpecificationContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function EXCHANGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCHANGE, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function WITH(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::WITH);
        }

        return $this->getToken(MySqlParser::WITH, $index);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function VALIDATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALIDATION, 0);
    }

    public function WITHOUT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITHOUT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterByExchangePartition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterByExchangePartition($this);
        }
    }
}

class DropDatabaseContext extends ParserRuleContext
{
    /**
     * @var Token|null $dbFormat
     */
    public $dbFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropDatabase;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function DATABASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASE, 0);
    }

    public function SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA, 0);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropDatabase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropDatabase($this);
        }
    }
}

class DropEventContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropEvent;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function EVENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENT, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropEvent($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropEvent($this);
        }
    }
}

class DropIndexContext extends ParserRuleContext
{
    /**
     * @var Token|null $intimeAction
     */
    public $intimeAction;

    /**
     * @var Token|null $algType
     */
    public $algType;

    /**
     * @var Token|null $lockType
     */
    public $lockType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropIndex;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ALGORITHM(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ALGORITHM);
        }

        return $this->getToken(MySqlParser::ALGORITHM, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LOCK(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LOCK);
        }

        return $this->getToken(MySqlParser::LOCK, $index);
    }

    public function ONLINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONLINE, 0);
    }

    public function OFFLINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OFFLINE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function DEFAULT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::DEFAULT);
        }

        return $this->getToken(MySqlParser::DEFAULT, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function INPLACE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::INPLACE);
        }

        return $this->getToken(MySqlParser::INPLACE, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COPY(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COPY);
        }

        return $this->getToken(MySqlParser::COPY, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function NONE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::NONE);
        }

        return $this->getToken(MySqlParser::NONE, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function SHARED(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::SHARED);
        }

        return $this->getToken(MySqlParser::SHARED, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EXCLUSIVE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EXCLUSIVE);
        }

        return $this->getToken(MySqlParser::EXCLUSIVE, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropIndex($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropIndex($this);
        }
    }
}

class DropLogfileGroupContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropLogfileGroup;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function LOGFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGFILE, 0);
    }

    public function GROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropLogfileGroup($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropLogfileGroup($this);
        }
    }
}

class DropProcedureContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropProcedure;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function PROCEDURE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCEDURE, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropProcedure($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropProcedure($this);
        }
    }
}

class DropFunctionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropFunction;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropFunction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropFunction($this);
        }
    }
}

class DropServerContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropServer;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function SERVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERVER, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropServer($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropServer($this);
        }
    }
}

class DropTableContext extends ParserRuleContext
{
    /**
     * @var Token|null $dropType
     */
    public $dropType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropTable;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function TEMPORARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPORARY, 0);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    public function RESTRICT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESTRICT, 0);
    }

    public function CASCADE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CASCADE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropTable($this);
        }
    }
}

class DropTablespaceContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropTablespace;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropTablespace($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropTablespace($this);
        }
    }
}

class DropTriggerContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropTrigger;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function TRIGGER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRIGGER, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropTrigger($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropTrigger($this);
        }
    }
}

class DropViewContext extends ParserRuleContext
{
    /**
     * @var Token|null $dropType
     */
    public $dropType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropView;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function VIEW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VIEW, 0);
    }

    /**
     * @return array<FullIdContext>|FullIdContext|null
     */
    public function fullId(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FullIdContext::class);
        }

        return $this->getTypedRuleContext(FullIdContext::class, $index);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function RESTRICT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESTRICT, 0);
    }

    public function CASCADE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CASCADE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropView($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropView($this);
        }
    }
}

class DropRoleContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropRole;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function ROLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE, 0);
    }

    /**
     * @return array<RoleNameContext>|RoleNameContext|null
     */
    public function roleName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RoleNameContext::class);
        }

        return $this->getTypedRuleContext(RoleNameContext::class, $index);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropRole($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropRole($this);
        }
    }
}

class SetRoleContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_setRole;
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function ROLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    public function NONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NONE, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    /**
     * @return array<RoleNameContext>|RoleNameContext|null
     */
    public function roleName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RoleNameContext::class);
        }

        return $this->getTypedRuleContext(RoleNameContext::class, $index);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function roleOption(): ?RoleOptionContext
    {
        return $this->getTypedRuleContext(RoleOptionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetRole($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetRole($this);
        }
    }
}

class RenameTableContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_renameTable;
    }

    public function RENAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RENAME, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    /**
     * @return array<RenameTableClauseContext>|RenameTableClauseContext|null
     */
    public function renameTableClause(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RenameTableClauseContext::class);
        }

        return $this->getTypedRuleContext(RenameTableClauseContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRenameTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRenameTable($this);
        }
    }
}

class RenameTableClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_renameTableClause;
    }

    /**
     * @return array<TableNameContext>|TableNameContext|null
     */
    public function tableName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableNameContext::class);
        }

        return $this->getTypedRuleContext(TableNameContext::class, $index);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRenameTableClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRenameTableClause($this);
        }
    }
}

class TruncateTableContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_truncateTable;
    }

    public function TRUNCATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRUNCATE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTruncateTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTruncateTable($this);
        }
    }
}

class CallStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_callStatement;
    }

    public function CALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CALL, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function constants(): ?ConstantsContext
    {
        return $this->getTypedRuleContext(ConstantsContext::class, 0);
    }

    public function expressions(): ?ExpressionsContext
    {
        return $this->getTypedRuleContext(ExpressionsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCallStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCallStatement($this);
        }
    }
}

class DeleteStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_deleteStatement;
    }

    public function singleDeleteStatement(): ?SingleDeleteStatementContext
    {
        return $this->getTypedRuleContext(SingleDeleteStatementContext::class, 0);
    }

    public function multipleDeleteStatement(): ?MultipleDeleteStatementContext
    {
        return $this->getTypedRuleContext(MultipleDeleteStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDeleteStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDeleteStatement($this);
        }
    }
}

class DoStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_doStatement;
    }

    public function DO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DO, 0);
    }

    public function expressions(): ?ExpressionsContext
    {
        return $this->getTypedRuleContext(ExpressionsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDoStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDoStatement($this);
        }
    }
}

class HandlerStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_handlerStatement;
    }

    public function handlerOpenStatement(): ?HandlerOpenStatementContext
    {
        return $this->getTypedRuleContext(HandlerOpenStatementContext::class, 0);
    }

    public function handlerReadIndexStatement(): ?HandlerReadIndexStatementContext
    {
        return $this->getTypedRuleContext(HandlerReadIndexStatementContext::class, 0);
    }

    public function handlerReadStatement(): ?HandlerReadStatementContext
    {
        return $this->getTypedRuleContext(HandlerReadStatementContext::class, 0);
    }

    public function handlerCloseStatement(): ?HandlerCloseStatementContext
    {
        return $this->getTypedRuleContext(HandlerCloseStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerStatement($this);
        }
    }
}

class InsertStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $priority
     */
    public $priority;

    /**
     * @var UidListContext|null $partitions
     */
    public $partitions;

    /**
     * @var FullColumnNameListContext|null $columns
     */
    public $columns;

    /**
     * @var UpdatedElementContext|null $setFirst
     */
    public $setFirst;

    /**
     * @var UpdatedElementContext|null $updatedElement
     */
    public $updatedElement;

    /**
     * @var UpdatedElementContext|null $duplicatedFirst
     */
    public $duplicatedFirst;

    /**
     * @var array<UpdatedElementContext>|null $setElements
     */
    public $setElements;

    /**
     * @var array<UpdatedElementContext>|null $duplicatedElements
     */
    public $duplicatedElements;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_insertStatement;
    }

    public function INSERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSERT, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function insertStatementValue(): ?InsertStatementValueContext
    {
        return $this->getTypedRuleContext(InsertStatementValueContext::class, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    /**
     * @return array<UpdatedElementContext>|UpdatedElementContext|null
     */
    public function updatedElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UpdatedElementContext::class);
        }

        return $this->getTypedRuleContext(UpdatedElementContext::class, $index);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function DUPLICATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DUPLICATE, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    public function DELAYED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELAYED, 0);
    }

    public function HIGH_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HIGH_PRIORITY, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function fullColumnNameList(): ?FullColumnNameListContext
    {
        return $this->getTypedRuleContext(FullColumnNameListContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterInsertStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitInsertStatement($this);
        }
    }
}

class LoadDataStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $priority
     */
    public $priority;

    /**
     * @var Token|null $filename
     */
    public $filename;

    /**
     * @var Token|null $violation
     */
    public $violation;

    /**
     * @var Token|null $fieldsFormat
     */
    public $fieldsFormat;

    /**
     * @var Token|null $linesFormat
     */
    public $linesFormat;

    /**
     * @var CharsetNameContext|null $charset
     */
    public $charset;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_loadDataStatement;
    }

    public function LOAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOAD, 0);
    }

    public function DATA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATA, 0);
    }

    public function INFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INFILE, 0);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function SET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::SET);
        }

        return $this->getToken(MySqlParser::SET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LINES(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LINES);
        }

        return $this->getToken(MySqlParser::LINES, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function IGNORE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::IGNORE);
        }

        return $this->getToken(MySqlParser::IGNORE, $index);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    /**
     * @return array<AssignmentFieldContext>|AssignmentFieldContext|null
     */
    public function assignmentField(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(AssignmentFieldContext::class);
        }

        return $this->getTypedRuleContext(AssignmentFieldContext::class, $index);
    }

    /**
     * @return array<UpdatedElementContext>|UpdatedElementContext|null
     */
    public function updatedElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UpdatedElementContext::class);
        }

        return $this->getTypedRuleContext(UpdatedElementContext::class, $index);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    public function CONCURRENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONCURRENT, 0);
    }

    public function REPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLACE, 0);
    }

    public function FIELDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIELDS, 0);
    }

    public function COLUMNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMNS, 0);
    }

    public function ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROWS, 0);
    }

    /**
     * @return array<SelectFieldsIntoContext>|SelectFieldsIntoContext|null
     */
    public function selectFieldsInto(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SelectFieldsIntoContext::class);
        }

        return $this->getTypedRuleContext(SelectFieldsIntoContext::class, $index);
    }

    /**
     * @return array<SelectLinesIntoContext>|SelectLinesIntoContext|null
     */
    public function selectLinesInto(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SelectLinesIntoContext::class);
        }

        return $this->getTypedRuleContext(SelectLinesIntoContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLoadDataStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLoadDataStatement($this);
        }
    }
}

class LoadXmlStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $priority
     */
    public $priority;

    /**
     * @var Token|null $filename
     */
    public $filename;

    /**
     * @var Token|null $violation
     */
    public $violation;

    /**
     * @var Token|null $tag
     */
    public $tag;

    /**
     * @var Token|null $linesFormat
     */
    public $linesFormat;

    /**
     * @var CharsetNameContext|null $charset
     */
    public $charset;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_loadXmlStatement;
    }

    public function LOAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOAD, 0);
    }

    public function XML(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XML, 0);
    }

    public function INFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INFILE, 0);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STRING_LITERAL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STRING_LITERAL);
        }

        return $this->getToken(MySqlParser::STRING_LITERAL, $index);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function SET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::SET);
        }

        return $this->getToken(MySqlParser::SET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ROWS(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ROWS);
        }

        return $this->getToken(MySqlParser::ROWS, $index);
    }

    public function IDENTIFIED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IDENTIFIED, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function LESS_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LESS_SYMBOL, 0);
    }

    public function GREATER_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GREATER_SYMBOL, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function IGNORE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::IGNORE);
        }

        return $this->getToken(MySqlParser::IGNORE, $index);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<AssignmentFieldContext>|AssignmentFieldContext|null
     */
    public function assignmentField(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(AssignmentFieldContext::class);
        }

        return $this->getTypedRuleContext(AssignmentFieldContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<UpdatedElementContext>|UpdatedElementContext|null
     */
    public function updatedElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UpdatedElementContext::class);
        }

        return $this->getTypedRuleContext(UpdatedElementContext::class, $index);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    public function CONCURRENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONCURRENT, 0);
    }

    public function REPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLACE, 0);
    }

    public function LINES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINES, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLoadXmlStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLoadXmlStatement($this);
        }
    }
}

class ReplaceStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $priority
     */
    public $priority;

    /**
     * @var UidListContext|null $partitions
     */
    public $partitions;

    /**
     * @var UidListContext|null $columns
     */
    public $columns;

    /**
     * @var UpdatedElementContext|null $setFirst
     */
    public $setFirst;

    /**
     * @var UpdatedElementContext|null $updatedElement
     */
    public $updatedElement;

    /**
     * @var array<UpdatedElementContext>|null $setElements
     */
    public $setElements;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_replaceStatement;
    }

    public function REPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLACE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function insertStatementValue(): ?InsertStatementValueContext
    {
        return $this->getTypedRuleContext(InsertStatementValueContext::class, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    /**
     * @return array<UpdatedElementContext>|UpdatedElementContext|null
     */
    public function updatedElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UpdatedElementContext::class);
        }

        return $this->getTypedRuleContext(UpdatedElementContext::class, $index);
    }

    /**
     * @return array<UidListContext>|UidListContext|null
     */
    public function uidList(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidListContext::class);
        }

        return $this->getTypedRuleContext(UidListContext::class, $index);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    public function DELAYED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELAYED, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterReplaceStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitReplaceStatement($this);
        }
    }
}

class SelectStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_selectStatement;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class UnionSelectContext extends SelectStatementContext
{
    /**
     * @var Token|null $unionType
     */
    public $unionType;

    public function __construct(SelectStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function querySpecificationNointo(): ?QuerySpecificationNointoContext
    {
        return $this->getTypedRuleContext(QuerySpecificationNointoContext::class, 0);
    }

    public function queryExpressionNointo(): ?QueryExpressionNointoContext
    {
        return $this->getTypedRuleContext(QueryExpressionNointoContext::class, 0);
    }

    /**
     * @return array<UnionStatementContext>|UnionStatementContext|null
     */
    public function unionStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UnionStatementContext::class);
        }

        return $this->getTypedRuleContext(UnionStatementContext::class, $index);
    }

    public function UNION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNION, 0);
    }

    public function orderByClause(): ?OrderByClauseContext
    {
        return $this->getTypedRuleContext(OrderByClauseContext::class, 0);
    }

    public function limitClause(): ?LimitClauseContext
    {
        return $this->getTypedRuleContext(LimitClauseContext::class, 0);
    }

    public function lockClause(): ?LockClauseContext
    {
        return $this->getTypedRuleContext(LockClauseContext::class, 0);
    }

    public function querySpecification(): ?QuerySpecificationContext
    {
        return $this->getTypedRuleContext(QuerySpecificationContext::class, 0);
    }

    public function queryExpression(): ?QueryExpressionContext
    {
        return $this->getTypedRuleContext(QueryExpressionContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function DISTINCT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISTINCT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUnionSelect($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUnionSelect($this);
        }
    }
}

class UnionParenthesisSelectContext extends SelectStatementContext
{
    /**
     * @var Token|null $unionType
     */
    public $unionType;

    public function __construct(SelectStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function queryExpressionNointo(): ?QueryExpressionNointoContext
    {
        return $this->getTypedRuleContext(QueryExpressionNointoContext::class, 0);
    }

    /**
     * @return array<UnionParenthesisContext>|UnionParenthesisContext|null
     */
    public function unionParenthesis(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UnionParenthesisContext::class);
        }

        return $this->getTypedRuleContext(UnionParenthesisContext::class, $index);
    }

    public function UNION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNION, 0);
    }

    public function queryExpression(): ?QueryExpressionContext
    {
        return $this->getTypedRuleContext(QueryExpressionContext::class, 0);
    }

    public function orderByClause(): ?OrderByClauseContext
    {
        return $this->getTypedRuleContext(OrderByClauseContext::class, 0);
    }

    public function limitClause(): ?LimitClauseContext
    {
        return $this->getTypedRuleContext(LimitClauseContext::class, 0);
    }

    public function lockClause(): ?LockClauseContext
    {
        return $this->getTypedRuleContext(LockClauseContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function DISTINCT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISTINCT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUnionParenthesisSelect($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUnionParenthesisSelect($this);
        }
    }
}

class SimpleSelectContext extends SelectStatementContext
{
    public function __construct(SelectStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function querySpecification(): ?QuerySpecificationContext
    {
        return $this->getTypedRuleContext(QuerySpecificationContext::class, 0);
    }

    public function lockClause(): ?LockClauseContext
    {
        return $this->getTypedRuleContext(LockClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleSelect($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleSelect($this);
        }
    }
}

class ParenthesisSelectContext extends SelectStatementContext
{
    public function __construct(SelectStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function queryExpression(): ?QueryExpressionContext
    {
        return $this->getTypedRuleContext(QueryExpressionContext::class, 0);
    }

    public function lockClause(): ?LockClauseContext
    {
        return $this->getTypedRuleContext(LockClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterParenthesisSelect($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitParenthesisSelect($this);
        }
    }
}

class WithLateralStatementContext extends SelectStatementContext
{
    public function __construct(SelectStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function querySpecificationNointo(): ?QuerySpecificationNointoContext
    {
        return $this->getTypedRuleContext(QuerySpecificationNointoContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    /**
     * @return array<LateralStatementContext>|LateralStatementContext|null
     */
    public function lateralStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(LateralStatementContext::class);
        }

        return $this->getTypedRuleContext(LateralStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWithLateralStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWithLateralStatement($this);
        }
    }
}

class UpdateStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_updateStatement;
    }

    public function singleUpdateStatement(): ?SingleUpdateStatementContext
    {
        return $this->getTypedRuleContext(SingleUpdateStatementContext::class, 0);
    }

    public function multipleUpdateStatement(): ?MultipleUpdateStatementContext
    {
        return $this->getTypedRuleContext(MultipleUpdateStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUpdateStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUpdateStatement($this);
        }
    }
}

class ValuesStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_valuesStatement;
    }

    public function VALUES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUES, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    /**
     * @return array<ExpressionsWithDefaultsContext>|ExpressionsWithDefaultsContext|null
     */
    public function expressionsWithDefaults(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionsWithDefaultsContext::class);
        }

        return $this->getTypedRuleContext(ExpressionsWithDefaultsContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterValuesStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitValuesStatement($this);
        }
    }
}

class InsertStatementValueContext extends ParserRuleContext
{
    /**
     * @var Token|null $insertFormat
     */
    public $insertFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_insertStatementValue;
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    public function VALUES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUES, 0);
    }

    public function VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUE, 0);
    }

    /**
     * @return array<ExpressionsWithDefaultsContext>|ExpressionsWithDefaultsContext|null
     */
    public function expressionsWithDefaults(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionsWithDefaultsContext::class);
        }

        return $this->getTypedRuleContext(ExpressionsWithDefaultsContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterInsertStatementValue($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitInsertStatementValue($this);
        }
    }
}

class UpdatedElementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_updatedElement;
    }

    public function fullColumnName(): ?FullColumnNameContext
    {
        return $this->getTypedRuleContext(FullColumnNameContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUpdatedElement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUpdatedElement($this);
        }
    }
}

class AssignmentFieldContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_assignmentField;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function LOCAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL_ID, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAssignmentField($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAssignmentField($this);
        }
    }
}

class LockClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_lockClause;
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCK, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    public function SHARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHARE, 0);
    }

    public function MODE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MODE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLockClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLockClause($this);
        }
    }
}

class SingleDeleteStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $priority
     */
    public $priority;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_singleDeleteStatement;
    }

    public function DELETE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELETE, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function QUICK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUICK, 0);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function orderByClause(): ?OrderByClauseContext
    {
        return $this->getTypedRuleContext(OrderByClauseContext::class, 0);
    }

    public function LIMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIMIT, 0);
    }

    public function limitClauseAtom(): ?LimitClauseAtomContext
    {
        return $this->getTypedRuleContext(LimitClauseAtomContext::class, 0);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSingleDeleteStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSingleDeleteStatement($this);
        }
    }
}

class MultipleDeleteStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $priority
     */
    public $priority;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_multipleDeleteStatement;
    }

    public function DELETE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELETE, 0);
    }

    /**
     * @return array<TableNameContext>|TableNameContext|null
     */
    public function tableName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableNameContext::class);
        }

        return $this->getTypedRuleContext(TableNameContext::class, $index);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function tableSources(): ?TableSourcesContext
    {
        return $this->getTypedRuleContext(TableSourcesContext::class, 0);
    }

    public function USING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USING, 0);
    }

    public function QUICK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUICK, 0);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function DOT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::DOT);
        }

        return $this->getToken(MySqlParser::DOT, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STAR(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STAR);
        }

        return $this->getToken(MySqlParser::STAR, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMultipleDeleteStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMultipleDeleteStatement($this);
        }
    }
}

class HandlerOpenStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_handlerOpenStatement;
    }

    public function HANDLER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HANDLER, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function OPEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPEN, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerOpenStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerOpenStatement($this);
        }
    }
}

class HandlerReadIndexStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $moveOrder
     */
    public $moveOrder;

    /**
     * @var UidContext|null $index
     */
    public $index;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_handlerReadIndexStatement;
    }

    public function HANDLER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HANDLER, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function comparisonOperator(): ?ComparisonOperatorContext
    {
        return $this->getTypedRuleContext(ComparisonOperatorContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function constants(): ?ConstantsContext
    {
        return $this->getTypedRuleContext(ConstantsContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function LIMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIMIT, 0);
    }

    public function limitClauseAtom(): ?LimitClauseAtomContext
    {
        return $this->getTypedRuleContext(LimitClauseAtomContext::class, 0);
    }

    public function FIRST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST, 0);
    }

    public function NEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NEXT, 0);
    }

    public function PREV(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PREV, 0);
    }

    public function LAST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAST, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerReadIndexStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerReadIndexStatement($this);
        }
    }
}

class HandlerReadStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $moveOrder
     */
    public $moveOrder;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_handlerReadStatement;
    }

    public function HANDLER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HANDLER, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function FIRST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST, 0);
    }

    public function NEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NEXT, 0);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function LIMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIMIT, 0);
    }

    public function limitClauseAtom(): ?LimitClauseAtomContext
    {
        return $this->getTypedRuleContext(LimitClauseAtomContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerReadStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerReadStatement($this);
        }
    }
}

class HandlerCloseStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_handlerCloseStatement;
    }

    public function HANDLER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HANDLER, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function CLOSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLOSE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerCloseStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerCloseStatement($this);
        }
    }
}

class SingleUpdateStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $priority
     */
    public $priority;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_singleUpdateStatement;
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    /**
     * @return array<UpdatedElementContext>|UpdatedElementContext|null
     */
    public function updatedElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UpdatedElementContext::class);
        }

        return $this->getTypedRuleContext(UpdatedElementContext::class, $index);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function orderByClause(): ?OrderByClauseContext
    {
        return $this->getTypedRuleContext(OrderByClauseContext::class, 0);
    }

    public function limitClause(): ?LimitClauseContext
    {
        return $this->getTypedRuleContext(LimitClauseContext::class, 0);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSingleUpdateStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSingleUpdateStatement($this);
        }
    }
}

class MultipleUpdateStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $priority
     */
    public $priority;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_multipleUpdateStatement;
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function tableSources(): ?TableSourcesContext
    {
        return $this->getTypedRuleContext(TableSourcesContext::class, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    /**
     * @return array<UpdatedElementContext>|UpdatedElementContext|null
     */
    public function updatedElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UpdatedElementContext::class);
        }

        return $this->getTypedRuleContext(UpdatedElementContext::class, $index);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMultipleUpdateStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMultipleUpdateStatement($this);
        }
    }
}

class OrderByClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_orderByClause;
    }

    public function ORDER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ORDER, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    /**
     * @return array<OrderByExpressionContext>|OrderByExpressionContext|null
     */
    public function orderByExpression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(OrderByExpressionContext::class);
        }

        return $this->getTypedRuleContext(OrderByExpressionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterOrderByClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitOrderByClause($this);
        }
    }
}

class OrderByExpressionContext extends ParserRuleContext
{
    /**
     * @var Token|null $order
     */
    public $order;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_orderByExpression;
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function ASC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASC, 0);
    }

    public function DESC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DESC, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterOrderByExpression($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitOrderByExpression($this);
        }
    }
}

class TableSourcesContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableSources;
    }

    /**
     * @return array<TableSourceContext>|TableSourceContext|null
     */
    public function tableSource(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableSourceContext::class);
        }

        return $this->getTypedRuleContext(TableSourceContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableSources($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableSources($this);
        }
    }
}

class TableSourceContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableSource;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class TableJsonContext extends TableSourceContext
{
    public function __construct(TableSourceContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function jsonTable(): ?JsonTableContext
    {
        return $this->getTypedRuleContext(JsonTableContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableJson($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableJson($this);
        }
    }
}

class TableSourceNestedContext extends TableSourceContext
{
    public function __construct(TableSourceContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function tableSourceItem(): ?TableSourceItemContext
    {
        return $this->getTypedRuleContext(TableSourceItemContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<JoinPartContext>|JoinPartContext|null
     */
    public function joinPart(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(JoinPartContext::class);
        }

        return $this->getTypedRuleContext(JoinPartContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableSourceNested($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableSourceNested($this);
        }
    }
}

class TableSourceBaseContext extends TableSourceContext
{
    public function __construct(TableSourceContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function tableSourceItem(): ?TableSourceItemContext
    {
        return $this->getTypedRuleContext(TableSourceItemContext::class, 0);
    }

    /**
     * @return array<JoinPartContext>|JoinPartContext|null
     */
    public function joinPart(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(JoinPartContext::class);
        }

        return $this->getTypedRuleContext(JoinPartContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableSourceBase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableSourceBase($this);
        }
    }
}

class TableSourceItemContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableSourceItem;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SubqueryTableItemContext extends TableSourceItemContext
{
    /**
     * @var SelectStatementContext|null $parenthesisSubquery
     */
    public $parenthesisSubquery;

    /**
     * @var UidContext|null $alias
     */
    public $alias;

    public function __construct(TableSourceItemContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSubqueryTableItem($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSubqueryTableItem($this);
        }
    }
}

class AtomTableItemContext extends TableSourceItemContext
{
    /**
     * @var UidContext|null $alias
     */
    public $alias;

    public function __construct(TableSourceItemContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<IndexHintContext>|IndexHintContext|null
     */
    public function indexHint(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexHintContext::class);
        }

        return $this->getTypedRuleContext(IndexHintContext::class, $index);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAtomTableItem($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAtomTableItem($this);
        }
    }
}

class TableSourcesItemContext extends TableSourceItemContext
{
    public function __construct(TableSourceItemContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function tableSources(): ?TableSourcesContext
    {
        return $this->getTypedRuleContext(TableSourcesContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableSourcesItem($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableSourcesItem($this);
        }
    }
}

class IndexHintContext extends ParserRuleContext
{
    /**
     * @var Token|null $indexHintAction
     */
    public $indexHintAction;

    /**
     * @var Token|null $keyFormat
     */
    public $keyFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_indexHint;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function USE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USE, 0);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    public function FORCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FORCE, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function indexHintType(): ?IndexHintTypeContext
    {
        return $this->getTypedRuleContext(IndexHintTypeContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIndexHint($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIndexHint($this);
        }
    }
}

class IndexHintTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_indexHintType;
    }

    public function JOIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JOIN, 0);
    }

    public function ORDER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ORDER, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function GROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIndexHintType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIndexHintType($this);
        }
    }
}

class JoinPartContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_joinPart;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class InnerJoinContext extends JoinPartContext
{
    public function __construct(JoinPartContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function JOIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JOIN, 0);
    }

    public function tableSourceItem(): ?TableSourceItemContext
    {
        return $this->getTypedRuleContext(TableSourceItemContext::class, 0);
    }

    public function LATERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LATERAL, 0);
    }

    /**
     * @return array<JoinSpecContext>|JoinSpecContext|null
     */
    public function joinSpec(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(JoinSpecContext::class);
        }

        return $this->getTypedRuleContext(JoinSpecContext::class, $index);
    }

    public function INNER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INNER, 0);
    }

    public function CROSS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CROSS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterInnerJoin($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitInnerJoin($this);
        }
    }
}

class NaturalJoinContext extends JoinPartContext
{
    public function __construct(JoinPartContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function NATURAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NATURAL, 0);
    }

    public function JOIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JOIN, 0);
    }

    public function tableSourceItem(): ?TableSourceItemContext
    {
        return $this->getTypedRuleContext(TableSourceItemContext::class, 0);
    }

    public function LEFT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEFT, 0);
    }

    public function RIGHT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RIGHT, 0);
    }

    public function OUTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OUTER, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNaturalJoin($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNaturalJoin($this);
        }
    }
}

class OuterJoinContext extends JoinPartContext
{
    public function __construct(JoinPartContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function JOIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JOIN, 0);
    }

    public function tableSourceItem(): ?TableSourceItemContext
    {
        return $this->getTypedRuleContext(TableSourceItemContext::class, 0);
    }

    public function LEFT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEFT, 0);
    }

    public function RIGHT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RIGHT, 0);
    }

    public function OUTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OUTER, 0);
    }

    public function LATERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LATERAL, 0);
    }

    /**
     * @return array<JoinSpecContext>|JoinSpecContext|null
     */
    public function joinSpec(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(JoinSpecContext::class);
        }

        return $this->getTypedRuleContext(JoinSpecContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterOuterJoin($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitOuterJoin($this);
        }
    }
}

class StraightJoinContext extends JoinPartContext
{
    public function __construct(JoinPartContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function STRAIGHT_JOIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRAIGHT_JOIN, 0);
    }

    public function tableSourceItem(): ?TableSourceItemContext
    {
        return $this->getTypedRuleContext(TableSourceItemContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ON(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ON);
        }

        return $this->getToken(MySqlParser::ON, $index);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStraightJoin($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStraightJoin($this);
        }
    }
}

class JoinSpecContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_joinSpec;
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function USING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USING, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJoinSpec($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJoinSpec($this);
        }
    }
}

class QueryExpressionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_queryExpression;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function querySpecification(): ?QuerySpecificationContext
    {
        return $this->getTypedRuleContext(QuerySpecificationContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function queryExpression(): ?QueryExpressionContext
    {
        return $this->getTypedRuleContext(QueryExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterQueryExpression($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitQueryExpression($this);
        }
    }
}

class QueryExpressionNointoContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_queryExpressionNointo;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function querySpecificationNointo(): ?QuerySpecificationNointoContext
    {
        return $this->getTypedRuleContext(QuerySpecificationNointoContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function queryExpressionNointo(): ?QueryExpressionNointoContext
    {
        return $this->getTypedRuleContext(QueryExpressionNointoContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterQueryExpressionNointo($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitQueryExpressionNointo($this);
        }
    }
}

class QuerySpecificationContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_querySpecification;
    }

    public function SELECT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SELECT, 0);
    }

    public function selectElements(): ?SelectElementsContext
    {
        return $this->getTypedRuleContext(SelectElementsContext::class, 0);
    }

    public function fromClause(): ?FromClauseContext
    {
        return $this->getTypedRuleContext(FromClauseContext::class, 0);
    }

    /**
     * @return array<SelectSpecContext>|SelectSpecContext|null
     */
    public function selectSpec(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SelectSpecContext::class);
        }

        return $this->getTypedRuleContext(SelectSpecContext::class, $index);
    }

    public function selectIntoExpression(): ?SelectIntoExpressionContext
    {
        return $this->getTypedRuleContext(SelectIntoExpressionContext::class, 0);
    }

    public function groupByClause(): ?GroupByClauseContext
    {
        return $this->getTypedRuleContext(GroupByClauseContext::class, 0);
    }

    public function havingClause(): ?HavingClauseContext
    {
        return $this->getTypedRuleContext(HavingClauseContext::class, 0);
    }

    public function windowClause(): ?WindowClauseContext
    {
        return $this->getTypedRuleContext(WindowClauseContext::class, 0);
    }

    public function orderByClause(): ?OrderByClauseContext
    {
        return $this->getTypedRuleContext(OrderByClauseContext::class, 0);
    }

    public function limitClause(): ?LimitClauseContext
    {
        return $this->getTypedRuleContext(LimitClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterQuerySpecification($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitQuerySpecification($this);
        }
    }
}

class QuerySpecificationNointoContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_querySpecificationNointo;
    }

    public function SELECT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SELECT, 0);
    }

    public function selectElements(): ?SelectElementsContext
    {
        return $this->getTypedRuleContext(SelectElementsContext::class, 0);
    }

    public function fromClause(): ?FromClauseContext
    {
        return $this->getTypedRuleContext(FromClauseContext::class, 0);
    }

    /**
     * @return array<SelectSpecContext>|SelectSpecContext|null
     */
    public function selectSpec(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SelectSpecContext::class);
        }

        return $this->getTypedRuleContext(SelectSpecContext::class, $index);
    }

    public function groupByClause(): ?GroupByClauseContext
    {
        return $this->getTypedRuleContext(GroupByClauseContext::class, 0);
    }

    public function havingClause(): ?HavingClauseContext
    {
        return $this->getTypedRuleContext(HavingClauseContext::class, 0);
    }

    public function windowClause(): ?WindowClauseContext
    {
        return $this->getTypedRuleContext(WindowClauseContext::class, 0);
    }

    public function orderByClause(): ?OrderByClauseContext
    {
        return $this->getTypedRuleContext(OrderByClauseContext::class, 0);
    }

    public function limitClause(): ?LimitClauseContext
    {
        return $this->getTypedRuleContext(LimitClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterQuerySpecificationNointo($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitQuerySpecificationNointo($this);
        }
    }
}

class UnionParenthesisContext extends ParserRuleContext
{
    /**
     * @var Token|null $unionType
     */
    public $unionType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_unionParenthesis;
    }

    public function UNION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNION, 0);
    }

    public function queryExpressionNointo(): ?QueryExpressionNointoContext
    {
        return $this->getTypedRuleContext(QueryExpressionNointoContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function DISTINCT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISTINCT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUnionParenthesis($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUnionParenthesis($this);
        }
    }
}

class UnionStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $unionType
     */
    public $unionType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_unionStatement;
    }

    public function UNION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNION, 0);
    }

    public function querySpecificationNointo(): ?QuerySpecificationNointoContext
    {
        return $this->getTypedRuleContext(QuerySpecificationNointoContext::class, 0);
    }

    public function queryExpressionNointo(): ?QueryExpressionNointoContext
    {
        return $this->getTypedRuleContext(QueryExpressionNointoContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function DISTINCT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISTINCT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUnionStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUnionStatement($this);
        }
    }
}

class LateralStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_lateralStatement;
    }

    public function LATERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LATERAL, 0);
    }

    public function querySpecificationNointo(): ?QuerySpecificationNointoContext
    {
        return $this->getTypedRuleContext(QuerySpecificationNointoContext::class, 0);
    }

    public function queryExpressionNointo(): ?QueryExpressionNointoContext
    {
        return $this->getTypedRuleContext(QueryExpressionNointoContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLateralStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLateralStatement($this);
        }
    }
}

class JsonTableContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_jsonTable;
    }

    public function JSON_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_TABLE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STRING_LITERAL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STRING_LITERAL);
        }

        return $this->getToken(MySqlParser::STRING_LITERAL, $index);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function COLUMNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMNS, 0);
    }

    public function jsonColumnList(): ?JsonColumnListContext
    {
        return $this->getTypedRuleContext(JsonColumnListContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonTable($this);
        }
    }
}

class JsonColumnListContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_jsonColumnList;
    }

    /**
     * @return array<JsonColumnContext>|JsonColumnContext|null
     */
    public function jsonColumn(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(JsonColumnContext::class);
        }

        return $this->getTypedRuleContext(JsonColumnContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonColumnList($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonColumnList($this);
        }
    }
}

class JsonColumnContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_jsonColumn;
    }

    public function fullColumnName(): ?FullColumnNameContext
    {
        return $this->getTypedRuleContext(FullColumnNameContext::class, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function ORDINALITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ORDINALITY, 0);
    }

    public function dataType(): ?DataTypeContext
    {
        return $this->getTypedRuleContext(DataTypeContext::class, 0);
    }

    public function PATH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PATH, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function EXISTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXISTS, 0);
    }

    public function jsonOnEmpty(): ?JsonOnEmptyContext
    {
        return $this->getTypedRuleContext(JsonOnEmptyContext::class, 0);
    }

    public function jsonOnError(): ?JsonOnErrorContext
    {
        return $this->getTypedRuleContext(JsonOnErrorContext::class, 0);
    }

    public function NESTED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NESTED, 0);
    }

    public function COLUMNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMNS, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function jsonColumnList(): ?JsonColumnListContext
    {
        return $this->getTypedRuleContext(JsonColumnListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonColumn($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonColumn($this);
        }
    }
}

class JsonOnEmptyContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_jsonOnEmpty;
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function EMPTY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EMPTY, 0);
    }

    public function NULL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULL_LITERAL, 0);
    }

    public function ERROR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ERROR, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function defaultValue(): ?DefaultValueContext
    {
        return $this->getTypedRuleContext(DefaultValueContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonOnEmpty($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonOnEmpty($this);
        }
    }
}

class JsonOnErrorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_jsonOnError;
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ERROR(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ERROR);
        }

        return $this->getToken(MySqlParser::ERROR, $index);
    }

    public function NULL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULL_LITERAL, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function defaultValue(): ?DefaultValueContext
    {
        return $this->getTypedRuleContext(DefaultValueContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonOnError($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonOnError($this);
        }
    }
}

class SelectSpecContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_selectSpec;
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function DISTINCT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISTINCT, 0);
    }

    public function DISTINCTROW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISTINCTROW, 0);
    }

    public function HIGH_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HIGH_PRIORITY, 0);
    }

    public function STRAIGHT_JOIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRAIGHT_JOIN, 0);
    }

    public function SQL_SMALL_RESULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_SMALL_RESULT, 0);
    }

    public function SQL_BIG_RESULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_BIG_RESULT, 0);
    }

    public function SQL_BUFFER_RESULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_BUFFER_RESULT, 0);
    }

    public function SQL_CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_CACHE, 0);
    }

    public function SQL_NO_CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_NO_CACHE, 0);
    }

    public function SQL_CALC_FOUND_ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_CALC_FOUND_ROWS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectSpec($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectSpec($this);
        }
    }
}

class SelectElementsContext extends ParserRuleContext
{
    /**
     * @var Token|null $star
     */
    public $star;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_selectElements;
    }

    /**
     * @return array<SelectElementContext>|SelectElementContext|null
     */
    public function selectElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SelectElementContext::class);
        }

        return $this->getTypedRuleContext(SelectElementContext::class, $index);
    }

    public function STAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STAR, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectElements($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectElements($this);
        }
    }
}

class SelectElementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_selectElement;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SelectExpressionElementContext extends SelectElementContext
{
    public function __construct(SelectElementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function LOCAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL_ID, 0);
    }

    public function VAR_ASSIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VAR_ASSIGN, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectExpressionElement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectExpressionElement($this);
        }
    }
}

class SelectFunctionElementContext extends SelectElementContext
{
    public function __construct(SelectElementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function functionCall(): ?FunctionCallContext
    {
        return $this->getTypedRuleContext(FunctionCallContext::class, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectFunctionElement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectFunctionElement($this);
        }
    }
}

class SelectStarElementContext extends SelectElementContext
{
    public function __construct(SelectElementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function DOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOT, 0);
    }

    public function STAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STAR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectStarElement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectStarElement($this);
        }
    }
}

class SelectColumnElementContext extends SelectElementContext
{
    public function __construct(SelectElementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function fullColumnName(): ?FullColumnNameContext
    {
        return $this->getTypedRuleContext(FullColumnNameContext::class, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectColumnElement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectColumnElement($this);
        }
    }
}

class SelectIntoExpressionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_selectIntoExpression;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SelectIntoVariablesContext extends SelectIntoExpressionContext
{
    public function __construct(SelectIntoExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    /**
     * @return array<AssignmentFieldContext>|AssignmentFieldContext|null
     */
    public function assignmentField(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(AssignmentFieldContext::class);
        }

        return $this->getTypedRuleContext(AssignmentFieldContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectIntoVariables($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectIntoVariables($this);
        }
    }
}

class SelectIntoTextFileContext extends SelectIntoExpressionContext
{
    /**
     * @var Token|null $filename
     */
    public $filename;

    /**
     * @var Token|null $fieldsFormat
     */
    public $fieldsFormat;

    /**
     * @var CharsetNameContext|null $charset
     */
    public $charset;

    public function __construct(SelectIntoExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function OUTFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OUTFILE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function LINES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINES, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function FIELDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIELDS, 0);
    }

    public function COLUMNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMNS, 0);
    }

    /**
     * @return array<SelectFieldsIntoContext>|SelectFieldsIntoContext|null
     */
    public function selectFieldsInto(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SelectFieldsIntoContext::class);
        }

        return $this->getTypedRuleContext(SelectFieldsIntoContext::class, $index);
    }

    /**
     * @return array<SelectLinesIntoContext>|SelectLinesIntoContext|null
     */
    public function selectLinesInto(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SelectLinesIntoContext::class);
        }

        return $this->getTypedRuleContext(SelectLinesIntoContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectIntoTextFile($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectIntoTextFile($this);
        }
    }
}

class SelectIntoDumpFileContext extends SelectIntoExpressionContext
{
    public function __construct(SelectIntoExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function DUMPFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DUMPFILE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectIntoDumpFile($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectIntoDumpFile($this);
        }
    }
}

class SelectFieldsIntoContext extends ParserRuleContext
{
    /**
     * @var Token|null $terminationField
     */
    public $terminationField;

    /**
     * @var Token|null $enclosion
     */
    public $enclosion;

    /**
     * @var Token|null $escaping
     */
    public $escaping;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_selectFieldsInto;
    }

    public function TERMINATED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TERMINATED, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ENCLOSED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCLOSED, 0);
    }

    public function OPTIONALLY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIONALLY, 0);
    }

    public function ESCAPED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ESCAPED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectFieldsInto($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectFieldsInto($this);
        }
    }
}

class SelectLinesIntoContext extends ParserRuleContext
{
    /**
     * @var Token|null $starting
     */
    public $starting;

    /**
     * @var Token|null $terminationLine
     */
    public $terminationLine;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_selectLinesInto;
    }

    public function STARTING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STARTING, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function TERMINATED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TERMINATED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSelectLinesInto($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSelectLinesInto($this);
        }
    }
}

class FromClauseContext extends ParserRuleContext
{
    /**
     * @var ExpressionContext|null $whereExpr
     */
    public $whereExpr;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_fromClause;
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function tableSources(): ?TableSourcesContext
    {
        return $this->getTypedRuleContext(TableSourcesContext::class, 0);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFromClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFromClause($this);
        }
    }
}

class GroupByClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_groupByClause;
    }

    public function GROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    /**
     * @return array<GroupByItemContext>|GroupByItemContext|null
     */
    public function groupByItem(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(GroupByItemContext::class);
        }

        return $this->getTypedRuleContext(GroupByItemContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function ROLLUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLLUP, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGroupByClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGroupByClause($this);
        }
    }
}

class HavingClauseContext extends ParserRuleContext
{
    /**
     * @var ExpressionContext|null $havingExpr
     */
    public $havingExpr;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_havingClause;
    }

    public function HAVING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HAVING, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHavingClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHavingClause($this);
        }
    }
}

class WindowClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_windowClause;
    }

    public function WINDOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WINDOW, 0);
    }

    /**
     * @return array<WindowNameContext>|WindowNameContext|null
     */
    public function windowName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(WindowNameContext::class);
        }

        return $this->getTypedRuleContext(WindowNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function AS(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::AS);
        }

        return $this->getToken(MySqlParser::AS, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<WindowSpecContext>|WindowSpecContext|null
     */
    public function windowSpec(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(WindowSpecContext::class);
        }

        return $this->getTypedRuleContext(WindowSpecContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWindowClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWindowClause($this);
        }
    }
}

class GroupByItemContext extends ParserRuleContext
{
    /**
     * @var Token|null $order
     */
    public $order;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_groupByItem;
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function ASC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASC, 0);
    }

    public function DESC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DESC, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGroupByItem($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGroupByItem($this);
        }
    }
}

class LimitClauseContext extends ParserRuleContext
{
    /**
     * @var LimitClauseAtomContext|null $offset
     */
    public $offset;

    /**
     * @var LimitClauseAtomContext|null $limit
     */
    public $limit;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_limitClause;
    }

    public function LIMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIMIT, 0);
    }

    public function OFFSET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OFFSET, 0);
    }

    /**
     * @return array<LimitClauseAtomContext>|LimitClauseAtomContext|null
     */
    public function limitClauseAtom(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(LimitClauseAtomContext::class);
        }

        return $this->getTypedRuleContext(LimitClauseAtomContext::class, $index);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLimitClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLimitClause($this);
        }
    }
}

class LimitClauseAtomContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_limitClauseAtom;
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function mysqlVariable(): ?MysqlVariableContext
    {
        return $this->getTypedRuleContext(MysqlVariableContext::class, 0);
    }

    public function simpleId(): ?SimpleIdContext
    {
        return $this->getTypedRuleContext(SimpleIdContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLimitClauseAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLimitClauseAtom($this);
        }
    }
}

class StartTransactionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_startTransaction;
    }

    public function START(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::START, 0);
    }

    public function TRANSACTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRANSACTION, 0);
    }

    /**
     * @return array<TransactionModeContext>|TransactionModeContext|null
     */
    public function transactionMode(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TransactionModeContext::class);
        }

        return $this->getTypedRuleContext(TransactionModeContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStartTransaction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStartTransaction($this);
        }
    }
}

class BeginWorkContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_beginWork;
    }

    public function BEGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BEGIN, 0);
    }

    public function WORK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WORK, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBeginWork($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBeginWork($this);
        }
    }
}

class CommitWorkContext extends ParserRuleContext
{
    /**
     * @var Token|null $nochain
     */
    public $nochain;

    /**
     * @var Token|null $norelease
     */
    public $norelease;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_commitWork;
    }

    public function COMMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMIT, 0);
    }

    public function WORK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WORK, 0);
    }

    public function AND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AND, 0);
    }

    public function CHAIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAIN, 0);
    }

    public function RELEASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELEASE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function NO(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::NO);
        }

        return $this->getToken(MySqlParser::NO, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCommitWork($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCommitWork($this);
        }
    }
}

class RollbackWorkContext extends ParserRuleContext
{
    /**
     * @var Token|null $nochain
     */
    public $nochain;

    /**
     * @var Token|null $norelease
     */
    public $norelease;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_rollbackWork;
    }

    public function ROLLBACK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLLBACK, 0);
    }

    public function WORK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WORK, 0);
    }

    public function AND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AND, 0);
    }

    public function CHAIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAIN, 0);
    }

    public function RELEASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELEASE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function NO(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::NO);
        }

        return $this->getToken(MySqlParser::NO, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRollbackWork($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRollbackWork($this);
        }
    }
}

class SavepointStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_savepointStatement;
    }

    public function SAVEPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SAVEPOINT, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSavepointStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSavepointStatement($this);
        }
    }
}

class RollbackStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_rollbackStatement;
    }

    public function ROLLBACK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLLBACK, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function WORK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WORK, 0);
    }

    public function SAVEPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SAVEPOINT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRollbackStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRollbackStatement($this);
        }
    }
}

class ReleaseStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_releaseStatement;
    }

    public function RELEASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELEASE, 0);
    }

    public function SAVEPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SAVEPOINT, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterReleaseStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitReleaseStatement($this);
        }
    }
}

class LockTablesContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_lockTables;
    }

    public function LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCK, 0);
    }

    /**
     * @return array<LockTableElementContext>|LockTableElementContext|null
     */
    public function lockTableElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(LockTableElementContext::class);
        }

        return $this->getTypedRuleContext(LockTableElementContext::class, $index);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function waitNowaitClause(): ?WaitNowaitClauseContext
    {
        return $this->getTypedRuleContext(WaitNowaitClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLockTables($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLockTables($this);
        }
    }
}

class UnlockTablesContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_unlockTables;
    }

    public function UNLOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNLOCK, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUnlockTables($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUnlockTables($this);
        }
    }
}

class SetAutocommitStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $autocommitValue
     */
    public $autocommitValue;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_setAutocommitStatement;
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function AUTOCOMMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTOCOMMIT, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetAutocommitStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetAutocommitStatement($this);
        }
    }
}

class SetTransactionStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $transactionContext
     */
    public $transactionContext;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_setTransactionStatement;
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function TRANSACTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRANSACTION, 0);
    }

    /**
     * @return array<TransactionOptionContext>|TransactionOptionContext|null
     */
    public function transactionOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TransactionOptionContext::class);
        }

        return $this->getTypedRuleContext(TransactionOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function GLOBAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GLOBAL, 0);
    }

    public function SESSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SESSION, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetTransactionStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetTransactionStatement($this);
        }
    }
}

class TransactionModeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_transactionMode;
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function CONSISTENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSISTENT, 0);
    }

    public function SNAPSHOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SNAPSHOT, 0);
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function WRITE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WRITE, 0);
    }

    public function ONLY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONLY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTransactionMode($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTransactionMode($this);
        }
    }
}

class LockTableElementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_lockTableElement;
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function lockAction(): ?LockActionContext
    {
        return $this->getTypedRuleContext(LockActionContext::class, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLockTableElement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLockTableElement($this);
        }
    }
}

class LockActionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_lockAction;
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function WRITE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WRITE, 0);
    }

    public function LOW_PRIORITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOW_PRIORITY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLockAction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLockAction($this);
        }
    }
}

class TransactionOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_transactionOption;
    }

    public function ISOLATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISOLATION, 0);
    }

    public function LEVEL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEVEL, 0);
    }

    public function transactionLevel(): ?TransactionLevelContext
    {
        return $this->getTypedRuleContext(TransactionLevelContext::class, 0);
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function WRITE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WRITE, 0);
    }

    public function ONLY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONLY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTransactionOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTransactionOption($this);
        }
    }
}

class TransactionLevelContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_transactionLevel;
    }

    public function REPEATABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPEATABLE, 0);
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function COMMITTED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMITTED, 0);
    }

    public function UNCOMMITTED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNCOMMITTED, 0);
    }

    public function SERIALIZABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERIALIZABLE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTransactionLevel($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTransactionLevel($this);
        }
    }
}

class ChangeMasterContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_changeMaster;
    }

    public function CHANGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHANGE, 0);
    }

    public function MASTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    /**
     * @return array<MasterOptionContext>|MasterOptionContext|null
     */
    public function masterOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(MasterOptionContext::class);
        }

        return $this->getTypedRuleContext(MasterOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function channelOption(): ?ChannelOptionContext
    {
        return $this->getTypedRuleContext(ChannelOptionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterChangeMaster($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitChangeMaster($this);
        }
    }
}

class ChangeReplicationFilterContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_changeReplicationFilter;
    }

    public function CHANGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHANGE, 0);
    }

    public function REPLICATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATION, 0);
    }

    public function FILTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FILTER, 0);
    }

    /**
     * @return array<ReplicationFilterContext>|ReplicationFilterContext|null
     */
    public function replicationFilter(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ReplicationFilterContext::class);
        }

        return $this->getTypedRuleContext(ReplicationFilterContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterChangeReplicationFilter($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitChangeReplicationFilter($this);
        }
    }
}

class PurgeBinaryLogsContext extends ParserRuleContext
{
    /**
     * @var Token|null $purgeFormat
     */
    public $purgeFormat;

    /**
     * @var Token|null $fileName
     */
    public $fileName;

    /**
     * @var Token|null $timeValue
     */
    public $timeValue;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_purgeBinaryLogs;
    }

    public function PURGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PURGE, 0);
    }

    public function LOGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGS, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function MASTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    public function BEFORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BEFORE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPurgeBinaryLogs($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPurgeBinaryLogs($this);
        }
    }
}

class ResetMasterContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_resetMaster;
    }

    public function RESET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESET, 0);
    }

    public function MASTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterResetMaster($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitResetMaster($this);
        }
    }
}

class ResetSlaveContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_resetSlave;
    }

    public function RESET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESET, 0);
    }

    public function SLAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLAVE, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function channelOption(): ?ChannelOptionContext
    {
        return $this->getTypedRuleContext(ChannelOptionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterResetSlave($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitResetSlave($this);
        }
    }
}

class StartSlaveContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_startSlave;
    }

    public function START(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::START, 0);
    }

    public function SLAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLAVE, 0);
    }

    /**
     * @return array<ThreadTypeContext>|ThreadTypeContext|null
     */
    public function threadType(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ThreadTypeContext::class);
        }

        return $this->getTypedRuleContext(ThreadTypeContext::class, $index);
    }

    public function UNTIL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNTIL, 0);
    }

    public function untilOption(): ?UntilOptionContext
    {
        return $this->getTypedRuleContext(UntilOptionContext::class, 0);
    }

    /**
     * @return array<ConnectionOptionContext>|ConnectionOptionContext|null
     */
    public function connectionOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ConnectionOptionContext::class);
        }

        return $this->getTypedRuleContext(ConnectionOptionContext::class, $index);
    }

    public function channelOption(): ?ChannelOptionContext
    {
        return $this->getTypedRuleContext(ChannelOptionContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStartSlave($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStartSlave($this);
        }
    }
}

class StopSlaveContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_stopSlave;
    }

    public function STOP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STOP, 0);
    }

    public function SLAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLAVE, 0);
    }

    /**
     * @return array<ThreadTypeContext>|ThreadTypeContext|null
     */
    public function threadType(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ThreadTypeContext::class);
        }

        return $this->getTypedRuleContext(ThreadTypeContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStopSlave($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStopSlave($this);
        }
    }
}

class StartGroupReplicationContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_startGroupReplication;
    }

    public function START(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::START, 0);
    }

    public function GROUP_REPLICATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP_REPLICATION, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStartGroupReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStartGroupReplication($this);
        }
    }
}

class StopGroupReplicationContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_stopGroupReplication;
    }

    public function STOP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STOP, 0);
    }

    public function GROUP_REPLICATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP_REPLICATION, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStopGroupReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStopGroupReplication($this);
        }
    }
}

class MasterOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_masterOption;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class MasterStringOptionContext extends MasterOptionContext
{
    public function __construct(MasterOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function stringMasterOption(): ?StringMasterOptionContext
    {
        return $this->getTypedRuleContext(StringMasterOptionContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMasterStringOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMasterStringOption($this);
        }
    }
}

class MasterRealOptionContext extends MasterOptionContext
{
    public function __construct(MasterOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function MASTER_HEARTBEAT_PERIOD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_HEARTBEAT_PERIOD, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function REAL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REAL_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMasterRealOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMasterRealOption($this);
        }
    }
}

class MasterBoolOptionContext extends MasterOptionContext
{
    /**
     * @var Token|null $boolVal
     */
    public $boolVal;

    public function __construct(MasterOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function boolMasterOption(): ?BoolMasterOptionContext
    {
        return $this->getTypedRuleContext(BoolMasterOptionContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMasterBoolOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMasterBoolOption($this);
        }
    }
}

class MasterUidListOptionContext extends MasterOptionContext
{
    public function __construct(MasterOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function IGNORE_SERVER_IDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE_SERVER_IDS, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMasterUidListOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMasterUidListOption($this);
        }
    }
}

class MasterDecimalOptionContext extends MasterOptionContext
{
    public function __construct(MasterOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function decimalMasterOption(): ?DecimalMasterOptionContext
    {
        return $this->getTypedRuleContext(DecimalMasterOptionContext::class, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMasterDecimalOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMasterDecimalOption($this);
        }
    }
}

class StringMasterOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_stringMasterOption;
    }

    public function MASTER_BIND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_BIND, 0);
    }

    public function MASTER_HOST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_HOST, 0);
    }

    public function MASTER_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_USER, 0);
    }

    public function MASTER_PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_PASSWORD, 0);
    }

    public function MASTER_LOG_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_LOG_FILE, 0);
    }

    public function RELAY_LOG_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY_LOG_FILE, 0);
    }

    public function MASTER_SSL_CA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CA, 0);
    }

    public function MASTER_SSL_CAPATH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CAPATH, 0);
    }

    public function MASTER_SSL_CERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CERT, 0);
    }

    public function MASTER_SSL_CRL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CRL, 0);
    }

    public function MASTER_SSL_CRLPATH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CRLPATH, 0);
    }

    public function MASTER_SSL_KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_KEY, 0);
    }

    public function MASTER_SSL_CIPHER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CIPHER, 0);
    }

    public function MASTER_TLS_VERSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_TLS_VERSION, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStringMasterOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStringMasterOption($this);
        }
    }
}

class DecimalMasterOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_decimalMasterOption;
    }

    public function MASTER_PORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_PORT, 0);
    }

    public function MASTER_CONNECT_RETRY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_CONNECT_RETRY, 0);
    }

    public function MASTER_RETRY_COUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_RETRY_COUNT, 0);
    }

    public function MASTER_DELAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_DELAY, 0);
    }

    public function MASTER_LOG_POS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_LOG_POS, 0);
    }

    public function RELAY_LOG_POS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY_LOG_POS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDecimalMasterOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDecimalMasterOption($this);
        }
    }
}

class BoolMasterOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_boolMasterOption;
    }

    public function MASTER_AUTO_POSITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_AUTO_POSITION, 0);
    }

    public function MASTER_SSL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL, 0);
    }

    public function MASTER_SSL_VERIFY_SERVER_CERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_VERIFY_SERVER_CERT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBoolMasterOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBoolMasterOption($this);
        }
    }
}

class ChannelOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_channelOption;
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function CHANNEL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHANNEL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterChannelOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitChannelOption($this);
        }
    }
}

class ReplicationFilterContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_replicationFilter;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class WildIgnoreTableReplicationContext extends ReplicationFilterContext
{
    public function __construct(ReplicationFilterContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REPLICATE_WILD_IGNORE_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_WILD_IGNORE_TABLE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function simpleStrings(): ?SimpleStringsContext
    {
        return $this->getTypedRuleContext(SimpleStringsContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWildIgnoreTableReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWildIgnoreTableReplication($this);
        }
    }
}

class DoTableReplicationContext extends ReplicationFilterContext
{
    public function __construct(ReplicationFilterContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REPLICATE_DO_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_DO_TABLE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDoTableReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDoTableReplication($this);
        }
    }
}

class IgnoreTableReplicationContext extends ReplicationFilterContext
{
    public function __construct(ReplicationFilterContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REPLICATE_IGNORE_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_IGNORE_TABLE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIgnoreTableReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIgnoreTableReplication($this);
        }
    }
}

class RewriteDbReplicationContext extends ReplicationFilterContext
{
    public function __construct(ReplicationFilterContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REPLICATE_REWRITE_DB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_REWRITE_DB, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<TablePairContext>|TablePairContext|null
     */
    public function tablePair(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TablePairContext::class);
        }

        return $this->getTypedRuleContext(TablePairContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRewriteDbReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRewriteDbReplication($this);
        }
    }
}

class DoDbReplicationContext extends ReplicationFilterContext
{
    public function __construct(ReplicationFilterContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REPLICATE_DO_DB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_DO_DB, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDoDbReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDoDbReplication($this);
        }
    }
}

class IgnoreDbReplicationContext extends ReplicationFilterContext
{
    public function __construct(ReplicationFilterContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REPLICATE_IGNORE_DB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_IGNORE_DB, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIgnoreDbReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIgnoreDbReplication($this);
        }
    }
}

class WildDoTableReplicationContext extends ReplicationFilterContext
{
    public function __construct(ReplicationFilterContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REPLICATE_WILD_DO_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_WILD_DO_TABLE, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function simpleStrings(): ?SimpleStringsContext
    {
        return $this->getTypedRuleContext(SimpleStringsContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWildDoTableReplication($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWildDoTableReplication($this);
        }
    }
}

class TablePairContext extends ParserRuleContext
{
    /**
     * @var TableNameContext|null $firstTable
     */
    public $firstTable;

    /**
     * @var TableNameContext|null $secondTable
     */
    public $secondTable;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tablePair;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TableNameContext>|TableNameContext|null
     */
    public function tableName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableNameContext::class);
        }

        return $this->getTypedRuleContext(TableNameContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTablePair($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTablePair($this);
        }
    }
}

class ThreadTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_threadType;
    }

    public function IO_THREAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IO_THREAD, 0);
    }

    public function SQL_THREAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_THREAD, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterThreadType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitThreadType($this);
        }
    }
}

class UntilOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_untilOption;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class GtidsUntilOptionContext extends UntilOptionContext
{
    /**
     * @var Token|null $gtids
     */
    public $gtids;

    public function __construct(UntilOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function gtuidSet(): ?GtuidSetContext
    {
        return $this->getTypedRuleContext(GtuidSetContext::class, 0);
    }

    public function SQL_BEFORE_GTIDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_BEFORE_GTIDS, 0);
    }

    public function SQL_AFTER_GTIDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_AFTER_GTIDS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGtidsUntilOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGtidsUntilOption($this);
        }
    }
}

class SqlGapsUntilOptionContext extends UntilOptionContext
{
    public function __construct(UntilOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SQL_AFTER_MTS_GAPS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_AFTER_MTS_GAPS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSqlGapsUntilOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSqlGapsUntilOption($this);
        }
    }
}

class MasterLogUntilOptionContext extends UntilOptionContext
{
    public function __construct(UntilOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function MASTER_LOG_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_LOG_FILE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function MASTER_LOG_POS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_LOG_POS, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMasterLogUntilOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMasterLogUntilOption($this);
        }
    }
}

class RelayLogUntilOptionContext extends UntilOptionContext
{
    public function __construct(UntilOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function RELAY_LOG_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY_LOG_FILE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function RELAY_LOG_POS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY_LOG_POS, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRelayLogUntilOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRelayLogUntilOption($this);
        }
    }
}

class ConnectionOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_connectionOption;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class PluginDirConnectionOptionContext extends ConnectionOptionContext
{
    /**
     * @var Token|null $conOptPluginDir
     */
    public $conOptPluginDir;

    public function __construct(ConnectionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PLUGIN_DIR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUGIN_DIR, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPluginDirConnectionOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPluginDirConnectionOption($this);
        }
    }
}

class UserConnectionOptionContext extends ConnectionOptionContext
{
    /**
     * @var Token|null $conOptUser
     */
    public $conOptUser;

    public function __construct(ConnectionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUserConnectionOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUserConnectionOption($this);
        }
    }
}

class DefaultAuthConnectionOptionContext extends ConnectionOptionContext
{
    /**
     * @var Token|null $conOptDefAuth
     */
    public $conOptDefAuth;

    public function __construct(ConnectionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DEFAULT_AUTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT_AUTH, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDefaultAuthConnectionOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDefaultAuthConnectionOption($this);
        }
    }
}

class PasswordConnectionOptionContext extends ConnectionOptionContext
{
    /**
     * @var Token|null $conOptPassword
     */
    public $conOptPassword;

    public function __construct(ConnectionOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPasswordConnectionOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPasswordConnectionOption($this);
        }
    }
}

class GtuidSetContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_gtuidSet;
    }

    /**
     * @return array<UuidSetContext>|UuidSetContext|null
     */
    public function uuidSet(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UuidSetContext::class);
        }

        return $this->getTypedRuleContext(UuidSetContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGtuidSet($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGtuidSet($this);
        }
    }
}

class XaStartTransactionContext extends ParserRuleContext
{
    /**
     * @var Token|null $xaStart
     */
    public $xaStart;

    /**
     * @var Token|null $xaAction
     */
    public $xaAction;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_xaStartTransaction;
    }

    public function XA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA, 0);
    }

    public function xid(): ?XidContext
    {
        return $this->getTypedRuleContext(XidContext::class, 0);
    }

    public function START(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::START, 0);
    }

    public function BEGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BEGIN, 0);
    }

    public function JOIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JOIN, 0);
    }

    public function RESUME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESUME, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterXaStartTransaction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitXaStartTransaction($this);
        }
    }
}

class XaEndTransactionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_xaEndTransaction;
    }

    public function XA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA, 0);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    public function xid(): ?XidContext
    {
        return $this->getTypedRuleContext(XidContext::class, 0);
    }

    public function SUSPEND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUSPEND, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function MIGRATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MIGRATE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterXaEndTransaction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitXaEndTransaction($this);
        }
    }
}

class XaPrepareStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_xaPrepareStatement;
    }

    public function XA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA, 0);
    }

    public function PREPARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PREPARE, 0);
    }

    public function xid(): ?XidContext
    {
        return $this->getTypedRuleContext(XidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterXaPrepareStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitXaPrepareStatement($this);
        }
    }
}

class XaCommitWorkContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_xaCommitWork;
    }

    public function XA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA, 0);
    }

    public function COMMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMIT, 0);
    }

    public function xid(): ?XidContext
    {
        return $this->getTypedRuleContext(XidContext::class, 0);
    }

    public function ONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE, 0);
    }

    public function PHASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PHASE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterXaCommitWork($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitXaCommitWork($this);
        }
    }
}

class XaRollbackWorkContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_xaRollbackWork;
    }

    public function XA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA, 0);
    }

    public function ROLLBACK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLLBACK, 0);
    }

    public function xid(): ?XidContext
    {
        return $this->getTypedRuleContext(XidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterXaRollbackWork($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitXaRollbackWork($this);
        }
    }
}

class XaRecoverWorkContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_xaRecoverWork;
    }

    public function XA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA, 0);
    }

    public function RECOVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RECOVER, 0);
    }

    public function CONVERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONVERT, 0);
    }

    public function xid(): ?XidContext
    {
        return $this->getTypedRuleContext(XidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterXaRecoverWork($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitXaRecoverWork($this);
        }
    }
}

class PrepareStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $query
     */
    public $query;

    /**
     * @var Token|null $variable
     */
    public $variable;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_prepareStatement;
    }

    public function PREPARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PREPARE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function LOCAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL_ID, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPrepareStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPrepareStatement($this);
        }
    }
}

class ExecuteStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_executeStatement;
    }

    public function EXECUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXECUTE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function USING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USING, 0);
    }

    public function userVariables(): ?UserVariablesContext
    {
        return $this->getTypedRuleContext(UserVariablesContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterExecuteStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitExecuteStatement($this);
        }
    }
}

class DeallocatePrepareContext extends ParserRuleContext
{
    /**
     * @var Token|null $dropFormat
     */
    public $dropFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_deallocatePrepare;
    }

    public function PREPARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PREPARE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function DEALLOCATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEALLOCATE, 0);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDeallocatePrepare($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDeallocatePrepare($this);
        }
    }
}

class RoutineBodyContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_routineBody;
    }

    public function blockStatement(): ?BlockStatementContext
    {
        return $this->getTypedRuleContext(BlockStatementContext::class, 0);
    }

    public function sqlStatement(): ?SqlStatementContext
    {
        return $this->getTypedRuleContext(SqlStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoutineBody($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoutineBody($this);
        }
    }
}

class BlockStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_blockStatement;
    }

    public function BEGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BEGIN, 0);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function COLON_SYMB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLON_SYMB, 0);
    }

    /**
     * @return array<DeclareVariableContext>|DeclareVariableContext|null
     */
    public function declareVariable(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DeclareVariableContext::class);
        }

        return $this->getTypedRuleContext(DeclareVariableContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function SEMI(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::SEMI);
        }

        return $this->getToken(MySqlParser::SEMI, $index);
    }

    /**
     * @return array<DeclareConditionContext>|DeclareConditionContext|null
     */
    public function declareCondition(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DeclareConditionContext::class);
        }

        return $this->getTypedRuleContext(DeclareConditionContext::class, $index);
    }

    /**
     * @return array<DeclareCursorContext>|DeclareCursorContext|null
     */
    public function declareCursor(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DeclareCursorContext::class);
        }

        return $this->getTypedRuleContext(DeclareCursorContext::class, $index);
    }

    /**
     * @return array<DeclareHandlerContext>|DeclareHandlerContext|null
     */
    public function declareHandler(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DeclareHandlerContext::class);
        }

        return $this->getTypedRuleContext(DeclareHandlerContext::class, $index);
    }

    /**
     * @return array<ProcedureSqlStatementContext>|ProcedureSqlStatementContext|null
     */
    public function procedureSqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureSqlStatementContext::class);
        }

        return $this->getTypedRuleContext(ProcedureSqlStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBlockStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBlockStatement($this);
        }
    }
}

class CaseStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_caseStatement;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function CASE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::CASE);
        }

        return $this->getToken(MySqlParser::CASE, $index);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    /**
     * @return array<CaseAlternativeContext>|CaseAlternativeContext|null
     */
    public function caseAlternative(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CaseAlternativeContext::class);
        }

        return $this->getTypedRuleContext(CaseAlternativeContext::class, $index);
    }

    public function ELSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ELSE, 0);
    }

    /**
     * @return array<ProcedureSqlStatementContext>|ProcedureSqlStatementContext|null
     */
    public function procedureSqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureSqlStatementContext::class);
        }

        return $this->getTypedRuleContext(ProcedureSqlStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCaseStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCaseStatement($this);
        }
    }
}

class IfStatementContext extends ParserRuleContext
{
    /**
     * @var ProcedureSqlStatementContext|null $procedureSqlStatement
     */
    public $procedureSqlStatement;

    /**
     * @var array<ProcedureSqlStatementContext>|null $thenStatements
     */
    public $thenStatements;

    /**
     * @var array<ProcedureSqlStatementContext>|null $elseStatements
     */
    public $elseStatements;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_ifStatement;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function IF(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::IF);
        }

        return $this->getToken(MySqlParser::IF, $index);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function THEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::THEN, 0);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    /**
     * @return array<ElifAlternativeContext>|ElifAlternativeContext|null
     */
    public function elifAlternative(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ElifAlternativeContext::class);
        }

        return $this->getTypedRuleContext(ElifAlternativeContext::class, $index);
    }

    public function ELSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ELSE, 0);
    }

    /**
     * @return array<ProcedureSqlStatementContext>|ProcedureSqlStatementContext|null
     */
    public function procedureSqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureSqlStatementContext::class);
        }

        return $this->getTypedRuleContext(ProcedureSqlStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIfStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIfStatement($this);
        }
    }
}

class IterateStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_iterateStatement;
    }

    public function ITERATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ITERATE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIterateStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIterateStatement($this);
        }
    }
}

class LeaveStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_leaveStatement;
    }

    public function LEAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEAVE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLeaveStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLeaveStatement($this);
        }
    }
}

class LoopStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_loopStatement;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LOOP(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LOOP);
        }

        return $this->getToken(MySqlParser::LOOP, $index);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function COLON_SYMB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLON_SYMB, 0);
    }

    /**
     * @return array<ProcedureSqlStatementContext>|ProcedureSqlStatementContext|null
     */
    public function procedureSqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureSqlStatementContext::class);
        }

        return $this->getTypedRuleContext(ProcedureSqlStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLoopStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLoopStatement($this);
        }
    }
}

class RepeatStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_repeatStatement;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function REPEAT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::REPEAT);
        }

        return $this->getToken(MySqlParser::REPEAT, $index);
    }

    public function UNTIL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNTIL, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function COLON_SYMB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLON_SYMB, 0);
    }

    /**
     * @return array<ProcedureSqlStatementContext>|ProcedureSqlStatementContext|null
     */
    public function procedureSqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureSqlStatementContext::class);
        }

        return $this->getTypedRuleContext(ProcedureSqlStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRepeatStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRepeatStatement($this);
        }
    }
}

class ReturnStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_returnStatement;
    }

    public function RETURN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RETURN, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterReturnStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitReturnStatement($this);
        }
    }
}

class WhileStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_whileStatement;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function WHILE(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::WHILE);
        }

        return $this->getToken(MySqlParser::WHILE, $index);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function DO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DO, 0);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function COLON_SYMB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLON_SYMB, 0);
    }

    /**
     * @return array<ProcedureSqlStatementContext>|ProcedureSqlStatementContext|null
     */
    public function procedureSqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureSqlStatementContext::class);
        }

        return $this->getTypedRuleContext(ProcedureSqlStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWhileStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWhileStatement($this);
        }
    }
}

class CursorStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_cursorStatement;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class CloseCursorContext extends CursorStatementContext
{
    public function __construct(CursorStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CLOSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLOSE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCloseCursor($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCloseCursor($this);
        }
    }
}

class OpenCursorContext extends CursorStatementContext
{
    public function __construct(CursorStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function OPEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPEN, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterOpenCursor($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitOpenCursor($this);
        }
    }
}

class FetchCursorContext extends CursorStatementContext
{
    public function __construct(CursorStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function FETCH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FETCH, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function NEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NEXT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFetchCursor($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFetchCursor($this);
        }
    }
}

class DeclareVariableContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_declareVariable;
    }

    public function DECLARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECLARE, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function dataType(): ?DataTypeContext
    {
        return $this->getTypedRuleContext(DataTypeContext::class, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDeclareVariable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDeclareVariable($this);
        }
    }
}

class DeclareConditionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_declareCondition;
    }

    public function DECLARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECLARE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function CONDITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONDITION, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function SQLSTATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQLSTATE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDeclareCondition($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDeclareCondition($this);
        }
    }
}

class DeclareCursorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_declareCursor;
    }

    public function DECLARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECLARE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function CURSOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURSOR, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDeclareCursor($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDeclareCursor($this);
        }
    }
}

class DeclareHandlerContext extends ParserRuleContext
{
    /**
     * @var Token|null $handlerAction
     */
    public $handlerAction;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_declareHandler;
    }

    public function DECLARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECLARE, 0);
    }

    public function HANDLER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HANDLER, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    /**
     * @return array<HandlerConditionValueContext>|HandlerConditionValueContext|null
     */
    public function handlerConditionValue(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(HandlerConditionValueContext::class);
        }

        return $this->getTypedRuleContext(HandlerConditionValueContext::class, $index);
    }

    public function routineBody(): ?RoutineBodyContext
    {
        return $this->getTypedRuleContext(RoutineBodyContext::class, 0);
    }

    public function CONTINUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONTINUE, 0);
    }

    public function EXIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXIT, 0);
    }

    public function UNDO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDO, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDeclareHandler($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDeclareHandler($this);
        }
    }
}

class HandlerConditionValueContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_handlerConditionValue;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class HandlerConditionWarningContext extends HandlerConditionValueContext
{
    public function __construct(HandlerConditionValueContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SQLWARNING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQLWARNING, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerConditionWarning($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerConditionWarning($this);
        }
    }
}

class HandlerConditionCodeContext extends HandlerConditionValueContext
{
    public function __construct(HandlerConditionValueContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerConditionCode($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerConditionCode($this);
        }
    }
}

class HandlerConditionNotfoundContext extends HandlerConditionValueContext
{
    public function __construct(HandlerConditionValueContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function FOUND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOUND, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerConditionNotfound($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerConditionNotfound($this);
        }
    }
}

class HandlerConditionStateContext extends HandlerConditionValueContext
{
    public function __construct(HandlerConditionValueContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SQLSTATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQLSTATE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerConditionState($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerConditionState($this);
        }
    }
}

class HandlerConditionExceptionContext extends HandlerConditionValueContext
{
    public function __construct(HandlerConditionValueContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SQLEXCEPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQLEXCEPTION, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerConditionException($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerConditionException($this);
        }
    }
}

class HandlerConditionNameContext extends HandlerConditionValueContext
{
    public function __construct(HandlerConditionValueContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHandlerConditionName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHandlerConditionName($this);
        }
    }
}

class ProcedureSqlStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_procedureSqlStatement;
    }

    public function SEMI(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SEMI, 0);
    }

    public function compoundStatement(): ?CompoundStatementContext
    {
        return $this->getTypedRuleContext(CompoundStatementContext::class, 0);
    }

    public function sqlStatement(): ?SqlStatementContext
    {
        return $this->getTypedRuleContext(SqlStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterProcedureSqlStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitProcedureSqlStatement($this);
        }
    }
}

class CaseAlternativeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_caseAlternative;
    }

    public function WHEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHEN, 0);
    }

    public function THEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::THEN, 0);
    }

    public function constant(): ?ConstantContext
    {
        return $this->getTypedRuleContext(ConstantContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    /**
     * @return array<ProcedureSqlStatementContext>|ProcedureSqlStatementContext|null
     */
    public function procedureSqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureSqlStatementContext::class);
        }

        return $this->getTypedRuleContext(ProcedureSqlStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCaseAlternative($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCaseAlternative($this);
        }
    }
}

class ElifAlternativeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_elifAlternative;
    }

    public function ELSEIF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ELSEIF, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function THEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::THEN, 0);
    }

    /**
     * @return array<ProcedureSqlStatementContext>|ProcedureSqlStatementContext|null
     */
    public function procedureSqlStatement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ProcedureSqlStatementContext::class);
        }

        return $this->getTypedRuleContext(ProcedureSqlStatementContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterElifAlternative($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitElifAlternative($this);
        }
    }
}

class AlterUserContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_alterUser;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class AlterUserMysqlV80Context extends AlterUserContext
{
    /**
     * @var Token|null $tlsNone
     */
    public $tlsNone;

    public function __construct(AlterUserContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    /**
     * @return array<UserAuthOptionContext>|UserAuthOptionContext|null
     */
    public function userAuthOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserAuthOptionContext::class);
        }

        return $this->getTypedRuleContext(UserAuthOptionContext::class, $index);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function REQUIRE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REQUIRE, 0);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    /**
     * @return array<UserPasswordOptionContext>|UserPasswordOptionContext|null
     */
    public function userPasswordOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserPasswordOptionContext::class);
        }

        return $this->getTypedRuleContext(UserPasswordOptionContext::class, $index);
    }

    /**
     * @return array<UserLockOptionContext>|UserLockOptionContext|null
     */
    public function userLockOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserLockOptionContext::class);
        }

        return $this->getTypedRuleContext(UserLockOptionContext::class, $index);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ATTRIBUTE, 0);
    }

    /**
     * @return array<TlsOptionContext>|TlsOptionContext|null
     */
    public function tlsOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TlsOptionContext::class);
        }

        return $this->getTypedRuleContext(TlsOptionContext::class, $index);
    }

    public function NONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NONE, 0);
    }

    /**
     * @return array<UserResourceOptionContext>|UserResourceOptionContext|null
     */
    public function userResourceOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserResourceOptionContext::class);
        }

        return $this->getTypedRuleContext(UserResourceOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function AND(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::AND);
        }

        return $this->getToken(MySqlParser::AND, $index);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function ROLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE, 0);
    }

    public function roleOption(): ?RoleOptionContext
    {
        return $this->getTypedRuleContext(RoleOptionContext::class, 0);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterUserMysqlV80($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterUserMysqlV80($this);
        }
    }
}

class AlterUserMysqlV56Context extends AlterUserContext
{
    public function __construct(AlterUserContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    /**
     * @return array<UserSpecificationContext>|UserSpecificationContext|null
     */
    public function userSpecification(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserSpecificationContext::class);
        }

        return $this->getTypedRuleContext(UserSpecificationContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAlterUserMysqlV56($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAlterUserMysqlV56($this);
        }
    }
}

class CreateUserContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createUser;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class CreateUserMysqlV56Context extends CreateUserContext
{
    public function __construct(CreateUserContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    /**
     * @return array<UserAuthOptionContext>|UserAuthOptionContext|null
     */
    public function userAuthOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserAuthOptionContext::class);
        }

        return $this->getTypedRuleContext(UserAuthOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateUserMysqlV56($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateUserMysqlV56($this);
        }
    }
}

class CreateUserMysqlV80Context extends CreateUserContext
{
    /**
     * @var Token|null $tlsNone
     */
    public $tlsNone;

    public function __construct(CreateUserContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    /**
     * @return array<UserAuthOptionContext>|UserAuthOptionContext|null
     */
    public function userAuthOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserAuthOptionContext::class);
        }

        return $this->getTypedRuleContext(UserAuthOptionContext::class, $index);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function ROLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE, 0);
    }

    public function roleOption(): ?RoleOptionContext
    {
        return $this->getTypedRuleContext(RoleOptionContext::class, 0);
    }

    public function REQUIRE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REQUIRE, 0);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    /**
     * @return array<UserPasswordOptionContext>|UserPasswordOptionContext|null
     */
    public function userPasswordOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserPasswordOptionContext::class);
        }

        return $this->getTypedRuleContext(UserPasswordOptionContext::class, $index);
    }

    /**
     * @return array<UserLockOptionContext>|UserLockOptionContext|null
     */
    public function userLockOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserLockOptionContext::class);
        }

        return $this->getTypedRuleContext(UserLockOptionContext::class, $index);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ATTRIBUTE, 0);
    }

    /**
     * @return array<TlsOptionContext>|TlsOptionContext|null
     */
    public function tlsOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TlsOptionContext::class);
        }

        return $this->getTypedRuleContext(TlsOptionContext::class, $index);
    }

    public function NONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NONE, 0);
    }

    /**
     * @return array<UserResourceOptionContext>|UserResourceOptionContext|null
     */
    public function userResourceOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserResourceOptionContext::class);
        }

        return $this->getTypedRuleContext(UserResourceOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function AND(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::AND);
        }

        return $this->getToken(MySqlParser::AND, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateUserMysqlV80($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateUserMysqlV80($this);
        }
    }
}

class DropUserContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dropUser;
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    public function ifExists(): ?IfExistsContext
    {
        return $this->getTypedRuleContext(IfExistsContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDropUser($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDropUser($this);
        }
    }
}

class GrantStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $privilegeObject
     */
    public $privilegeObject;

    /**
     * @var Token|null $tlsNone
     */
    public $tlsNone;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_grantStatement;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function GRANT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::GRANT);
        }

        return $this->getToken(MySqlParser::GRANT, $index);
    }

    /**
     * @return array<PrivelegeClauseContext>|PrivelegeClauseContext|null
     */
    public function privelegeClause(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PrivelegeClauseContext::class);
        }

        return $this->getTypedRuleContext(PrivelegeClauseContext::class, $index);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function privilegeLevel(): ?PrivilegeLevelContext
    {
        return $this->getTypedRuleContext(PrivilegeLevelContext::class, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    /**
     * @return array<UserAuthOptionContext>|UserAuthOptionContext|null
     */
    public function userAuthOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserAuthOptionContext::class);
        }

        return $this->getTypedRuleContext(UserAuthOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function REQUIRE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REQUIRE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function WITH(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::WITH);
        }

        return $this->getToken(MySqlParser::WITH, $index);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    public function ROLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE, 0);
    }

    public function roleOption(): ?RoleOptionContext
    {
        return $this->getTypedRuleContext(RoleOptionContext::class, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function PROCEDURE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCEDURE, 0);
    }

    /**
     * @return array<TlsOptionContext>|TlsOptionContext|null
     */
    public function tlsOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TlsOptionContext::class);
        }

        return $this->getTypedRuleContext(TlsOptionContext::class, $index);
    }

    public function NONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NONE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function OPTION(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::OPTION);
        }

        return $this->getToken(MySqlParser::OPTION, $index);
    }

    /**
     * @return array<UserResourceOptionContext>|UserResourceOptionContext|null
     */
    public function userResourceOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserResourceOptionContext::class);
        }

        return $this->getTypedRuleContext(UserResourceOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function AND(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::AND);
        }

        return $this->getToken(MySqlParser::AND, $index);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADMIN, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGrantStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGrantStatement($this);
        }
    }
}

class RoleOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_roleOption;
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function NONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NONE, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function EXCEPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCEPT, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoleOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoleOption($this);
        }
    }
}

class GrantProxyContext extends ParserRuleContext
{
    /**
     * @var UserNameContext|null $fromFirst
     */
    public $fromFirst;

    /**
     * @var UserNameContext|null $toFirst
     */
    public $toFirst;

    /**
     * @var UserNameContext|null $userName
     */
    public $userName;

    /**
     * @var array<UserNameContext>|null $toOther
     */
    public $toOther;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_grantProxy;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function GRANT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::GRANT);
        }

        return $this->getToken(MySqlParser::GRANT, $index);
    }

    public function PROXY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROXY, 0);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function OPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTION, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGrantProxy($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGrantProxy($this);
        }
    }
}

class RenameUserContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_renameUser;
    }

    public function RENAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RENAME, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    /**
     * @return array<RenameUserClauseContext>|RenameUserClauseContext|null
     */
    public function renameUserClause(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(RenameUserClauseContext::class);
        }

        return $this->getTypedRuleContext(RenameUserClauseContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRenameUser($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRenameUser($this);
        }
    }
}

class RevokeStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_revokeStatement;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class DetailRevokeContext extends RevokeStatementContext
{
    /**
     * @var Token|null $privilegeObject
     */
    public $privilegeObject;

    public function __construct(RevokeStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REVOKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REVOKE, 0);
    }

    /**
     * @return array<PrivelegeClauseContext>|PrivelegeClauseContext|null
     */
    public function privelegeClause(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PrivelegeClauseContext::class);
        }

        return $this->getTypedRuleContext(PrivelegeClauseContext::class, $index);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function privilegeLevel(): ?PrivilegeLevelContext
    {
        return $this->getTypedRuleContext(PrivilegeLevelContext::class, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function PROCEDURE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCEDURE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDetailRevoke($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDetailRevoke($this);
        }
    }
}

class RoleRevokeContext extends RevokeStatementContext
{
    public function __construct(RevokeStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REVOKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REVOKE, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoleRevoke($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoleRevoke($this);
        }
    }
}

class ShortRevokeContext extends RevokeStatementContext
{
    public function __construct(RevokeStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function REVOKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REVOKE, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function GRANT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GRANT, 0);
    }

    public function OPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTION, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    public function PRIVILEGES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIVILEGES, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShortRevoke($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShortRevoke($this);
        }
    }
}

class RevokeProxyContext extends ParserRuleContext
{
    /**
     * @var UserNameContext|null $onUser
     */
    public $onUser;

    /**
     * @var UserNameContext|null $fromFirst
     */
    public $fromFirst;

    /**
     * @var UserNameContext|null $userName
     */
    public $userName;

    /**
     * @var array<UserNameContext>|null $fromOther
     */
    public $fromOther;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_revokeProxy;
    }

    public function REVOKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REVOKE, 0);
    }

    public function PROXY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROXY, 0);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRevokeProxy($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRevokeProxy($this);
        }
    }
}

class SetPasswordStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_setPasswordStatement;
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function passwordFunctionClause(): ?PasswordFunctionClauseContext
    {
        return $this->getTypedRuleContext(PasswordFunctionClauseContext::class, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetPasswordStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetPasswordStatement($this);
        }
    }
}

class UserSpecificationContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_userSpecification;
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function userPasswordOption(): ?UserPasswordOptionContext
    {
        return $this->getTypedRuleContext(UserPasswordOptionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUserSpecification($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUserSpecification($this);
        }
    }
}

class UserAuthOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_userAuthOption;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SimpleAuthOptionContext extends UserAuthOptionContext
{
    public function __construct(UserAuthOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleAuthOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleAuthOption($this);
        }
    }
}

class ModuleAuthOptionContext extends UserAuthOptionContext
{
    public function __construct(UserAuthOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function IDENTIFIED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IDENTIFIED, 0);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function authenticationRule(): ?AuthenticationRuleContext
    {
        return $this->getTypedRuleContext(AuthenticationRuleContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterModuleAuthOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitModuleAuthOption($this);
        }
    }
}

class RandomAuthOptionContext extends UserAuthOptionContext
{
    public function __construct(UserAuthOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function IDENTIFIED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IDENTIFIED, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function RANDOM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RANDOM, 0);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function authOptionClause(): ?AuthOptionClauseContext
    {
        return $this->getTypedRuleContext(AuthOptionClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRandomAuthOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRandomAuthOption($this);
        }
    }
}

class StringAuthOptionContext extends UserAuthOptionContext
{
    public function __construct(UserAuthOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function IDENTIFIED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IDENTIFIED, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function authOptionClause(): ?AuthOptionClauseContext
    {
        return $this->getTypedRuleContext(AuthOptionClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStringAuthOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStringAuthOption($this);
        }
    }
}

class HashAuthOptionContext extends UserAuthOptionContext
{
    /**
     * @var Token|null $hashed
     */
    public $hashed;

    public function __construct(UserAuthOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function IDENTIFIED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IDENTIFIED, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHashAuthOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHashAuthOption($this);
        }
    }
}

class AuthOptionClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_authOptionClause;
    }

    public function REPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLACE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function RETAIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RETAIN, 0);
    }

    public function CURRENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT, 0);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAuthOptionClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAuthOptionClause($this);
        }
    }
}

class AuthenticationRuleContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_authenticationRule;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class PasswordModuleOptionContext extends AuthenticationRuleContext
{
    public function __construct(AuthenticationRuleContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function authPlugin(): ?AuthPluginContext
    {
        return $this->getTypedRuleContext(AuthPluginContext::class, 0);
    }

    public function USING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USING, 0);
    }

    public function passwordFunctionClause(): ?PasswordFunctionClauseContext
    {
        return $this->getTypedRuleContext(PasswordFunctionClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPasswordModuleOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPasswordModuleOption($this);
        }
    }
}

class ModuleContext extends AuthenticationRuleContext
{
    public function __construct(AuthenticationRuleContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function authPlugin(): ?AuthPluginContext
    {
        return $this->getTypedRuleContext(AuthPluginContext::class, 0);
    }

    public function authOptionClause(): ?AuthOptionClauseContext
    {
        return $this->getTypedRuleContext(AuthOptionClauseContext::class, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    public function USING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USING, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function RANDOM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RANDOM, 0);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterModule($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitModule($this);
        }
    }
}

class TlsOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tlsOption;
    }

    public function SSL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SSL, 0);
    }

    public function X509(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::X509, 0);
    }

    public function CIPHER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CIPHER, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ISSUER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISSUER, 0);
    }

    public function SUBJECT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBJECT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTlsOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTlsOption($this);
        }
    }
}

class UserResourceOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_userResourceOption;
    }

    public function MAX_QUERIES_PER_HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_QUERIES_PER_HOUR, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function MAX_UPDATES_PER_HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_UPDATES_PER_HOUR, 0);
    }

    public function MAX_CONNECTIONS_PER_HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_CONNECTIONS_PER_HOUR, 0);
    }

    public function MAX_USER_CONNECTIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_USER_CONNECTIONS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUserResourceOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUserResourceOption($this);
        }
    }
}

class UserPasswordOptionContext extends ParserRuleContext
{
    /**
     * @var Token|null $expireType
     */
    public $expireType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_userPasswordOption;
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function EXPIRE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXPIRE, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function DAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAY, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function NEVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NEVER, 0);
    }

    public function INTERVAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTERVAL, 0);
    }

    public function HISTORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HISTORY, 0);
    }

    public function REUSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REUSE, 0);
    }

    public function REQUIRE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REQUIRE, 0);
    }

    public function CURRENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT, 0);
    }

    public function OPTIONAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIONAL, 0);
    }

    public function FAILED_LOGIN_ATTEMPTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FAILED_LOGIN_ATTEMPTS, 0);
    }

    public function PASSWORD_LOCK_TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD_LOCK_TIME, 0);
    }

    public function UNBOUNDED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNBOUNDED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUserPasswordOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUserPasswordOption($this);
        }
    }
}

class UserLockOptionContext extends ParserRuleContext
{
    /**
     * @var Token|null $lockType
     */
    public $lockType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_userLockOption;
    }

    public function ACCOUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ACCOUNT, 0);
    }

    public function LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCK, 0);
    }

    public function UNLOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNLOCK, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUserLockOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUserLockOption($this);
        }
    }
}

class PrivelegeClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_privelegeClause;
    }

    public function privilege(): ?PrivilegeContext
    {
        return $this->getTypedRuleContext(PrivilegeContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPrivelegeClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPrivelegeClause($this);
        }
    }
}

class PrivilegeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_privilege;
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function PRIVILEGES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIVILEGES, 0);
    }

    public function ALTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALTER, 0);
    }

    public function ROUTINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROUTINE, 0);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function TEMPORARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPORARY, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function VIEW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VIEW, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function ROLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE, 0);
    }

    public function DELETE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELETE, 0);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function EVENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENT, 0);
    }

    public function EXECUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXECUTE, 0);
    }

    public function FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FILE, 0);
    }

    public function GRANT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GRANT, 0);
    }

    public function OPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTION, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function INSERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSERT, 0);
    }

    public function LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCK, 0);
    }

    public function PROCESS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCESS, 0);
    }

    public function PROXY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROXY, 0);
    }

    public function REFERENCES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REFERENCES, 0);
    }

    public function RELOAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELOAD, 0);
    }

    public function REPLICATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATION, 0);
    }

    public function CLIENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLIENT, 0);
    }

    public function SLAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLAVE, 0);
    }

    public function SELECT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SELECT, 0);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function DATABASES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASES, 0);
    }

    public function SHUTDOWN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHUTDOWN, 0);
    }

    public function SUPER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUPER, 0);
    }

    public function TRIGGER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRIGGER, 0);
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function USAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USAGE, 0);
    }

    public function APPLICATION_PASSWORD_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::APPLICATION_PASSWORD_ADMIN, 0);
    }

    public function AUDIT_ABORT_EXEMPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUDIT_ABORT_EXEMPT, 0);
    }

    public function AUDIT_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUDIT_ADMIN, 0);
    }

    public function AUTHENTICATION_POLICY_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTHENTICATION_POLICY_ADMIN, 0);
    }

    public function BACKUP_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BACKUP_ADMIN, 0);
    }

    public function BINLOG_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINLOG_ADMIN, 0);
    }

    public function BINLOG_ENCRYPTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINLOG_ENCRYPTION_ADMIN, 0);
    }

    public function CLONE_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLONE_ADMIN, 0);
    }

    public function CONNECTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECTION_ADMIN, 0);
    }

    public function ENCRYPTION_KEY_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCRYPTION_KEY_ADMIN, 0);
    }

    public function FIREWALL_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIREWALL_ADMIN, 0);
    }

    public function FIREWALL_EXEMPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIREWALL_EXEMPT, 0);
    }

    public function FIREWALL_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIREWALL_USER, 0);
    }

    public function FLUSH_OPTIMIZER_COSTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLUSH_OPTIMIZER_COSTS, 0);
    }

    public function FLUSH_STATUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLUSH_STATUS, 0);
    }

    public function FLUSH_TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLUSH_TABLES, 0);
    }

    public function FLUSH_USER_RESOURCES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLUSH_USER_RESOURCES, 0);
    }

    public function GROUP_REPLICATION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP_REPLICATION_ADMIN, 0);
    }

    public function INNODB_REDO_LOG_ARCHIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INNODB_REDO_LOG_ARCHIVE, 0);
    }

    public function INNODB_REDO_LOG_ENABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INNODB_REDO_LOG_ENABLE, 0);
    }

    public function NDB_STORED_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NDB_STORED_USER, 0);
    }

    public function PASSWORDLESS_USER_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORDLESS_USER_ADMIN, 0);
    }

    public function PERSIST_RO_VARIABLES_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PERSIST_RO_VARIABLES_ADMIN, 0);
    }

    public function REPLICATION_APPLIER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATION_APPLIER, 0);
    }

    public function REPLICATION_SLAVE_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATION_SLAVE_ADMIN, 0);
    }

    public function RESOURCE_GROUP_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESOURCE_GROUP_ADMIN, 0);
    }

    public function RESOURCE_GROUP_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESOURCE_GROUP_USER, 0);
    }

    public function ROLE_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE_ADMIN, 0);
    }

    public function SERVICE_CONNECTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERVICE_CONNECTION_ADMIN, 0);
    }

    public function SESSION_VARIABLES_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SESSION_VARIABLES_ADMIN, 0);
    }

    public function SET_USER_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET_USER_ID, 0);
    }

    public function SKIP_QUERY_REWRITE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SKIP_QUERY_REWRITE, 0);
    }

    public function SHOW_ROUTINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW_ROUTINE, 0);
    }

    public function SYSTEM_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SYSTEM_USER, 0);
    }

    public function SYSTEM_VARIABLES_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SYSTEM_VARIABLES_ADMIN, 0);
    }

    public function TABLE_ENCRYPTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE_ENCRYPTION_ADMIN, 0);
    }

    public function TP_CONNECTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TP_CONNECTION_ADMIN, 0);
    }

    public function VERSION_TOKEN_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VERSION_TOKEN_ADMIN, 0);
    }

    public function XA_RECOVER_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA_RECOVER_ADMIN, 0);
    }

    public function LOAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOAD, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function S3(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::S3, 0);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function INVOKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVOKE, 0);
    }

    public function LAMBDA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAMBDA, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPrivilege($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPrivilege($this);
        }
    }
}

class PrivilegeLevelContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_privilegeLevel;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class DefiniteSchemaPrivLevelContext extends PrivilegeLevelContext
{
    public function __construct(PrivilegeLevelContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function DOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOT, 0);
    }

    public function STAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STAR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDefiniteSchemaPrivLevel($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDefiniteSchemaPrivLevel($this);
        }
    }
}

class DefiniteFullTablePrivLevel2Context extends PrivilegeLevelContext
{
    public function __construct(PrivilegeLevelContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function dottedId(): ?DottedIdContext
    {
        return $this->getTypedRuleContext(DottedIdContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDefiniteFullTablePrivLevel2($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDefiniteFullTablePrivLevel2($this);
        }
    }
}

class DefiniteFullTablePrivLevelContext extends PrivilegeLevelContext
{
    public function __construct(PrivilegeLevelContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function DOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDefiniteFullTablePrivLevel($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDefiniteFullTablePrivLevel($this);
        }
    }
}

class GlobalPrivLevelContext extends PrivilegeLevelContext
{
    public function __construct(PrivilegeLevelContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STAR(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STAR);
        }

        return $this->getToken(MySqlParser::STAR, $index);
    }

    public function DOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGlobalPrivLevel($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGlobalPrivLevel($this);
        }
    }
}

class DefiniteTablePrivLevelContext extends PrivilegeLevelContext
{
    public function __construct(PrivilegeLevelContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDefiniteTablePrivLevel($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDefiniteTablePrivLevel($this);
        }
    }
}

class CurrentSchemaPriviLevelContext extends PrivilegeLevelContext
{
    public function __construct(PrivilegeLevelContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function STAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STAR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCurrentSchemaPriviLevel($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCurrentSchemaPriviLevel($this);
        }
    }
}

class RenameUserClauseContext extends ParserRuleContext
{
    /**
     * @var UserNameContext|null $fromFirst
     */
    public $fromFirst;

    /**
     * @var UserNameContext|null $toFirst
     */
    public $toFirst;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_renameUserClause;
    }

    public function TO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO, 0);
    }

    /**
     * @return array<UserNameContext>|UserNameContext|null
     */
    public function userName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UserNameContext::class);
        }

        return $this->getTypedRuleContext(UserNameContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRenameUserClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRenameUserClause($this);
        }
    }
}

class AnalyzeTableContext extends ParserRuleContext
{
    /**
     * @var Token|null $actionOption
     */
    public $actionOption;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_analyzeTable;
    }

    public function ANALYZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ANALYZE, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function HISTOGRAM(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::HISTOGRAM);
        }

        return $this->getToken(MySqlParser::HISTOGRAM, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ON(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ON);
        }

        return $this->getToken(MySqlParser::ON, $index);
    }

    /**
     * @return array<FullColumnNameContext>|FullColumnNameContext|null
     */
    public function fullColumnName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FullColumnNameContext::class);
        }

        return $this->getTypedRuleContext(FullColumnNameContext::class, $index);
    }

    public function DROP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DROP, 0);
    }

    public function NO_WRITE_TO_BINLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NO_WRITE_TO_BINLOG, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function BUCKETS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BUCKETS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAnalyzeTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAnalyzeTable($this);
        }
    }
}

class CheckTableContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_checkTable;
    }

    public function CHECK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECK, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    /**
     * @return array<CheckTableOptionContext>|CheckTableOptionContext|null
     */
    public function checkTableOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CheckTableOptionContext::class);
        }

        return $this->getTypedRuleContext(CheckTableOptionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCheckTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCheckTable($this);
        }
    }
}

class ChecksumTableContext extends ParserRuleContext
{
    /**
     * @var Token|null $actionOption
     */
    public $actionOption;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_checksumTable;
    }

    public function CHECKSUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECKSUM, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function QUICK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUICK, 0);
    }

    public function EXTENDED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTENDED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterChecksumTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitChecksumTable($this);
        }
    }
}

class OptimizeTableContext extends ParserRuleContext
{
    /**
     * @var Token|null $actionOption
     */
    public $actionOption;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_optimizeTable;
    }

    public function OPTIMIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIMIZE, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function NO_WRITE_TO_BINLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NO_WRITE_TO_BINLOG, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterOptimizeTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitOptimizeTable($this);
        }
    }
}

class RepairTableContext extends ParserRuleContext
{
    /**
     * @var Token|null $actionOption
     */
    public $actionOption;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_repairTable;
    }

    public function REPAIR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPAIR, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function QUICK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUICK, 0);
    }

    public function EXTENDED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTENDED, 0);
    }

    public function USE_FRM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USE_FRM, 0);
    }

    public function NO_WRITE_TO_BINLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NO_WRITE_TO_BINLOG, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRepairTable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRepairTable($this);
        }
    }
}

class CheckTableOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_checkTableOption;
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function UPGRADE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPGRADE, 0);
    }

    public function QUICK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUICK, 0);
    }

    public function FAST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FAST, 0);
    }

    public function MEDIUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEDIUM, 0);
    }

    public function EXTENDED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTENDED, 0);
    }

    public function CHANGED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHANGED, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCheckTableOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCheckTableOption($this);
        }
    }
}

class CreateUdfunctionContext extends ParserRuleContext
{
    /**
     * @var Token|null $returnType
     */
    public $returnType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_createUdfunction;
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function RETURNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RETURNS, 0);
    }

    public function SONAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SONAME, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function STRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING, 0);
    }

    public function INTEGER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTEGER, 0);
    }

    public function REAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REAL, 0);
    }

    public function DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECIMAL, 0);
    }

    public function AGGREGATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AGGREGATE, 0);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCreateUdfunction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCreateUdfunction($this);
        }
    }
}

class InstallPluginContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_installPlugin;
    }

    public function INSTALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSTALL, 0);
    }

    public function PLUGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUGIN, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function SONAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SONAME, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterInstallPlugin($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitInstallPlugin($this);
        }
    }
}

class UninstallPluginContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_uninstallPlugin;
    }

    public function UNINSTALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNINSTALL, 0);
    }

    public function PLUGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUGIN, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUninstallPlugin($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUninstallPlugin($this);
        }
    }
}

class SetStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_setStatement;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SetTransactionContext extends SetStatementContext
{
    public function __construct(SetStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function setTransactionStatement(): ?SetTransactionStatementContext
    {
        return $this->getTypedRuleContext(SetTransactionStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetTransaction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetTransaction($this);
        }
    }
}

class SetCharsetContext extends SetStatementContext
{
    public function __construct(SetStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function charSet(): ?CharSetContext
    {
        return $this->getTypedRuleContext(CharSetContext::class, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetCharset($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetCharset($this);
        }
    }
}

class SetNamesContext extends SetStatementContext
{
    public function __construct(SetStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function NAMES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NAMES, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetNames($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetNames($this);
        }
    }
}

class SetPasswordContext extends SetStatementContext
{
    public function __construct(SetStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function setPasswordStatement(): ?SetPasswordStatementContext
    {
        return $this->getTypedRuleContext(SetPasswordStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetPassword($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetPassword($this);
        }
    }
}

class SetAutocommitContext extends SetStatementContext
{
    public function __construct(SetStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function setAutocommitStatement(): ?SetAutocommitStatementContext
    {
        return $this->getTypedRuleContext(SetAutocommitStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetAutocommit($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetAutocommit($this);
        }
    }
}

class SetNewValueInsideTriggerContext extends SetStatementContext
{
    public function __construct(SetStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    /**
     * @return array<FullIdContext>|FullIdContext|null
     */
    public function fullId(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FullIdContext::class);
        }

        return $this->getTypedRuleContext(FullIdContext::class, $index);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function VAR_ASSIGN(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::VAR_ASSIGN);
        }

        return $this->getToken(MySqlParser::VAR_ASSIGN, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetNewValueInsideTrigger($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetNewValueInsideTrigger($this);
        }
    }
}

class SetVariableContext extends SetStatementContext
{
    public function __construct(SetStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    /**
     * @return array<VariableClauseContext>|VariableClauseContext|null
     */
    public function variableClause(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(VariableClauseContext::class);
        }

        return $this->getTypedRuleContext(VariableClauseContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function VAR_ASSIGN(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::VAR_ASSIGN);
        }

        return $this->getToken(MySqlParser::VAR_ASSIGN, $index);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ON(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ON);
        }

        return $this->getToken(MySqlParser::ON, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSetVariable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSetVariable($this);
        }
    }
}

class ShowStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_showStatement;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class ShowOpenTablesContext extends ShowStatementContext
{
    /**
     * @var Token|null $schemaFormat
     */
    public $schemaFormat;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function OPEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPEN, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function showFilter(): ?ShowFilterContext
    {
        return $this->getTypedRuleContext(ShowFilterContext::class, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowOpenTables($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowOpenTables($this);
        }
    }
}

class ShowGlobalInfoContext extends ShowStatementContext
{
    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function showGlobalInfoClause(): ?ShowGlobalInfoClauseContext
    {
        return $this->getTypedRuleContext(ShowGlobalInfoClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowGlobalInfo($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowGlobalInfo($this);
        }
    }
}

class ShowCreateFullIdObjectContext extends ShowStatementContext
{
    /**
     * @var Token|null $namedEntity
     */
    public $namedEntity;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function EVENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENT, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function PROCEDURE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCEDURE, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function TRIGGER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRIGGER, 0);
    }

    public function VIEW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VIEW, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowCreateFullIdObject($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowCreateFullIdObject($this);
        }
    }
}

class ShowCreateUserContext extends ShowStatementContext
{
    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowCreateUser($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowCreateUser($this);
        }
    }
}

class ShowErrorsContext extends ShowStatementContext
{
    /**
     * @var Token|null $errorFormat
     */
    public $errorFormat;

    /**
     * @var DecimalLiteralContext|null $offset
     */
    public $offset;

    /**
     * @var DecimalLiteralContext|null $rowCount
     */
    public $rowCount;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function ERRORS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ERRORS, 0);
    }

    public function WARNINGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WARNINGS, 0);
    }

    public function LIMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIMIT, 0);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowErrors($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowErrors($this);
        }
    }
}

class ShowCountErrorsContext extends ShowStatementContext
{
    /**
     * @var Token|null $errorFormat
     */
    public $errorFormat;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function COUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COUNT, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function STAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STAR, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function ERRORS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ERRORS, 0);
    }

    public function WARNINGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WARNINGS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowCountErrors($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowCountErrors($this);
        }
    }
}

class ShowObjectFilterContext extends ShowStatementContext
{
    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function showCommonEntity(): ?ShowCommonEntityContext
    {
        return $this->getTypedRuleContext(ShowCommonEntityContext::class, 0);
    }

    public function showFilter(): ?ShowFilterContext
    {
        return $this->getTypedRuleContext(ShowFilterContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowObjectFilter($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowObjectFilter($this);
        }
    }
}

class ShowCreateDbContext extends ShowStatementContext
{
    /**
     * @var Token|null $schemaFormat
     */
    public $schemaFormat;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function CREATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function DATABASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASE, 0);
    }

    public function SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA, 0);
    }

    public function ifNotExists(): ?IfNotExistsContext
    {
        return $this->getTypedRuleContext(IfNotExistsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowCreateDb($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowCreateDb($this);
        }
    }
}

class ShowEngineContext extends ShowStatementContext
{
    /**
     * @var Token|null $engineOption
     */
    public $engineOption;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function engineName(): ?EngineNameContext
    {
        return $this->getTypedRuleContext(EngineNameContext::class, 0);
    }

    public function STATUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATUS, 0);
    }

    public function MUTEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MUTEX, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowEngine($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowEngine($this);
        }
    }
}

class ShowSchemaFilterContext extends ShowStatementContext
{
    /**
     * @var Token|null $schemaFormat
     */
    public $schemaFormat;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function showSchemaEntity(): ?ShowSchemaEntityContext
    {
        return $this->getTypedRuleContext(ShowSchemaEntityContext::class, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function showFilter(): ?ShowFilterContext
    {
        return $this->getTypedRuleContext(ShowFilterContext::class, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowSchemaFilter($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowSchemaFilter($this);
        }
    }
}

class ShowIndexesContext extends ShowStatementContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    /**
     * @var Token|null $tableFormat
     */
    public $tableFormat;

    /**
     * @var Token|null $schemaFormat
     */
    public $schemaFormat;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function INDEXES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEXES, 0);
    }

    public function KEYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEYS, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function FROM(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::FROM);
        }

        return $this->getToken(MySqlParser::FROM, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function IN(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::IN);
        }

        return $this->getToken(MySqlParser::IN, $index);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowIndexes($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowIndexes($this);
        }
    }
}

class ShowLogEventsContext extends ShowStatementContext
{
    /**
     * @var Token|null $logFormat
     */
    public $logFormat;

    /**
     * @var Token|null $filename
     */
    public $filename;

    /**
     * @var DecimalLiteralContext|null $fromPosition
     */
    public $fromPosition;

    /**
     * @var DecimalLiteralContext|null $offset
     */
    public $offset;

    /**
     * @var DecimalLiteralContext|null $rowCount
     */
    public $rowCount;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function EVENTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENTS, 0);
    }

    public function BINLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINLOG, 0);
    }

    public function RELAYLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAYLOG, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function LIMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIMIT, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowLogEvents($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowLogEvents($this);
        }
    }
}

class ShowMasterLogsContext extends ShowStatementContext
{
    /**
     * @var Token|null $logFormat
     */
    public $logFormat;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function LOGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGS, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function MASTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowMasterLogs($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowMasterLogs($this);
        }
    }
}

class ShowGrantsContext extends ShowStatementContext
{
    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function GRANTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GRANTS, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowGrants($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowGrants($this);
        }
    }
}

class ShowSlaveStatusContext extends ShowStatementContext
{
    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function SLAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLAVE, 0);
    }

    public function STATUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATUS, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function CHANNEL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHANNEL, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowSlaveStatus($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowSlaveStatus($this);
        }
    }
}

class ShowRoutineContext extends ShowStatementContext
{
    /**
     * @var Token|null $routine
     */
    public $routine;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function CODE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CODE, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function PROCEDURE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCEDURE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowRoutine($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowRoutine($this);
        }
    }
}

class ShowProfileContext extends ShowStatementContext
{
    /**
     * @var DecimalLiteralContext|null $queryCount
     */
    public $queryCount;

    /**
     * @var DecimalLiteralContext|null $offset
     */
    public $offset;

    /**
     * @var DecimalLiteralContext|null $rowCount
     */
    public $rowCount;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function PROFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROFILE, 0);
    }

    /**
     * @return array<ShowProfileTypeContext>|ShowProfileTypeContext|null
     */
    public function showProfileType(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ShowProfileTypeContext::class);
        }

        return $this->getTypedRuleContext(ShowProfileTypeContext::class, $index);
    }

    public function LIMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIMIT, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function QUERY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUERY, 0);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowProfile($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowProfile($this);
        }
    }
}

class ShowColumnsContext extends ShowStatementContext
{
    /**
     * @var Token|null $columnsFormat
     */
    public $columnsFormat;

    /**
     * @var Token|null $tableFormat
     */
    public $tableFormat;

    /**
     * @var Token|null $schemaFormat
     */
    public $schemaFormat;

    public function __construct(ShowStatementContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function SHOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function COLUMNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMNS, 0);
    }

    public function FIELDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIELDS, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function FROM(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::FROM);
        }

        return $this->getToken(MySqlParser::FROM, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function IN(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::IN);
        }

        return $this->getToken(MySqlParser::IN, $index);
    }

    public function FULL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FULL, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function showFilter(): ?ShowFilterContext
    {
        return $this->getTypedRuleContext(ShowFilterContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowColumns($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowColumns($this);
        }
    }
}

class VariableClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_variableClause;
    }

    public function LOCAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL_ID, 0);
    }

    public function GLOBAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GLOBAL_ID, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function GLOBAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GLOBAL, 0);
    }

    public function SESSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SESSION, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function AT_SIGN(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::AT_SIGN);
        }

        return $this->getToken(MySqlParser::AT_SIGN, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterVariableClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitVariableClause($this);
        }
    }
}

class ShowCommonEntityContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_showCommonEntity;
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function COLLATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATION, 0);
    }

    public function DATABASES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASES, 0);
    }

    public function SCHEMAS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMAS, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function STATUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATUS, 0);
    }

    public function PROCEDURE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCEDURE, 0);
    }

    public function VARIABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARIABLES, 0);
    }

    public function GLOBAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GLOBAL, 0);
    }

    public function SESSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SESSION, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowCommonEntity($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowCommonEntity($this);
        }
    }
}

class ShowFilterContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_showFilter;
    }

    public function LIKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIKE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function WHERE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHERE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowFilter($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowFilter($this);
        }
    }
}

class ShowGlobalInfoClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_showGlobalInfoClause;
    }

    public function ENGINES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINES, 0);
    }

    public function STORAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STORAGE, 0);
    }

    public function MASTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER, 0);
    }

    public function STATUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATUS, 0);
    }

    public function PLUGINS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUGINS, 0);
    }

    public function PRIVILEGES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIVILEGES, 0);
    }

    public function PROCESSLIST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCESSLIST, 0);
    }

    public function FULL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FULL, 0);
    }

    public function PROFILES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROFILES, 0);
    }

    public function SLAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLAVE, 0);
    }

    public function HOSTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOSTS, 0);
    }

    public function AUTHORS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTHORS, 0);
    }

    public function CONTRIBUTORS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONTRIBUTORS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowGlobalInfoClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowGlobalInfoClause($this);
        }
    }
}

class ShowSchemaEntityContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_showSchemaEntity;
    }

    public function EVENTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENTS, 0);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function STATUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATUS, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function FULL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FULL, 0);
    }

    public function TRIGGERS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRIGGERS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowSchemaEntity($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowSchemaEntity($this);
        }
    }
}

class ShowProfileTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_showProfileType;
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function BLOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BLOCK, 0);
    }

    public function IO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IO, 0);
    }

    public function CONTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONTEXT, 0);
    }

    public function SWITCHES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SWITCHES, 0);
    }

    public function CPU(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CPU, 0);
    }

    public function IPC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IPC, 0);
    }

    public function MEMORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEMORY, 0);
    }

    public function PAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PAGE, 0);
    }

    public function FAULTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FAULTS, 0);
    }

    public function SOURCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOURCE, 0);
    }

    public function SWAPS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SWAPS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShowProfileType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShowProfileType($this);
        }
    }
}

class BinlogStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_binlogStatement;
    }

    public function BINLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINLOG, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBinlogStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBinlogStatement($this);
        }
    }
}

class CacheIndexStatementContext extends ParserRuleContext
{
    /**
     * @var UidContext|null $schema
     */
    public $schema;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_cacheIndexStatement;
    }

    public function CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CACHE, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    /**
     * @return array<TableIndexesContext>|TableIndexesContext|null
     */
    public function tableIndexes(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableIndexesContext::class);
        }

        return $this->getTypedRuleContext(TableIndexesContext::class, $index);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCacheIndexStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCacheIndexStatement($this);
        }
    }
}

class FlushStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $flushFormat
     */
    public $flushFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_flushStatement;
    }

    public function FLUSH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLUSH, 0);
    }

    /**
     * @return array<FlushOptionContext>|FlushOptionContext|null
     */
    public function flushOption(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FlushOptionContext::class);
        }

        return $this->getTypedRuleContext(FlushOptionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function NO_WRITE_TO_BINLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NO_WRITE_TO_BINLOG, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFlushStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFlushStatement($this);
        }
    }
}

class KillStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $connectionFormat
     */
    public $connectionFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_killStatement;
    }

    public function KILL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KILL, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function CONNECTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECTION, 0);
    }

    public function QUERY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUERY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterKillStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitKillStatement($this);
        }
    }
}

class LoadIndexIntoCacheContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_loadIndexIntoCache;
    }

    public function LOAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOAD, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function INTO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTO, 0);
    }

    public function CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CACHE, 0);
    }

    /**
     * @return array<LoadedTableIndexesContext>|LoadedTableIndexesContext|null
     */
    public function loadedTableIndexes(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(LoadedTableIndexesContext::class);
        }

        return $this->getTypedRuleContext(LoadedTableIndexesContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLoadIndexIntoCache($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLoadIndexIntoCache($this);
        }
    }
}

class ResetStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_resetStatement;
    }

    public function RESET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESET, 0);
    }

    public function QUERY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUERY, 0);
    }

    public function CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CACHE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterResetStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitResetStatement($this);
        }
    }
}

class ShutdownStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_shutdownStatement;
    }

    public function SHUTDOWN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHUTDOWN, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterShutdownStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitShutdownStatement($this);
        }
    }
}

class TableIndexesContext extends ParserRuleContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableIndexes;
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function uidList(): ?UidListContext
    {
        return $this->getTypedRuleContext(UidListContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableIndexes($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableIndexes($this);
        }
    }
}

class FlushOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_flushOption;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class TableFlushOptionContext extends FlushOptionContext
{
    public function __construct(FlushOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function tables(): ?TablesContext
    {
        return $this->getTypedRuleContext(TablesContext::class, 0);
    }

    public function flushTableOption(): ?FlushTableOptionContext
    {
        return $this->getTypedRuleContext(FlushTableOptionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableFlushOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableFlushOption($this);
        }
    }
}

class ChannelFlushOptionContext extends FlushOptionContext
{
    public function __construct(FlushOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function RELAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY, 0);
    }

    public function LOGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGS, 0);
    }

    public function channelOption(): ?ChannelOptionContext
    {
        return $this->getTypedRuleContext(ChannelOptionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterChannelFlushOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitChannelFlushOption($this);
        }
    }
}

class SimpleFlushOptionContext extends FlushOptionContext
{
    public function __construct(FlushOptionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DES_KEY_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DES_KEY_FILE, 0);
    }

    public function HOSTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOSTS, 0);
    }

    public function LOGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGS, 0);
    }

    public function OPTIMIZER_COSTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIMIZER_COSTS, 0);
    }

    public function PRIVILEGES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIVILEGES, 0);
    }

    public function QUERY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUERY, 0);
    }

    public function CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CACHE, 0);
    }

    public function STATUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATUS, 0);
    }

    public function USER_RESOURCES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER_RESOURCES, 0);
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCK, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function ERROR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ERROR, 0);
    }

    public function GENERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GENERAL, 0);
    }

    public function RELAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY, 0);
    }

    public function SLOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLOW, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleFlushOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleFlushOption($this);
        }
    }
}

class FlushTableOptionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_flushTableOption;
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    public function READ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::READ, 0);
    }

    public function LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCK, 0);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function EXPORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXPORT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFlushTableOption($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFlushTableOption($this);
        }
    }
}

class LoadedTableIndexesContext extends ParserRuleContext
{
    /**
     * @var Token|null $indexFormat
     */
    public $indexFormat;

    /**
     * @var UidListContext|null $partitionList
     */
    public $partitionList;

    /**
     * @var UidListContext|null $indexList
     */
    public $indexList;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_loadedTableIndexes;
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    public function IGNORE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE, 0);
    }

    public function LEAVES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEAVES, 0);
    }

    /**
     * @return array<UidListContext>|UidListContext|null
     */
    public function uidList(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidListContext::class);
        }

        return $this->getTypedRuleContext(UidListContext::class, $index);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEX, 0);
    }

    public function KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLoadedTableIndexes($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLoadedTableIndexes($this);
        }
    }
}

class SimpleDescribeStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $command
     */
    public $command;

    /**
     * @var Token|null $pattern
     */
    public $pattern;

    /**
     * @var UidContext|null $column
     */
    public $column;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_simpleDescribeStatement;
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function EXPLAIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXPLAIN, 0);
    }

    public function DESCRIBE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DESCRIBE, 0);
    }

    public function DESC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DESC, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleDescribeStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleDescribeStatement($this);
        }
    }
}

class FullDescribeStatementContext extends ParserRuleContext
{
    /**
     * @var Token|null $command
     */
    public $command;

    /**
     * @var Token|null $formatType
     */
    public $formatType;

    /**
     * @var Token|null $formatValue
     */
    public $formatValue;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_fullDescribeStatement;
    }

    public function describeObjectClause(): ?DescribeObjectClauseContext
    {
        return $this->getTypedRuleContext(DescribeObjectClauseContext::class, 0);
    }

    public function EXPLAIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXPLAIN, 0);
    }

    public function DESCRIBE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DESCRIBE, 0);
    }

    public function DESC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DESC, 0);
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function EXTENDED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTENDED, 0);
    }

    public function PARTITIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITIONS, 0);
    }

    public function FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FORMAT, 0);
    }

    public function TRADITIONAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRADITIONAL, 0);
    }

    public function JSON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFullDescribeStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFullDescribeStatement($this);
        }
    }
}

class HelpStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_helpStatement;
    }

    public function HELP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HELP, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHelpStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHelpStatement($this);
        }
    }
}

class UseStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_useStatement;
    }

    public function USE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USE, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUseStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUseStatement($this);
        }
    }
}

class SignalStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_signalStatement;
    }

    public function SIGNAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SIGNAL, 0);
    }

    public function ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ID, 0);
    }

    public function REVERSE_QUOTE_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REVERSE_QUOTE_ID, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    /**
     * @return array<SignalConditionInformationContext>|SignalConditionInformationContext|null
     */
    public function signalConditionInformation(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SignalConditionInformationContext::class);
        }

        return $this->getTypedRuleContext(SignalConditionInformationContext::class, $index);
    }

    public function SQLSTATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQLSTATE, 0);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSignalStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSignalStatement($this);
        }
    }
}

class ResignalStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_resignalStatement;
    }

    public function RESIGNAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESIGNAL, 0);
    }

    public function ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ID, 0);
    }

    public function REVERSE_QUOTE_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REVERSE_QUOTE_ID, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    /**
     * @return array<SignalConditionInformationContext>|SignalConditionInformationContext|null
     */
    public function signalConditionInformation(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(SignalConditionInformationContext::class);
        }

        return $this->getTypedRuleContext(SignalConditionInformationContext::class, $index);
    }

    public function SQLSTATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQLSTATE, 0);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterResignalStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitResignalStatement($this);
        }
    }
}

class SignalConditionInformationContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_signalConditionInformation;
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function CLASS_ORIGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLASS_ORIGIN, 0);
    }

    public function SUBCLASS_ORIGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBCLASS_ORIGIN, 0);
    }

    public function MESSAGE_TEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MESSAGE_TEXT, 0);
    }

    public function MYSQL_ERRNO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MYSQL_ERRNO, 0);
    }

    public function CONSTRAINT_CATALOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_CATALOG, 0);
    }

    public function CONSTRAINT_SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_SCHEMA, 0);
    }

    public function CONSTRAINT_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_NAME, 0);
    }

    public function CATALOG_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CATALOG_NAME, 0);
    }

    public function SCHEMA_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA_NAME, 0);
    }

    public function TABLE_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE_NAME, 0);
    }

    public function COLUMN_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN_NAME, 0);
    }

    public function CURSOR_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURSOR_NAME, 0);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function DECIMAL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECIMAL_LITERAL, 0);
    }

    public function mysqlVariable(): ?MysqlVariableContext
    {
        return $this->getTypedRuleContext(MysqlVariableContext::class, 0);
    }

    public function simpleId(): ?SimpleIdContext
    {
        return $this->getTypedRuleContext(SimpleIdContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSignalConditionInformation($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSignalConditionInformation($this);
        }
    }
}

class WithStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_withStatement;
    }

    public function WITH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITH, 0);
    }

    /**
     * @return array<CommonTableExpressionsContext>|CommonTableExpressionsContext|null
     */
    public function commonTableExpressions(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CommonTableExpressionsContext::class);
        }

        return $this->getTypedRuleContext(CommonTableExpressionsContext::class, $index);
    }

    public function RECURSIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RECURSIVE, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWithStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWithStatement($this);
        }
    }
}

class TableStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableStatement;
    }

    public function TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE, 0);
    }

    public function tableName(): ?TableNameContext
    {
        return $this->getTypedRuleContext(TableNameContext::class, 0);
    }

    public function orderByClause(): ?OrderByClauseContext
    {
        return $this->getTypedRuleContext(OrderByClauseContext::class, 0);
    }

    public function limitClause(): ?LimitClauseContext
    {
        return $this->getTypedRuleContext(LimitClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableStatement($this);
        }
    }
}

class DiagnosticsStatementContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_diagnosticsStatement;
    }

    public function GET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GET, 0);
    }

    public function DIAGNOSTICS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIAGNOSTICS, 0);
    }

    public function CURRENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT, 0);
    }

    public function STACKED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STACKED, 0);
    }

    /**
     * @return array<VariableClauseContext>|VariableClauseContext|null
     */
    public function variableClause(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(VariableClauseContext::class);
        }

        return $this->getTypedRuleContext(VariableClauseContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function EQUAL_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::EQUAL_SYMBOL);
        }

        return $this->getToken(MySqlParser::EQUAL_SYMBOL, $index);
    }

    public function CONDITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONDITION, 0);
    }

    /**
     * @return array<DiagnosticsConditionInformationNameContext>|DiagnosticsConditionInformationNameContext|null
     */
    public function diagnosticsConditionInformationName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DiagnosticsConditionInformationNameContext::class);
        }

        return $this->getTypedRuleContext(DiagnosticsConditionInformationNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function NUMBER(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::NUMBER);
        }

        return $this->getToken(MySqlParser::NUMBER, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ROW_COUNT(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ROW_COUNT);
        }

        return $this->getToken(MySqlParser::ROW_COUNT, $index);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDiagnosticsStatement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDiagnosticsStatement($this);
        }
    }
}

class DiagnosticsConditionInformationNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_diagnosticsConditionInformationName;
    }

    public function CLASS_ORIGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLASS_ORIGIN, 0);
    }

    public function SUBCLASS_ORIGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBCLASS_ORIGIN, 0);
    }

    public function RETURNED_SQLSTATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RETURNED_SQLSTATE, 0);
    }

    public function MESSAGE_TEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MESSAGE_TEXT, 0);
    }

    public function MYSQL_ERRNO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MYSQL_ERRNO, 0);
    }

    public function CONSTRAINT_CATALOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_CATALOG, 0);
    }

    public function CONSTRAINT_SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_SCHEMA, 0);
    }

    public function CONSTRAINT_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_NAME, 0);
    }

    public function CATALOG_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CATALOG_NAME, 0);
    }

    public function SCHEMA_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA_NAME, 0);
    }

    public function TABLE_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE_NAME, 0);
    }

    public function COLUMN_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN_NAME, 0);
    }

    public function CURSOR_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURSOR_NAME, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDiagnosticsConditionInformationName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDiagnosticsConditionInformationName($this);
        }
    }
}

class DescribeObjectClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_describeObjectClause;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class DescribeStatementsContext extends DescribeObjectClauseContext
{
    public function __construct(DescribeObjectClauseContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function deleteStatement(): ?DeleteStatementContext
    {
        return $this->getTypedRuleContext(DeleteStatementContext::class, 0);
    }

    public function insertStatement(): ?InsertStatementContext
    {
        return $this->getTypedRuleContext(InsertStatementContext::class, 0);
    }

    public function replaceStatement(): ?ReplaceStatementContext
    {
        return $this->getTypedRuleContext(ReplaceStatementContext::class, 0);
    }

    public function updateStatement(): ?UpdateStatementContext
    {
        return $this->getTypedRuleContext(UpdateStatementContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDescribeStatements($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDescribeStatements($this);
        }
    }
}

class DescribeConnectionContext extends DescribeObjectClauseContext
{
    public function __construct(DescribeObjectClauseContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function CONNECTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECTION, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDescribeConnection($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDescribeConnection($this);
        }
    }
}

class FullIdContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_fullId;
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    public function DOT_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOT_ID, 0);
    }

    public function DOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFullId($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFullId($this);
        }
    }
}

class TableNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tableName;
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTableName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTableName($this);
        }
    }
}

class RoleNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_roleName;
    }

    public function userName(): ?UserNameContext
    {
        return $this->getTypedRuleContext(UserNameContext::class, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRoleName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRoleName($this);
        }
    }
}

class FullColumnNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_fullColumnName;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    /**
     * @return array<DottedIdContext>|DottedIdContext|null
     */
    public function dottedId(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DottedIdContext::class);
        }

        return $this->getTypedRuleContext(DottedIdContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFullColumnName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFullColumnName($this);
        }
    }
}

class IndexColumnNameContext extends ParserRuleContext
{
    /**
     * @var Token|null $sortType
     */
    public $sortType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_indexColumnName;
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function ASC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASC, 0);
    }

    public function DESC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DESC, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIndexColumnName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIndexColumnName($this);
        }
    }
}

class SimpleUserNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_simpleUserName;
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ID, 0);
    }

    public function ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADMIN, 0);
    }

    public function keywordsCanBeId(): ?KeywordsCanBeIdContext
    {
        return $this->getTypedRuleContext(KeywordsCanBeIdContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleUserName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleUserName($this);
        }
    }
}

class HostNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_hostName;
    }

    public function LOCAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL_ID, 0);
    }

    public function HOST_IP_ADDRESS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOST_IP_ADDRESS, 0);
    }

    public function AT_SIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AT_SIGN, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHostName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHostName($this);
        }
    }
}

class UserNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_userName;
    }

    public function simpleUserName(): ?SimpleUserNameContext
    {
        return $this->getTypedRuleContext(SimpleUserNameContext::class, 0);
    }

    public function hostName(): ?HostNameContext
    {
        return $this->getTypedRuleContext(HostNameContext::class, 0);
    }

    public function currentUserExpression(): ?CurrentUserExpressionContext
    {
        return $this->getTypedRuleContext(CurrentUserExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUserName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUserName($this);
        }
    }
}

class MysqlVariableContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_mysqlVariable;
    }

    public function LOCAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL_ID, 0);
    }

    public function GLOBAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GLOBAL_ID, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMysqlVariable($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMysqlVariable($this);
        }
    }
}

class CharsetNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_charsetName;
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function charsetNameBase(): ?CharsetNameBaseContext
    {
        return $this->getTypedRuleContext(CharsetNameBaseContext::class, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function CHARSET_REVERSE_QOUTE_STRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARSET_REVERSE_QOUTE_STRING, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCharsetName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCharsetName($this);
        }
    }
}

class CollationNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_collationName;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCollationName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCollationName($this);
        }
    }
}

class EngineNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_engineName;
    }

    public function engineNameBase(): ?EngineNameBaseContext
    {
        return $this->getTypedRuleContext(EngineNameBaseContext::class, 0);
    }

    public function ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ID, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterEngineName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitEngineName($this);
        }
    }
}

class EngineNameBaseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_engineNameBase;
    }

    public function ARCHIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ARCHIVE, 0);
    }

    public function BLACKHOLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BLACKHOLE, 0);
    }

    public function CONNECT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECT, 0);
    }

    public function CSV(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CSV, 0);
    }

    public function FEDERATED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FEDERATED, 0);
    }

    public function INNODB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INNODB, 0);
    }

    public function MEMORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEMORY, 0);
    }

    public function MRG_MYISAM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MRG_MYISAM, 0);
    }

    public function MYISAM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MYISAM, 0);
    }

    public function NDB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NDB, 0);
    }

    public function NDBCLUSTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NDBCLUSTER, 0);
    }

    public function PERFORMANCE_SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PERFORMANCE_SCHEMA, 0);
    }

    public function TOKUDB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TOKUDB, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterEngineNameBase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitEngineNameBase($this);
        }
    }
}

class UuidSetContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_uuidSet;
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function MINUS(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::MINUS);
        }

        return $this->getToken(MySqlParser::MINUS, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COLON_SYMB(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COLON_SYMB);
        }

        return $this->getToken(MySqlParser::COLON_SYMB, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUuidSet($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUuidSet($this);
        }
    }
}

class XidContext extends ParserRuleContext
{
    /**
     * @var XuidStringIdContext|null $globalTableUid
     */
    public $globalTableUid;

    /**
     * @var XuidStringIdContext|null $qualifier
     */
    public $qualifier;

    /**
     * @var DecimalLiteralContext|null $idFormat
     */
    public $idFormat;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_xid;
    }

    /**
     * @return array<XuidStringIdContext>|XuidStringIdContext|null
     */
    public function xuidStringId(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(XuidStringIdContext::class);
        }

        return $this->getTypedRuleContext(XuidStringIdContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterXid($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitXid($this);
        }
    }
}

class XuidStringIdContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_xuidStringId;
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function BIT_STRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_STRING, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function HEXADECIMAL_LITERAL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::HEXADECIMAL_LITERAL);
        }

        return $this->getToken(MySqlParser::HEXADECIMAL_LITERAL, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterXuidStringId($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitXuidStringId($this);
        }
    }
}

class AuthPluginContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_authPlugin;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAuthPlugin($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAuthPlugin($this);
        }
    }
}

class UidContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_uid;
    }

    public function simpleId(): ?SimpleIdContext
    {
        return $this->getTypedRuleContext(SimpleIdContext::class, 0);
    }

    public function CHARSET_REVERSE_QOUTE_STRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARSET_REVERSE_QOUTE_STRING, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUid($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUid($this);
        }
    }
}

class SimpleIdContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_simpleId;
    }

    public function ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ID, 0);
    }

    public function charsetNameBase(): ?CharsetNameBaseContext
    {
        return $this->getTypedRuleContext(CharsetNameBaseContext::class, 0);
    }

    public function transactionLevelBase(): ?TransactionLevelBaseContext
    {
        return $this->getTypedRuleContext(TransactionLevelBaseContext::class, 0);
    }

    public function engineNameBase(): ?EngineNameBaseContext
    {
        return $this->getTypedRuleContext(EngineNameBaseContext::class, 0);
    }

    public function privilegesBase(): ?PrivilegesBaseContext
    {
        return $this->getTypedRuleContext(PrivilegesBaseContext::class, 0);
    }

    public function intervalTypeBase(): ?IntervalTypeBaseContext
    {
        return $this->getTypedRuleContext(IntervalTypeBaseContext::class, 0);
    }

    public function dataTypeBase(): ?DataTypeBaseContext
    {
        return $this->getTypedRuleContext(DataTypeBaseContext::class, 0);
    }

    public function keywordsCanBeId(): ?KeywordsCanBeIdContext
    {
        return $this->getTypedRuleContext(KeywordsCanBeIdContext::class, 0);
    }

    public function scalarFunctionName(): ?ScalarFunctionNameContext
    {
        return $this->getTypedRuleContext(ScalarFunctionNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleId($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleId($this);
        }
    }
}

class DottedIdContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dottedId;
    }

    public function DOT_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOT_ID, 0);
    }

    public function DOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOT, 0);
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDottedId($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDottedId($this);
        }
    }
}

class DecimalLiteralContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_decimalLiteral;
    }

    public function DECIMAL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECIMAL_LITERAL, 0);
    }

    public function ZERO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ZERO_DECIMAL, 0);
    }

    public function ONE_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE_DECIMAL, 0);
    }

    public function TWO_DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TWO_DECIMAL, 0);
    }

    public function REAL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REAL_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDecimalLiteral($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDecimalLiteral($this);
        }
    }
}

class FileSizeLiteralContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_fileSizeLiteral;
    }

    public function FILESIZE_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FILESIZE_LITERAL, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFileSizeLiteral($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFileSizeLiteral($this);
        }
    }
}

class StringLiteralContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_stringLiteral;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STRING_LITERAL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STRING_LITERAL);
        }

        return $this->getToken(MySqlParser::STRING_LITERAL, $index);
    }

    public function START_NATIONAL_STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::START_NATIONAL_STRING_LITERAL, 0);
    }

    public function STRING_CHARSET_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_CHARSET_NAME, 0);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStringLiteral($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStringLiteral($this);
        }
    }
}

class BooleanLiteralContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_booleanLiteral;
    }

    public function TRUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRUE, 0);
    }

    public function FALSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FALSE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBooleanLiteral($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBooleanLiteral($this);
        }
    }
}

class HexadecimalLiteralContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_hexadecimalLiteral;
    }

    public function HEXADECIMAL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HEXADECIMAL_LITERAL, 0);
    }

    public function STRING_CHARSET_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_CHARSET_NAME, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterHexadecimalLiteral($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitHexadecimalLiteral($this);
        }
    }
}

class NullNotnullContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_nullNotnull;
    }

    public function NULL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULL_LITERAL, 0);
    }

    public function NULL_SPEC_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULL_SPEC_LITERAL, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNullNotnull($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNullNotnull($this);
        }
    }
}

class ConstantContext extends ParserRuleContext
{
    /**
     * @var Token|null $nullLiteral
     */
    public $nullLiteral;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_constant;
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function MINUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUS, 0);
    }

    public function hexadecimalLiteral(): ?HexadecimalLiteralContext
    {
        return $this->getTypedRuleContext(HexadecimalLiteralContext::class, 0);
    }

    public function booleanLiteral(): ?BooleanLiteralContext
    {
        return $this->getTypedRuleContext(BooleanLiteralContext::class, 0);
    }

    public function REAL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REAL_LITERAL, 0);
    }

    public function BIT_STRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_STRING, 0);
    }

    public function NULL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULL_LITERAL, 0);
    }

    public function NULL_SPEC_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULL_SPEC_LITERAL, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterConstant($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitConstant($this);
        }
    }
}

class DataTypeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dataType;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SpatialDataTypeContext extends DataTypeContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function GEOMETRYCOLLECTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRYCOLLECTION, 0);
    }

    public function GEOMCOLLECTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMCOLLECTION, 0);
    }

    public function LINESTRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINESTRING, 0);
    }

    public function MULTILINESTRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTILINESTRING, 0);
    }

    public function MULTIPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTIPOINT, 0);
    }

    public function MULTIPOLYGON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTIPOLYGON, 0);
    }

    public function POINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POINT, 0);
    }

    public function POLYGON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POLYGON, 0);
    }

    public function JSON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON, 0);
    }

    public function GEOMETRY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRY, 0);
    }

    public function SRID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SRID, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSpatialDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSpatialDataType($this);
        }
    }
}

class LongVarbinaryDataTypeContext extends DataTypeContext
{
    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LONG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LONG, 0);
    }

    public function VARBINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARBINARY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLongVarbinaryDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLongVarbinaryDataType($this);
        }
    }
}

class CollectionDataTypeContext extends DataTypeContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function collectionOptions(): ?CollectionOptionsContext
    {
        return $this->getTypedRuleContext(CollectionOptionsContext::class, 0);
    }

    public function ENUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENUM, 0);
    }

    public function SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function charSet(): ?CharSetContext
    {
        return $this->getTypedRuleContext(CharSetContext::class, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCollectionDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCollectionDataType($this);
        }
    }
}

class NationalVaryingStringDataTypeContext extends DataTypeContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function NATIONAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NATIONAL, 0);
    }

    public function VARYING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARYING, 0);
    }

    public function CHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAR, 0);
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    public function lengthOneDimension(): ?LengthOneDimensionContext
    {
        return $this->getTypedRuleContext(LengthOneDimensionContext::class, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNationalVaryingStringDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNationalVaryingStringDataType($this);
        }
    }
}

class DimensionDataTypeContext extends DataTypeContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function TINYINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TINYINT, 0);
    }

    public function SMALLINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SMALLINT, 0);
    }

    public function MEDIUMINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEDIUMINT, 0);
    }

    public function INT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INT, 0);
    }

    public function INTEGER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTEGER, 0);
    }

    public function BIGINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIGINT, 0);
    }

    public function MIDDLEINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MIDDLEINT, 0);
    }

    public function INT1(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INT1, 0);
    }

    public function INT2(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INT2, 0);
    }

    public function INT3(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INT3, 0);
    }

    public function INT4(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INT4, 0);
    }

    public function INT8(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INT8, 0);
    }

    public function lengthOneDimension(): ?LengthOneDimensionContext
    {
        return $this->getTypedRuleContext(LengthOneDimensionContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function SIGNED(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::SIGNED);
        }

        return $this->getToken(MySqlParser::SIGNED, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function UNSIGNED(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::UNSIGNED);
        }

        return $this->getToken(MySqlParser::UNSIGNED, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function ZEROFILL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::ZEROFILL);
        }

        return $this->getToken(MySqlParser::ZEROFILL, $index);
    }

    public function REAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REAL, 0);
    }

    public function lengthTwoDimension(): ?LengthTwoDimensionContext
    {
        return $this->getTypedRuleContext(LengthTwoDimensionContext::class, 0);
    }

    public function DOUBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOUBLE, 0);
    }

    public function PRECISION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRECISION, 0);
    }

    public function DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECIMAL, 0);
    }

    public function DEC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEC, 0);
    }

    public function FIXED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIXED, 0);
    }

    public function NUMERIC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NUMERIC, 0);
    }

    public function FLOAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLOAT, 0);
    }

    public function FLOAT4(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLOAT4, 0);
    }

    public function FLOAT8(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLOAT8, 0);
    }

    public function lengthTwoOptionalDimension(): ?LengthTwoOptionalDimensionContext
    {
        return $this->getTypedRuleContext(LengthTwoOptionalDimensionContext::class, 0);
    }

    public function BIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT, 0);
    }

    public function TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIME, 0);
    }

    public function TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIMESTAMP, 0);
    }

    public function DATETIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATETIME, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function VARBINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARBINARY, 0);
    }

    public function BLOB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BLOB, 0);
    }

    public function YEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::YEAR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDimensionDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDimensionDataType($this);
        }
    }
}

class StringDataTypeContext extends DataTypeContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAR, 0);
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    public function VARCHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARCHAR, 0);
    }

    public function TINYTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TINYTEXT, 0);
    }

    public function TEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEXT, 0);
    }

    public function MEDIUMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEDIUMTEXT, 0);
    }

    public function LONGTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LONGTEXT, 0);
    }

    public function NCHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NCHAR, 0);
    }

    public function NVARCHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NVARCHAR, 0);
    }

    public function LONG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LONG, 0);
    }

    public function VARYING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARYING, 0);
    }

    public function lengthOneDimension(): ?LengthOneDimensionContext
    {
        return $this->getTypedRuleContext(LengthOneDimensionContext::class, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function BINARY(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::BINARY);
        }

        return $this->getToken(MySqlParser::BINARY, $index);
    }

    public function charSet(): ?CharSetContext
    {
        return $this->getTypedRuleContext(CharSetContext::class, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterStringDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitStringDataType($this);
        }
    }
}

class LongVarcharDataTypeContext extends DataTypeContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LONG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LONG, 0);
    }

    public function VARCHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARCHAR, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function charSet(): ?CharSetContext
    {
        return $this->getTypedRuleContext(CharSetContext::class, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLongVarcharDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLongVarcharDataType($this);
        }
    }
}

class NationalStringDataTypeContext extends DataTypeContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function NATIONAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NATIONAL, 0);
    }

    public function VARCHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARCHAR, 0);
    }

    public function CHARACTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER, 0);
    }

    public function CHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAR, 0);
    }

    public function lengthOneDimension(): ?LengthOneDimensionContext
    {
        return $this->getTypedRuleContext(LengthOneDimensionContext::class, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function NCHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NCHAR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNationalStringDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNationalStringDataType($this);
        }
    }
}

class SimpleDataTypeContext extends DataTypeContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(DataTypeContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATE, 0);
    }

    public function TINYBLOB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TINYBLOB, 0);
    }

    public function MEDIUMBLOB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEDIUMBLOB, 0);
    }

    public function LONGBLOB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LONGBLOB, 0);
    }

    public function BOOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BOOL, 0);
    }

    public function BOOLEAN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BOOLEAN, 0);
    }

    public function SERIAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERIAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleDataType($this);
        }
    }
}

class CollectionOptionsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_collectionOptions;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STRING_LITERAL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STRING_LITERAL);
        }

        return $this->getToken(MySqlParser::STRING_LITERAL, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCollectionOptions($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCollectionOptions($this);
        }
    }
}

class ConvertedDataTypeContext extends ParserRuleContext
{
    /**
     * @var Token|null $typeName
     */
    public $typeName;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_convertedDataType;
    }

    public function CHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAR, 0);
    }

    public function SIGNED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SIGNED, 0);
    }

    public function UNSIGNED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNSIGNED, 0);
    }

    public function ARRAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ARRAY, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function NCHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NCHAR, 0);
    }

    public function FLOAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLOAT, 0);
    }

    public function DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATE, 0);
    }

    public function DATETIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATETIME, 0);
    }

    public function TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIME, 0);
    }

    public function YEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::YEAR, 0);
    }

    public function JSON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON, 0);
    }

    public function INT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INT, 0);
    }

    public function INTEGER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTEGER, 0);
    }

    public function DOUBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DOUBLE, 0);
    }

    public function DECIMAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECIMAL, 0);
    }

    public function DEC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEC, 0);
    }

    public function lengthOneDimension(): ?LengthOneDimensionContext
    {
        return $this->getTypedRuleContext(LengthOneDimensionContext::class, 0);
    }

    public function charSet(): ?CharSetContext
    {
        return $this->getTypedRuleContext(CharSetContext::class, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function lengthTwoOptionalDimension(): ?LengthTwoOptionalDimensionContext
    {
        return $this->getTypedRuleContext(LengthTwoOptionalDimensionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterConvertedDataType($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitConvertedDataType($this);
        }
    }
}

class LengthOneDimensionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_lengthOneDimension;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLengthOneDimension($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLengthOneDimension($this);
        }
    }
}

class LengthTwoDimensionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_lengthTwoDimension;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLengthTwoDimension($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLengthTwoDimension($this);
        }
    }
}

class LengthTwoOptionalDimensionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_lengthTwoOptionalDimension;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLengthTwoOptionalDimension($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLengthTwoOptionalDimension($this);
        }
    }
}

class UidListContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_uidList;
    }

    /**
     * @return array<UidContext>|UidContext|null
     */
    public function uid(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(UidContext::class);
        }

        return $this->getTypedRuleContext(UidContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUidList($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUidList($this);
        }
    }
}

class FullColumnNameListContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_fullColumnNameList;
    }

    /**
     * @return array<FullColumnNameContext>|FullColumnNameContext|null
     */
    public function fullColumnName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FullColumnNameContext::class);
        }

        return $this->getTypedRuleContext(FullColumnNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFullColumnNameList($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFullColumnNameList($this);
        }
    }
}

class TablesContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_tables;
    }

    /**
     * @return array<TableNameContext>|TableNameContext|null
     */
    public function tableName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(TableNameContext::class);
        }

        return $this->getTypedRuleContext(TableNameContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTables($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTables($this);
        }
    }
}

class IndexColumnNamesContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_indexColumnNames;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<IndexColumnNameContext>|IndexColumnNameContext|null
     */
    public function indexColumnName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(IndexColumnNameContext::class);
        }

        return $this->getTypedRuleContext(IndexColumnNameContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIndexColumnNames($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIndexColumnNames($this);
        }
    }
}

class ExpressionsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_expressions;
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterExpressions($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitExpressions($this);
        }
    }
}

class ExpressionsWithDefaultsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_expressionsWithDefaults;
    }

    /**
     * @return array<ExpressionOrDefaultContext>|ExpressionOrDefaultContext|null
     */
    public function expressionOrDefault(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionOrDefaultContext::class);
        }

        return $this->getTypedRuleContext(ExpressionOrDefaultContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterExpressionsWithDefaults($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitExpressionsWithDefaults($this);
        }
    }
}

class ConstantsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_constants;
    }

    /**
     * @return array<ConstantContext>|ConstantContext|null
     */
    public function constant(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ConstantContext::class);
        }

        return $this->getTypedRuleContext(ConstantContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterConstants($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitConstants($this);
        }
    }
}

class SimpleStringsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_simpleStrings;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function STRING_LITERAL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::STRING_LITERAL);
        }

        return $this->getToken(MySqlParser::STRING_LITERAL, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleStrings($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleStrings($this);
        }
    }
}

class UserVariablesContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_userVariables;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LOCAL_ID(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LOCAL_ID);
        }

        return $this->getToken(MySqlParser::LOCAL_ID, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUserVariables($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUserVariables($this);
        }
    }
}

class DefaultValueContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_defaultValue;
    }

    public function NULL_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULL_LITERAL, 0);
    }

    public function CAST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CAST, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function convertedDataType(): ?ConvertedDataTypeContext
    {
        return $this->getTypedRuleContext(ConvertedDataTypeContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function constant(): ?ConstantContext
    {
        return $this->getTypedRuleContext(ConstantContext::class, 0);
    }

    public function unaryOperator(): ?UnaryOperatorContext
    {
        return $this->getTypedRuleContext(UnaryOperatorContext::class, 0);
    }

    /**
     * @return array<CurrentTimestampContext>|CurrentTimestampContext|null
     */
    public function currentTimestamp(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CurrentTimestampContext::class);
        }

        return $this->getTypedRuleContext(CurrentTimestampContext::class, $index);
    }

    public function ON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ON, 0);
    }

    public function UPDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATE, 0);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDefaultValue($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDefaultValue($this);
        }
    }
}

class CurrentTimestampContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_currentTimestamp;
    }

    public function NOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOW, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function CURRENT_TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_TIMESTAMP, 0);
    }

    public function LOCALTIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCALTIME, 0);
    }

    public function LOCALTIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCALTIMESTAMP, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCurrentTimestamp($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCurrentTimestamp($this);
        }
    }
}

class ExpressionOrDefaultContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_expressionOrDefault;
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterExpressionOrDefault($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitExpressionOrDefault($this);
        }
    }
}

class IfExistsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_ifExists;
    }

    public function IF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IF, 0);
    }

    public function EXISTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXISTS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIfExists($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIfExists($this);
        }
    }
}

class IfNotExistsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_ifNotExists;
    }

    public function IF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IF, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function EXISTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXISTS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIfNotExists($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIfNotExists($this);
        }
    }
}

class OrReplaceContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_orReplace;
    }

    public function OR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OR, 0);
    }

    public function REPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLACE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterOrReplace($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitOrReplace($this);
        }
    }
}

class WaitNowaitClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_waitNowaitClause;
    }

    public function WAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WAIT, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function NOWAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOWAIT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWaitNowaitClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWaitNowaitClause($this);
        }
    }
}

class FunctionCallContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_functionCall;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SpecificFunctionCallContext extends FunctionCallContext
{
    public function __construct(FunctionCallContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function specificFunction(): ?SpecificFunctionContext
    {
        return $this->getTypedRuleContext(SpecificFunctionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSpecificFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSpecificFunctionCall($this);
        }
    }
}

class PasswordFunctionCallContext extends FunctionCallContext
{
    public function __construct(FunctionCallContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function passwordFunctionClause(): ?PasswordFunctionClauseContext
    {
        return $this->getTypedRuleContext(PasswordFunctionClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPasswordFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPasswordFunctionCall($this);
        }
    }
}

class UdfFunctionCallContext extends FunctionCallContext
{
    public function __construct(FunctionCallContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function fullId(): ?FullIdContext
    {
        return $this->getTypedRuleContext(FullIdContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function functionArgs(): ?FunctionArgsContext
    {
        return $this->getTypedRuleContext(FunctionArgsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUdfFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUdfFunctionCall($this);
        }
    }
}

class NonAggregateFunctionCallContext extends FunctionCallContext
{
    public function __construct(FunctionCallContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function nonAggregateWindowedFunction(): ?NonAggregateWindowedFunctionContext
    {
        return $this->getTypedRuleContext(NonAggregateWindowedFunctionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNonAggregateFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNonAggregateFunctionCall($this);
        }
    }
}

class AggregateFunctionCallContext extends FunctionCallContext
{
    public function __construct(FunctionCallContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function aggregateWindowedFunction(): ?AggregateWindowedFunctionContext
    {
        return $this->getTypedRuleContext(AggregateWindowedFunctionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAggregateFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAggregateFunctionCall($this);
        }
    }
}

class ScalarFunctionCallContext extends FunctionCallContext
{
    public function __construct(FunctionCallContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function scalarFunctionName(): ?ScalarFunctionNameContext
    {
        return $this->getTypedRuleContext(ScalarFunctionNameContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function functionArgs(): ?FunctionArgsContext
    {
        return $this->getTypedRuleContext(FunctionArgsContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterScalarFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitScalarFunctionCall($this);
        }
    }
}

class SpecificFunctionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_specificFunction;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class PositionFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var StringLiteralContext|null $positionString
     */
    public $positionString;

    /**
     * @var ExpressionContext|null $positionExpression
     */
    public $positionExpression;

    /**
     * @var StringLiteralContext|null $inString
     */
    public $inString;

    /**
     * @var ExpressionContext|null $inExpression
     */
    public $inExpression;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function POSITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POSITION, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<StringLiteralContext>|StringLiteralContext|null
     */
    public function stringLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(StringLiteralContext::class);
        }

        return $this->getTypedRuleContext(StringLiteralContext::class, $index);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPositionFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPositionFunctionCall($this);
        }
    }
}

class TrimFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var Token|null $positioinForm
     */
    public $positioinForm;

    /**
     * @var StringLiteralContext|null $sourceString
     */
    public $sourceString;

    /**
     * @var ExpressionContext|null $sourceExpression
     */
    public $sourceExpression;

    /**
     * @var StringLiteralContext|null $fromString
     */
    public $fromString;

    /**
     * @var ExpressionContext|null $fromExpression
     */
    public $fromExpression;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function TRIM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRIM, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function BOTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BOTH, 0);
    }

    public function LEADING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEADING, 0);
    }

    public function TRAILING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRAILING, 0);
    }

    /**
     * @return array<StringLiteralContext>|StringLiteralContext|null
     */
    public function stringLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(StringLiteralContext::class);
        }

        return $this->getTypedRuleContext(StringLiteralContext::class, $index);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTrimFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTrimFunctionCall($this);
        }
    }
}

class JsonValueFunctionCallContext extends SpecificFunctionContext
{
    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function JSON_VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_VALUE, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function RETURNING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RETURNING, 0);
    }

    public function convertedDataType(): ?ConvertedDataTypeContext
    {
        return $this->getTypedRuleContext(ConvertedDataTypeContext::class, 0);
    }

    public function jsonOnEmpty(): ?JsonOnEmptyContext
    {
        return $this->getTypedRuleContext(JsonOnEmptyContext::class, 0);
    }

    public function jsonOnError(): ?JsonOnErrorContext
    {
        return $this->getTypedRuleContext(JsonOnErrorContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonValueFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonValueFunctionCall($this);
        }
    }
}

class CaseFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var FunctionArgContext|null $elseArg
     */
    public $elseArg;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CASE, 0);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    /**
     * @return array<CaseFuncAlternativeContext>|CaseFuncAlternativeContext|null
     */
    public function caseFuncAlternative(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CaseFuncAlternativeContext::class);
        }

        return $this->getTypedRuleContext(CaseFuncAlternativeContext::class, $index);
    }

    public function ELSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ELSE, 0);
    }

    public function functionArg(): ?FunctionArgContext
    {
        return $this->getTypedRuleContext(FunctionArgContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCaseFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCaseFunctionCall($this);
        }
    }
}

class ExtractFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var StringLiteralContext|null $sourceString
     */
    public $sourceString;

    /**
     * @var ExpressionContext|null $sourceExpression
     */
    public $sourceExpression;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function EXTRACT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTRACT, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function intervalType(): ?IntervalTypeContext
    {
        return $this->getTypedRuleContext(IntervalTypeContext::class, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterExtractFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitExtractFunctionCall($this);
        }
    }
}

class DataTypeFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var Token|null $separator
     */
    public $separator;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CONVERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONVERT, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function convertedDataType(): ?ConvertedDataTypeContext
    {
        return $this->getTypedRuleContext(ConvertedDataTypeContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function USING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USING, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function CAST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CAST, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDataTypeFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDataTypeFunctionCall($this);
        }
    }
}

class ValuesFunctionCallContext extends SpecificFunctionContext
{
    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function VALUES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUES, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function fullColumnName(): ?FullColumnNameContext
    {
        return $this->getTypedRuleContext(FullColumnNameContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterValuesFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitValuesFunctionCall($this);
        }
    }
}

class CaseExpressionFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var FunctionArgContext|null $elseArg
     */
    public $elseArg;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CASE, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    /**
     * @return array<CaseFuncAlternativeContext>|CaseFuncAlternativeContext|null
     */
    public function caseFuncAlternative(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(CaseFuncAlternativeContext::class);
        }

        return $this->getTypedRuleContext(CaseFuncAlternativeContext::class, $index);
    }

    public function ELSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ELSE, 0);
    }

    public function functionArg(): ?FunctionArgContext
    {
        return $this->getTypedRuleContext(FunctionArgContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCaseExpressionFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCaseExpressionFunctionCall($this);
        }
    }
}

class CurrentUserContext extends SpecificFunctionContext
{
    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function currentUserExpression(): ?CurrentUserExpressionContext
    {
        return $this->getTypedRuleContext(CurrentUserExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCurrentUser($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCurrentUser($this);
        }
    }
}

class SimpleFunctionCallContext extends SpecificFunctionContext
{
    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CURRENT_DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_DATE, 0);
    }

    public function CURRENT_TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_TIME, 0);
    }

    public function CURRENT_TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_TIMESTAMP, 0);
    }

    public function LOCALTIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCALTIME, 0);
    }

    public function UTC_TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTC_TIMESTAMP, 0);
    }

    public function SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSimpleFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSimpleFunctionCall($this);
        }
    }
}

class CharFunctionCallContext extends SpecificFunctionContext
{
    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function CHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAR, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function functionArgs(): ?FunctionArgsContext
    {
        return $this->getTypedRuleContext(FunctionArgsContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function USING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USING, 0);
    }

    public function charsetName(): ?CharsetNameContext
    {
        return $this->getTypedRuleContext(CharsetNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCharFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCharFunctionCall($this);
        }
    }
}

class WeightFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var Token|null $stringFormat
     */
    public $stringFormat;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function WEIGHT_STRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WEIGHT_STRING, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LR_BRACKET);
        }

        return $this->getToken(MySqlParser::LR_BRACKET, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function RR_BRACKET(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::RR_BRACKET);
        }

        return $this->getToken(MySqlParser::RR_BRACKET, $index);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function AS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AS, 0);
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function levelsInWeightString(): ?LevelsInWeightStringContext
    {
        return $this->getTypedRuleContext(LevelsInWeightStringContext::class, 0);
    }

    public function CHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAR, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWeightFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWeightFunctionCall($this);
        }
    }
}

class GetFormatFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var Token|null $datetimeFormat
     */
    public $datetimeFormat;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function GET_FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GET_FORMAT, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function COMMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMA, 0);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATE, 0);
    }

    public function TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIME, 0);
    }

    public function DATETIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATETIME, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterGetFormatFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitGetFormatFunctionCall($this);
        }
    }
}

class SubstrFunctionCallContext extends SpecificFunctionContext
{
    /**
     * @var StringLiteralContext|null $sourceString
     */
    public $sourceString;

    /**
     * @var ExpressionContext|null $sourceExpression
     */
    public $sourceExpression;

    /**
     * @var DecimalLiteralContext|null $fromDecimal
     */
    public $fromDecimal;

    /**
     * @var ExpressionContext|null $fromExpression
     */
    public $fromExpression;

    /**
     * @var DecimalLiteralContext|null $forDecimal
     */
    public $forDecimal;

    /**
     * @var ExpressionContext|null $forExpression
     */
    public $forExpression;

    public function __construct(SpecificFunctionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function FROM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function SUBSTR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBSTR, 0);
    }

    public function SUBSTRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBSTRING, 0);
    }

    public function stringLiteral(): ?StringLiteralContext
    {
        return $this->getTypedRuleContext(StringLiteralContext::class, 0);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function FOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOR, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSubstrFunctionCall($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSubstrFunctionCall($this);
        }
    }
}

class CaseFuncAlternativeContext extends ParserRuleContext
{
    /**
     * @var FunctionArgContext|null $condition
     */
    public $condition;

    /**
     * @var FunctionArgContext|null $consequent
     */
    public $consequent;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_caseFuncAlternative;
    }

    public function WHEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WHEN, 0);
    }

    public function THEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::THEN, 0);
    }

    /**
     * @return array<FunctionArgContext>|FunctionArgContext|null
     */
    public function functionArg(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FunctionArgContext::class);
        }

        return $this->getTypedRuleContext(FunctionArgContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCaseFuncAlternative($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCaseFuncAlternative($this);
        }
    }
}

class LevelsInWeightStringContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_levelsInWeightString;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class LevelWeightRangeContext extends LevelsInWeightStringContext
{
    /**
     * @var DecimalLiteralContext|null $firstLevel
     */
    public $firstLevel;

    /**
     * @var DecimalLiteralContext|null $lastLevel
     */
    public $lastLevel;

    public function __construct(LevelsInWeightStringContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LEVEL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEVEL, 0);
    }

    public function MINUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUS, 0);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLevelWeightRange($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLevelWeightRange($this);
        }
    }
}

class LevelWeightListContext extends LevelsInWeightStringContext
{
    public function __construct(LevelsInWeightStringContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LEVEL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEVEL, 0);
    }

    /**
     * @return array<LevelInWeightListElementContext>|LevelInWeightListElementContext|null
     */
    public function levelInWeightListElement(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(LevelInWeightListElementContext::class);
        }

        return $this->getTypedRuleContext(LevelInWeightListElementContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLevelWeightList($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLevelWeightList($this);
        }
    }
}

class LevelInWeightListElementContext extends ParserRuleContext
{
    /**
     * @var Token|null $orderType
     */
    public $orderType;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_levelInWeightListElement;
    }

    public function decimalLiteral(): ?DecimalLiteralContext
    {
        return $this->getTypedRuleContext(DecimalLiteralContext::class, 0);
    }

    public function ASC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASC, 0);
    }

    public function DESC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DESC, 0);
    }

    public function REVERSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REVERSE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLevelInWeightListElement($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLevelInWeightListElement($this);
        }
    }
}

class AggregateWindowedFunctionContext extends ParserRuleContext
{
    /**
     * @var Token|null $aggregator
     */
    public $aggregator;

    /**
     * @var Token|null $starArg
     */
    public $starArg;

    /**
     * @var Token|null $separator
     */
    public $separator;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_aggregateWindowedFunction;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function functionArg(): ?FunctionArgContext
    {
        return $this->getTypedRuleContext(FunctionArgContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function AVG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AVG, 0);
    }

    public function MAX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX, 0);
    }

    public function MIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MIN, 0);
    }

    public function SUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUM, 0);
    }

    public function overClause(): ?OverClauseContext
    {
        return $this->getTypedRuleContext(OverClauseContext::class, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function DISTINCT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISTINCT, 0);
    }

    public function COUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COUNT, 0);
    }

    public function functionArgs(): ?FunctionArgsContext
    {
        return $this->getTypedRuleContext(FunctionArgsContext::class, 0);
    }

    public function STAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STAR, 0);
    }

    public function BIT_AND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_AND, 0);
    }

    public function BIT_OR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_OR, 0);
    }

    public function BIT_XOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_XOR, 0);
    }

    public function STD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STD, 0);
    }

    public function STDDEV(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STDDEV, 0);
    }

    public function STDDEV_POP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STDDEV_POP, 0);
    }

    public function STDDEV_SAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STDDEV_SAMP, 0);
    }

    public function VAR_POP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VAR_POP, 0);
    }

    public function VAR_SAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VAR_SAMP, 0);
    }

    public function VARIANCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARIANCE, 0);
    }

    public function GROUP_CONCAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP_CONCAT, 0);
    }

    public function ORDER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ORDER, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    /**
     * @return array<OrderByExpressionContext>|OrderByExpressionContext|null
     */
    public function orderByExpression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(OrderByExpressionContext::class);
        }

        return $this->getTypedRuleContext(OrderByExpressionContext::class, $index);
    }

    public function SEPARATOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SEPARATOR, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAggregateWindowedFunction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAggregateWindowedFunction($this);
        }
    }
}

class NonAggregateWindowedFunctionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_nonAggregateWindowedFunction;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function overClause(): ?OverClauseContext
    {
        return $this->getTypedRuleContext(OverClauseContext::class, 0);
    }

    public function LAG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAG, 0);
    }

    public function LEAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEAD, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    /**
     * @return array<DecimalLiteralContext>|DecimalLiteralContext|null
     */
    public function decimalLiteral(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(DecimalLiteralContext::class);
        }

        return $this->getTypedRuleContext(DecimalLiteralContext::class, $index);
    }

    public function FIRST_VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST_VALUE, 0);
    }

    public function LAST_VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAST_VALUE, 0);
    }

    public function CUME_DIST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CUME_DIST, 0);
    }

    public function DENSE_RANK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DENSE_RANK, 0);
    }

    public function PERCENT_RANK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PERCENT_RANK, 0);
    }

    public function RANK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RANK, 0);
    }

    public function ROW_NUMBER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW_NUMBER, 0);
    }

    public function NTH_VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NTH_VALUE, 0);
    }

    public function NTILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NTILE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNonAggregateWindowedFunction($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNonAggregateWindowedFunction($this);
        }
    }
}

class OverClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_overClause;
    }

    public function OVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OVER, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function windowSpec(): ?WindowSpecContext
    {
        return $this->getTypedRuleContext(WindowSpecContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function windowName(): ?WindowNameContext
    {
        return $this->getTypedRuleContext(WindowNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterOverClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitOverClause($this);
        }
    }
}

class WindowSpecContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_windowSpec;
    }

    public function windowName(): ?WindowNameContext
    {
        return $this->getTypedRuleContext(WindowNameContext::class, 0);
    }

    public function partitionClause(): ?PartitionClauseContext
    {
        return $this->getTypedRuleContext(PartitionClauseContext::class, 0);
    }

    public function orderByClause(): ?OrderByClauseContext
    {
        return $this->getTypedRuleContext(OrderByClauseContext::class, 0);
    }

    public function frameClause(): ?FrameClauseContext
    {
        return $this->getTypedRuleContext(FrameClauseContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWindowSpec($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWindowSpec($this);
        }
    }
}

class WindowNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_windowName;
    }

    public function uid(): ?UidContext
    {
        return $this->getTypedRuleContext(UidContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterWindowName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitWindowName($this);
        }
    }
}

class FrameClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_frameClause;
    }

    public function frameUnits(): ?FrameUnitsContext
    {
        return $this->getTypedRuleContext(FrameUnitsContext::class, 0);
    }

    public function frameExtent(): ?FrameExtentContext
    {
        return $this->getTypedRuleContext(FrameExtentContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFrameClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFrameClause($this);
        }
    }
}

class FrameUnitsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_frameUnits;
    }

    public function ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROWS, 0);
    }

    public function RANGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RANGE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFrameUnits($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFrameUnits($this);
        }
    }
}

class FrameExtentContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_frameExtent;
    }

    public function frameRange(): ?FrameRangeContext
    {
        return $this->getTypedRuleContext(FrameRangeContext::class, 0);
    }

    public function frameBetween(): ?FrameBetweenContext
    {
        return $this->getTypedRuleContext(FrameBetweenContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFrameExtent($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFrameExtent($this);
        }
    }
}

class FrameBetweenContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_frameBetween;
    }

    public function BETWEEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BETWEEN, 0);
    }

    /**
     * @return array<FrameRangeContext>|FrameRangeContext|null
     */
    public function frameRange(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FrameRangeContext::class);
        }

        return $this->getTypedRuleContext(FrameRangeContext::class, $index);
    }

    public function AND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AND, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFrameBetween($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFrameBetween($this);
        }
    }
}

class FrameRangeContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_frameRange;
    }

    public function CURRENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT, 0);
    }

    public function ROW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW, 0);
    }

    public function UNBOUNDED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNBOUNDED, 0);
    }

    public function PRECEDING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRECEDING, 0);
    }

    public function FOLLOWING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOLLOWING, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFrameRange($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFrameRange($this);
        }
    }
}

class PartitionClauseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_partitionClause;
    }

    public function PARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITION, 0);
    }

    public function BY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BY, 0);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPartitionClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPartitionClause($this);
        }
    }
}

class ScalarFunctionNameContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_scalarFunctionName;
    }

    public function functionNameBase(): ?FunctionNameBaseContext
    {
        return $this->getTypedRuleContext(FunctionNameBaseContext::class, 0);
    }

    public function ASCII(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASCII, 0);
    }

    public function CURDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURDATE, 0);
    }

    public function CURRENT_DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_DATE, 0);
    }

    public function CURRENT_TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_TIME, 0);
    }

    public function CURRENT_TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_TIMESTAMP, 0);
    }

    public function CURTIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURTIME, 0);
    }

    public function DATE_ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATE_ADD, 0);
    }

    public function DATE_SUB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATE_SUB, 0);
    }

    public function IF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IF, 0);
    }

    public function INSERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSERT, 0);
    }

    public function LOCALTIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCALTIME, 0);
    }

    public function LOCALTIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCALTIMESTAMP, 0);
    }

    public function MID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MID, 0);
    }

    public function NOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOW, 0);
    }

    public function REPEAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPEAT, 0);
    }

    public function REPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLACE, 0);
    }

    public function SUBSTR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBSTR, 0);
    }

    public function SUBSTRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBSTRING, 0);
    }

    public function SYSDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SYSDATE, 0);
    }

    public function TRIM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRIM, 0);
    }

    public function UTC_DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTC_DATE, 0);
    }

    public function UTC_TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTC_TIME, 0);
    }

    public function UTC_TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTC_TIMESTAMP, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterScalarFunctionName($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitScalarFunctionName($this);
        }
    }
}

class PasswordFunctionClauseContext extends ParserRuleContext
{
    /**
     * @var Token|null $functionName
     */
    public $functionName;

    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_passwordFunctionClause;
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function functionArg(): ?FunctionArgContext
    {
        return $this->getTypedRuleContext(FunctionArgContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function OLD_PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OLD_PASSWORD, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPasswordFunctionClause($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPasswordFunctionClause($this);
        }
    }
}

class FunctionArgsContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_functionArgs;
    }

    /**
     * @return array<ConstantContext>|ConstantContext|null
     */
    public function constant(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ConstantContext::class);
        }

        return $this->getTypedRuleContext(ConstantContext::class, $index);
    }

    /**
     * @return array<FullColumnNameContext>|FullColumnNameContext|null
     */
    public function fullColumnName(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FullColumnNameContext::class);
        }

        return $this->getTypedRuleContext(FullColumnNameContext::class, $index);
    }

    /**
     * @return array<FunctionCallContext>|FunctionCallContext|null
     */
    public function functionCall(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(FunctionCallContext::class);
        }

        return $this->getTypedRuleContext(FunctionCallContext::class, $index);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFunctionArgs($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFunctionArgs($this);
        }
    }
}

class FunctionArgContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_functionArg;
    }

    public function constant(): ?ConstantContext
    {
        return $this->getTypedRuleContext(ConstantContext::class, 0);
    }

    public function fullColumnName(): ?FullColumnNameContext
    {
        return $this->getTypedRuleContext(FullColumnNameContext::class, 0);
    }

    public function functionCall(): ?FunctionCallContext
    {
        return $this->getTypedRuleContext(FunctionCallContext::class, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFunctionArg($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFunctionArg($this);
        }
    }
}

class ExpressionContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_expression;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class IsExpressionContext extends ExpressionContext
{
    /**
     * @var Token|null $testValue
     */
    public $testValue;

    public function __construct(ExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function predicate(): ?PredicateContext
    {
        return $this->getTypedRuleContext(PredicateContext::class, 0);
    }

    public function IS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IS, 0);
    }

    public function TRUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRUE, 0);
    }

    public function FALSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FALSE, 0);
    }

    public function UNKNOWN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNKNOWN, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIsExpression($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIsExpression($this);
        }
    }
}

class NotExpressionContext extends ExpressionContext
{
    /**
     * @var Token|null $notOperator
     */
    public $notOperator;

    public function __construct(ExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function EXCLAMATION_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCLAMATION_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNotExpression($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNotExpression($this);
        }
    }
}

class LogicalExpressionContext extends ExpressionContext
{
    public function __construct(ExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    public function logicalOperator(): ?LogicalOperatorContext
    {
        return $this->getTypedRuleContext(LogicalOperatorContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLogicalExpression($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLogicalExpression($this);
        }
    }
}

class PredicateExpressionContext extends ExpressionContext
{
    public function __construct(ExpressionContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function predicate(): ?PredicateContext
    {
        return $this->getTypedRuleContext(PredicateContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPredicateExpression($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPredicateExpression($this);
        }
    }
}

class PredicateContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_predicate;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class SoundsLikePredicateContext extends PredicateContext
{
    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<PredicateContext>|PredicateContext|null
     */
    public function predicate(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PredicateContext::class);
        }

        return $this->getTypedRuleContext(PredicateContext::class, $index);
    }

    public function SOUNDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOUNDS, 0);
    }

    public function LIKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIKE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSoundsLikePredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSoundsLikePredicate($this);
        }
    }
}

class ExpressionAtomPredicateContext extends PredicateContext
{
    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function expressionAtom(): ?ExpressionAtomContext
    {
        return $this->getTypedRuleContext(ExpressionAtomContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterExpressionAtomPredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitExpressionAtomPredicate($this);
        }
    }
}

class SubqueryComparisonPredicateContext extends PredicateContext
{
    /**
     * @var Token|null $quantifier
     */
    public $quantifier;

    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function predicate(): ?PredicateContext
    {
        return $this->getTypedRuleContext(PredicateContext::class, 0);
    }

    public function comparisonOperator(): ?ComparisonOperatorContext
    {
        return $this->getTypedRuleContext(ComparisonOperatorContext::class, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function ALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALL, 0);
    }

    public function ANY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ANY, 0);
    }

    public function SOME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOME, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSubqueryComparisonPredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSubqueryComparisonPredicate($this);
        }
    }
}

class JsonMemberOfPredicateContext extends PredicateContext
{
    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<PredicateContext>|PredicateContext|null
     */
    public function predicate(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PredicateContext::class);
        }

        return $this->getTypedRuleContext(PredicateContext::class, $index);
    }

    public function MEMBER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEMBER, 0);
    }

    public function OF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OF, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonMemberOfPredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonMemberOfPredicate($this);
        }
    }
}

class BinaryComparisonPredicateContext extends PredicateContext
{
    /**
     * @var PredicateContext|null $left
     */
    public $left;

    /**
     * @var PredicateContext|null $right
     */
    public $right;

    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function comparisonOperator(): ?ComparisonOperatorContext
    {
        return $this->getTypedRuleContext(ComparisonOperatorContext::class, 0);
    }

    /**
     * @return array<PredicateContext>|PredicateContext|null
     */
    public function predicate(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PredicateContext::class);
        }

        return $this->getTypedRuleContext(PredicateContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBinaryComparisonPredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBinaryComparisonPredicate($this);
        }
    }
}

class InPredicateContext extends PredicateContext
{
    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function predicate(): ?PredicateContext
    {
        return $this->getTypedRuleContext(PredicateContext::class, 0);
    }

    public function IN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IN, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function expressions(): ?ExpressionsContext
    {
        return $this->getTypedRuleContext(ExpressionsContext::class, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterInPredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitInPredicate($this);
        }
    }
}

class BetweenPredicateContext extends PredicateContext
{
    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<PredicateContext>|PredicateContext|null
     */
    public function predicate(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PredicateContext::class);
        }

        return $this->getTypedRuleContext(PredicateContext::class, $index);
    }

    public function BETWEEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BETWEEN, 0);
    }

    public function AND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AND, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBetweenPredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBetweenPredicate($this);
        }
    }
}

class IsNullPredicateContext extends PredicateContext
{
    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function predicate(): ?PredicateContext
    {
        return $this->getTypedRuleContext(PredicateContext::class, 0);
    }

    public function IS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IS, 0);
    }

    public function nullNotnull(): ?NullNotnullContext
    {
        return $this->getTypedRuleContext(NullNotnullContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIsNullPredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIsNullPredicate($this);
        }
    }
}

class LikePredicateContext extends PredicateContext
{
    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<PredicateContext>|PredicateContext|null
     */
    public function predicate(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PredicateContext::class);
        }

        return $this->getTypedRuleContext(PredicateContext::class, $index);
    }

    public function LIKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIKE, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function ESCAPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ESCAPE, 0);
    }

    public function STRING_LITERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING_LITERAL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLikePredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLikePredicate($this);
        }
    }
}

class RegexpPredicateContext extends PredicateContext
{
    /**
     * @var Token|null $regex
     */
    public $regex;

    public function __construct(PredicateContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    /**
     * @return array<PredicateContext>|PredicateContext|null
     */
    public function predicate(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(PredicateContext::class);
        }

        return $this->getTypedRuleContext(PredicateContext::class, $index);
    }

    public function REGEXP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REGEXP, 0);
    }

    public function RLIKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RLIKE, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterRegexpPredicate($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitRegexpPredicate($this);
        }
    }
}

class ExpressionAtomContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_expressionAtom;
    }

    public function copyFrom(ParserRuleContext $context): void
    {
        parent::copyFrom($context);

    }
}

class UnaryExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function unaryOperator(): ?UnaryOperatorContext
    {
        return $this->getTypedRuleContext(UnaryOperatorContext::class, 0);
    }

    public function expressionAtom(): ?ExpressionAtomContext
    {
        return $this->getTypedRuleContext(ExpressionAtomContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUnaryExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUnaryExpressionAtom($this);
        }
    }
}

class CollateExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function expressionAtom(): ?ExpressionAtomContext
    {
        return $this->getTypedRuleContext(ExpressionAtomContext::class, 0);
    }

    public function COLLATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATE, 0);
    }

    public function collationName(): ?CollationNameContext
    {
        return $this->getTypedRuleContext(CollationNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCollateExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCollateExpressionAtom($this);
        }
    }
}

class VariableAssignExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LOCAL_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL_ID, 0);
    }

    public function VAR_ASSIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VAR_ASSIGN, 0);
    }

    public function expressionAtom(): ?ExpressionAtomContext
    {
        return $this->getTypedRuleContext(ExpressionAtomContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterVariableAssignExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitVariableAssignExpressionAtom($this);
        }
    }
}

class MysqlVariableExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function mysqlVariable(): ?MysqlVariableContext
    {
        return $this->getTypedRuleContext(MysqlVariableContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMysqlVariableExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMysqlVariableExpressionAtom($this);
        }
    }
}

class NestedExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNestedExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNestedExpressionAtom($this);
        }
    }
}

class NestedRowExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function ROW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    /**
     * @return array<ExpressionContext>|ExpressionContext|null
     */
    public function expression(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionContext::class);
        }

        return $this->getTypedRuleContext(ExpressionContext::class, $index);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function COMMA(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::COMMA);
        }

        return $this->getToken(MySqlParser::COMMA, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterNestedRowExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitNestedRowExpressionAtom($this);
        }
    }
}

class MathExpressionAtomContext extends ExpressionAtomContext
{
    /**
     * @var ExpressionAtomContext|null $left
     */
    public $left;

    /**
     * @var ExpressionAtomContext|null $right
     */
    public $right;

    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function multOperator(): ?MultOperatorContext
    {
        return $this->getTypedRuleContext(MultOperatorContext::class, 0);
    }

    /**
     * @return array<ExpressionAtomContext>|ExpressionAtomContext|null
     */
    public function expressionAtom(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionAtomContext::class);
        }

        return $this->getTypedRuleContext(ExpressionAtomContext::class, $index);
    }

    public function addOperator(): ?AddOperatorContext
    {
        return $this->getTypedRuleContext(AddOperatorContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMathExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMathExpressionAtom($this);
        }
    }
}

class ExistsExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function EXISTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXISTS, 0);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterExistsExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitExistsExpressionAtom($this);
        }
    }
}

class IntervalExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function INTERVAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTERVAL, 0);
    }

    public function expression(): ?ExpressionContext
    {
        return $this->getTypedRuleContext(ExpressionContext::class, 0);
    }

    public function intervalType(): ?IntervalTypeContext
    {
        return $this->getTypedRuleContext(IntervalTypeContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIntervalExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIntervalExpressionAtom($this);
        }
    }
}

class JsonExpressionAtomContext extends ExpressionAtomContext
{
    /**
     * @var ExpressionAtomContext|null $left
     */
    public $left;

    /**
     * @var ExpressionAtomContext|null $right
     */
    public $right;

    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function jsonOperator(): ?JsonOperatorContext
    {
        return $this->getTypedRuleContext(JsonOperatorContext::class, 0);
    }

    /**
     * @return array<ExpressionAtomContext>|ExpressionAtomContext|null
     */
    public function expressionAtom(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionAtomContext::class);
        }

        return $this->getTypedRuleContext(ExpressionAtomContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonExpressionAtom($this);
        }
    }
}

class SubqueryExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function LR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LR_BRACKET, 0);
    }

    public function selectStatement(): ?SelectStatementContext
    {
        return $this->getTypedRuleContext(SelectStatementContext::class, 0);
    }

    public function RR_BRACKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RR_BRACKET, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterSubqueryExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitSubqueryExpressionAtom($this);
        }
    }
}

class ConstantExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function constant(): ?ConstantContext
    {
        return $this->getTypedRuleContext(ConstantContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterConstantExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitConstantExpressionAtom($this);
        }
    }
}

class FunctionCallExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function functionCall(): ?FunctionCallContext
    {
        return $this->getTypedRuleContext(FunctionCallContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFunctionCallExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFunctionCallExpressionAtom($this);
        }
    }
}

class BinaryExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function expressionAtom(): ?ExpressionAtomContext
    {
        return $this->getTypedRuleContext(ExpressionAtomContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBinaryExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBinaryExpressionAtom($this);
        }
    }
}

class FullColumnNameExpressionAtomContext extends ExpressionAtomContext
{
    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function fullColumnName(): ?FullColumnNameContext
    {
        return $this->getTypedRuleContext(FullColumnNameContext::class, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFullColumnNameExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFullColumnNameExpressionAtom($this);
        }
    }
}

class BitExpressionAtomContext extends ExpressionAtomContext
{
    /**
     * @var ExpressionAtomContext|null $left
     */
    public $left;

    /**
     * @var ExpressionAtomContext|null $right
     */
    public $right;

    public function __construct(ExpressionAtomContext $context)
    {
        parent::__construct($context);

        $this->copyFrom($context);
    }

    public function bitOperator(): ?BitOperatorContext
    {
        return $this->getTypedRuleContext(BitOperatorContext::class, 0);
    }

    /**
     * @return array<ExpressionAtomContext>|ExpressionAtomContext|null
     */
    public function expressionAtom(?int $index = null)
    {
        if ($index === null) {
            return $this->getTypedRuleContexts(ExpressionAtomContext::class);
        }

        return $this->getTypedRuleContext(ExpressionAtomContext::class, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBitExpressionAtom($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBitExpressionAtom($this);
        }
    }
}

class UnaryOperatorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_unaryOperator;
    }

    public function EXCLAMATION_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCLAMATION_SYMBOL, 0);
    }

    public function BIT_NOT_OP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_NOT_OP, 0);
    }

    public function PLUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUS, 0);
    }

    public function MINUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUS, 0);
    }

    public function NOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterUnaryOperator($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitUnaryOperator($this);
        }
    }
}

class ComparisonOperatorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_comparisonOperator;
    }

    public function EQUAL_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUAL_SYMBOL, 0);
    }

    public function GREATER_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GREATER_SYMBOL, 0);
    }

    public function LESS_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LESS_SYMBOL, 0);
    }

    public function EXCLAMATION_SYMBOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCLAMATION_SYMBOL, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterComparisonOperator($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitComparisonOperator($this);
        }
    }
}

class LogicalOperatorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_logicalOperator;
    }

    public function AND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AND, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function BIT_AND_OP(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::BIT_AND_OP);
        }

        return $this->getToken(MySqlParser::BIT_AND_OP, $index);
    }

    public function XOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XOR, 0);
    }

    public function OR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OR, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function BIT_OR_OP(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::BIT_OR_OP);
        }

        return $this->getToken(MySqlParser::BIT_OR_OP, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterLogicalOperator($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitLogicalOperator($this);
        }
    }
}

class BitOperatorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_bitOperator;
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function LESS_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::LESS_SYMBOL);
        }

        return $this->getToken(MySqlParser::LESS_SYMBOL, $index);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function GREATER_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::GREATER_SYMBOL);
        }

        return $this->getToken(MySqlParser::GREATER_SYMBOL, $index);
    }

    public function BIT_AND_OP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_AND_OP, 0);
    }

    public function BIT_XOR_OP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_XOR_OP, 0);
    }

    public function BIT_OR_OP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_OR_OP, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterBitOperator($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitBitOperator($this);
        }
    }
}

class MultOperatorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_multOperator;
    }

    public function STAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STAR, 0);
    }

    public function DIVIDE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIVIDE, 0);
    }

    public function MODULE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MODULE, 0);
    }

    public function DIV(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIV, 0);
    }

    public function MOD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MOD, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterMultOperator($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitMultOperator($this);
        }
    }
}

class AddOperatorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_addOperator;
    }

    public function PLUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUS, 0);
    }

    public function MINUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUS, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterAddOperator($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitAddOperator($this);
        }
    }
}

class JsonOperatorContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_jsonOperator;
    }

    public function MINUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUS, 0);
    }

    /**
     * @return array<TerminalNode>|TerminalNode|null
     */
    public function GREATER_SYMBOL(?int $index = null)
    {
        if ($index === null) {
            return $this->getTokens(MySqlParser::GREATER_SYMBOL);
        }

        return $this->getToken(MySqlParser::GREATER_SYMBOL, $index);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterJsonOperator($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitJsonOperator($this);
        }
    }
}

class CharsetNameBaseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_charsetNameBase;
    }

    public function ARMSCII8(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ARMSCII8, 0);
    }

    public function ASCII(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASCII, 0);
    }

    public function BIG5(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIG5, 0);
    }

    public function BINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINARY, 0);
    }

    public function CP1250(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CP1250, 0);
    }

    public function CP1251(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CP1251, 0);
    }

    public function CP1256(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CP1256, 0);
    }

    public function CP1257(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CP1257, 0);
    }

    public function CP850(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CP850, 0);
    }

    public function CP852(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CP852, 0);
    }

    public function CP866(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CP866, 0);
    }

    public function CP932(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CP932, 0);
    }

    public function DEC8(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEC8, 0);
    }

    public function EUCJPMS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EUCJPMS, 0);
    }

    public function EUCKR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EUCKR, 0);
    }

    public function GB18030(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GB18030, 0);
    }

    public function GB2312(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GB2312, 0);
    }

    public function GBK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GBK, 0);
    }

    public function GEOSTD8(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOSTD8, 0);
    }

    public function GREEK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GREEK, 0);
    }

    public function HEBREW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HEBREW, 0);
    }

    public function HP8(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HP8, 0);
    }

    public function KEYBCS2(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEYBCS2, 0);
    }

    public function KOI8R(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KOI8R, 0);
    }

    public function KOI8U(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KOI8U, 0);
    }

    public function LATIN1(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LATIN1, 0);
    }

    public function LATIN2(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LATIN2, 0);
    }

    public function LATIN5(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LATIN5, 0);
    }

    public function LATIN7(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LATIN7, 0);
    }

    public function MACCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MACCE, 0);
    }

    public function MACROMAN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MACROMAN, 0);
    }

    public function SJIS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SJIS, 0);
    }

    public function SWE7(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SWE7, 0);
    }

    public function TIS620(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIS620, 0);
    }

    public function UCS2(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UCS2, 0);
    }

    public function UJIS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UJIS, 0);
    }

    public function UTF16(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTF16, 0);
    }

    public function UTF16LE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTF16LE, 0);
    }

    public function UTF32(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTF32, 0);
    }

    public function UTF8(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTF8, 0);
    }

    public function UTF8MB3(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTF8MB3, 0);
    }

    public function UTF8MB4(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UTF8MB4, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterCharsetNameBase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitCharsetNameBase($this);
        }
    }
}

class TransactionLevelBaseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_transactionLevelBase;
    }

    public function REPEATABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPEATABLE, 0);
    }

    public function COMMITTED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMITTED, 0);
    }

    public function UNCOMMITTED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNCOMMITTED, 0);
    }

    public function SERIALIZABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERIALIZABLE, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterTransactionLevelBase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitTransactionLevelBase($this);
        }
    }
}

class PrivilegesBaseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_privilegesBase;
    }

    public function TABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLES, 0);
    }

    public function ROUTINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROUTINE, 0);
    }

    public function EXECUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXECUTE, 0);
    }

    public function FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FILE, 0);
    }

    public function PROCESS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCESS, 0);
    }

    public function RELOAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELOAD, 0);
    }

    public function SHUTDOWN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHUTDOWN, 0);
    }

    public function SUPER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUPER, 0);
    }

    public function PRIVILEGES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIVILEGES, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterPrivilegesBase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitPrivilegesBase($this);
        }
    }
}

class IntervalTypeBaseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_intervalTypeBase;
    }

    public function QUARTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUARTER, 0);
    }

    public function MONTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MONTH, 0);
    }

    public function DAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAY, 0);
    }

    public function HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOUR, 0);
    }

    public function MINUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUTE, 0);
    }

    public function WEEK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WEEK, 0);
    }

    public function SECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECOND, 0);
    }

    public function MICROSECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MICROSECOND, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterIntervalTypeBase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitIntervalTypeBase($this);
        }
    }
}

class DataTypeBaseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_dataTypeBase;
    }

    public function DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATE, 0);
    }

    public function TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIME, 0);
    }

    public function TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIMESTAMP, 0);
    }

    public function DATETIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATETIME, 0);
    }

    public function YEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::YEAR, 0);
    }

    public function ENUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENUM, 0);
    }

    public function TEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEXT, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterDataTypeBase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitDataTypeBase($this);
        }
    }
}

class KeywordsCanBeIdContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_keywordsCanBeId;
    }

    public function ACCOUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ACCOUNT, 0);
    }

    public function ACTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ACTION, 0);
    }

    public function ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADMIN, 0);
    }

    public function AFTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AFTER, 0);
    }

    public function AGGREGATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AGGREGATE, 0);
    }

    public function ALGORITHM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ALGORITHM, 0);
    }

    public function ANY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ANY, 0);
    }

    public function ARRAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ARRAY, 0);
    }

    public function AT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AT, 0);
    }

    public function AUDIT_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUDIT_ADMIN, 0);
    }

    public function AUDIT_ABORT_EXEMPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUDIT_ABORT_EXEMPT, 0);
    }

    public function AUTHORS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTHORS, 0);
    }

    public function AUTOCOMMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTOCOMMIT, 0);
    }

    public function AUTOEXTEND_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTOEXTEND_SIZE, 0);
    }

    public function AUTO_INCREMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTO_INCREMENT, 0);
    }

    public function AUTHENTICATION_POLICY_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AUTHENTICATION_POLICY_ADMIN, 0);
    }

    public function AVG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AVG, 0);
    }

    public function AVG_ROW_LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AVG_ROW_LENGTH, 0);
    }

    public function ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ATTRIBUTE, 0);
    }

    public function BACKUP_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BACKUP_ADMIN, 0);
    }

    public function BEGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BEGIN, 0);
    }

    public function BINLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINLOG, 0);
    }

    public function BINLOG_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINLOG_ADMIN, 0);
    }

    public function BINLOG_ENCRYPTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BINLOG_ENCRYPTION_ADMIN, 0);
    }

    public function BIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT, 0);
    }

    public function BIT_AND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_AND, 0);
    }

    public function BIT_OR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_OR, 0);
    }

    public function BIT_XOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_XOR, 0);
    }

    public function BLOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BLOCK, 0);
    }

    public function BOOL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BOOL, 0);
    }

    public function BOOLEAN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BOOLEAN, 0);
    }

    public function BTREE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BTREE, 0);
    }

    public function BUCKETS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BUCKETS, 0);
    }

    public function CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CACHE, 0);
    }

    public function CASCADED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CASCADED, 0);
    }

    public function CHAIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAIN, 0);
    }

    public function CHANGED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHANGED, 0);
    }

    public function CHANNEL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHANNEL, 0);
    }

    public function CHECKSUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHECKSUM, 0);
    }

    public function PAGE_CHECKSUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PAGE_CHECKSUM, 0);
    }

    public function CATALOG_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CATALOG_NAME, 0);
    }

    public function CIPHER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CIPHER, 0);
    }

    public function CLASS_ORIGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLASS_ORIGIN, 0);
    }

    public function CLIENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLIENT, 0);
    }

    public function CLONE_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLONE_ADMIN, 0);
    }

    public function CLOSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLOSE, 0);
    }

    public function CLUSTERING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CLUSTERING, 0);
    }

    public function COALESCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COALESCE, 0);
    }

    public function CODE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CODE, 0);
    }

    public function COLUMNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMNS, 0);
    }

    public function COLUMN_FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN_FORMAT, 0);
    }

    public function COLUMN_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLUMN_NAME, 0);
    }

    public function COMMENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMENT, 0);
    }

    public function COMMIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMMIT, 0);
    }

    public function COMPACT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPACT, 0);
    }

    public function COMPLETION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPLETION, 0);
    }

    public function COMPRESSED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPRESSED, 0);
    }

    public function COMPRESSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPRESSION, 0);
    }

    public function CONCURRENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONCURRENT, 0);
    }

    public function CONDITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONDITION, 0);
    }

    public function CONNECT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECT, 0);
    }

    public function CONNECTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECTION, 0);
    }

    public function CONNECTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECTION_ADMIN, 0);
    }

    public function CONSISTENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSISTENT, 0);
    }

    public function CONSTRAINT_CATALOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_CATALOG, 0);
    }

    public function CONSTRAINT_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_NAME, 0);
    }

    public function CONSTRAINT_SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONSTRAINT_SCHEMA, 0);
    }

    public function CONTAINS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONTAINS, 0);
    }

    public function CONTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONTEXT, 0);
    }

    public function CONTRIBUTORS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONTRIBUTORS, 0);
    }

    public function COPY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COPY, 0);
    }

    public function COUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COUNT, 0);
    }

    public function CPU(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CPU, 0);
    }

    public function CURRENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT, 0);
    }

    public function CURRENT_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURRENT_USER, 0);
    }

    public function CURSOR_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CURSOR_NAME, 0);
    }

    public function DATA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATA, 0);
    }

    public function DATAFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATAFILE, 0);
    }

    public function DEALLOCATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEALLOCATE, 0);
    }

    public function DEFAULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT, 0);
    }

    public function DEFAULT_AUTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFAULT_AUTH, 0);
    }

    public function DEFINER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEFINER, 0);
    }

    public function DELAY_KEY_WRITE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DELAY_KEY_WRITE, 0);
    }

    public function DES_KEY_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DES_KEY_FILE, 0);
    }

    public function DIAGNOSTICS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIAGNOSTICS, 0);
    }

    public function DIRECTORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIRECTORY, 0);
    }

    public function DISABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISABLE, 0);
    }

    public function DISCARD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISCARD, 0);
    }

    public function DISK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISK, 0);
    }

    public function DO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DO, 0);
    }

    public function DUMPFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DUMPFILE, 0);
    }

    public function DUPLICATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DUPLICATE, 0);
    }

    public function DYNAMIC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DYNAMIC, 0);
    }

    public function EMPTY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EMPTY, 0);
    }

    public function ENABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENABLE, 0);
    }

    public function ENCRYPTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCRYPTION, 0);
    }

    public function ENCRYPTION_KEY_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCRYPTION_KEY_ADMIN, 0);
    }

    public function END(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::END, 0);
    }

    public function ENDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENDS, 0);
    }

    public function ENGINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE, 0);
    }

    public function ENGINE_ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINE_ATTRIBUTE, 0);
    }

    public function ENGINES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENGINES, 0);
    }

    public function ENFORCED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENFORCED, 0);
    }

    public function ERROR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ERROR, 0);
    }

    public function ERRORS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ERRORS, 0);
    }

    public function ESCAPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ESCAPE, 0);
    }

    public function EUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EUR, 0);
    }

    public function EVEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVEN, 0);
    }

    public function EVENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENT, 0);
    }

    public function EVENTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVENTS, 0);
    }

    public function EVERY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EVERY, 0);
    }

    public function EXCEPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCEPT, 0);
    }

    public function EXCHANGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCHANGE, 0);
    }

    public function EXCLUSIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXCLUSIVE, 0);
    }

    public function EXPIRE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXPIRE, 0);
    }

    public function EXPORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXPORT, 0);
    }

    public function EXTENDED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTENDED, 0);
    }

    public function EXTENT_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTENT_SIZE, 0);
    }

    public function FAILED_LOGIN_ATTEMPTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FAILED_LOGIN_ATTEMPTS, 0);
    }

    public function FAST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FAST, 0);
    }

    public function FAULTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FAULTS, 0);
    }

    public function FIELDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIELDS, 0);
    }

    public function FILE_BLOCK_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FILE_BLOCK_SIZE, 0);
    }

    public function FILTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FILTER, 0);
    }

    public function FIREWALL_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIREWALL_ADMIN, 0);
    }

    public function FIREWALL_EXEMPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIREWALL_EXEMPT, 0);
    }

    public function FIREWALL_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIREWALL_USER, 0);
    }

    public function FIRST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST, 0);
    }

    public function FIXED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIXED, 0);
    }

    public function FLUSH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLUSH, 0);
    }

    public function FOLLOWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOLLOWS, 0);
    }

    public function FOUND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOUND, 0);
    }

    public function FULL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FULL, 0);
    }

    public function FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FUNCTION, 0);
    }

    public function GENERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GENERAL, 0);
    }

    public function GLOBAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GLOBAL, 0);
    }

    public function GRANTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GRANTS, 0);
    }

    public function GROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP, 0);
    }

    public function GROUP_CONCAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP_CONCAT, 0);
    }

    public function GROUP_REPLICATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP_REPLICATION, 0);
    }

    public function GROUP_REPLICATION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GROUP_REPLICATION_ADMIN, 0);
    }

    public function HANDLER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HANDLER, 0);
    }

    public function HASH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HASH, 0);
    }

    public function HELP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HELP, 0);
    }

    public function HISTORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HISTORY, 0);
    }

    public function HOST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOST, 0);
    }

    public function HOSTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOSTS, 0);
    }

    public function IDENTIFIED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IDENTIFIED, 0);
    }

    public function IGNORED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORED, 0);
    }

    public function IGNORE_SERVER_IDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IGNORE_SERVER_IDS, 0);
    }

    public function IMPORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IMPORT, 0);
    }

    public function INDEXES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INDEXES, 0);
    }

    public function INITIAL_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INITIAL_SIZE, 0);
    }

    public function INNODB_REDO_LOG_ARCHIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INNODB_REDO_LOG_ARCHIVE, 0);
    }

    public function INPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INPLACE, 0);
    }

    public function INSERT_METHOD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSERT_METHOD, 0);
    }

    public function INSTALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSTALL, 0);
    }

    public function INSTANCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSTANCE, 0);
    }

    public function INSTANT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSTANT, 0);
    }

    public function INTERNAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTERNAL, 0);
    }

    public function INVOKE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVOKE, 0);
    }

    public function INVOKER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVOKER, 0);
    }

    public function IO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IO, 0);
    }

    public function IO_THREAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IO_THREAD, 0);
    }

    public function IPC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IPC, 0);
    }

    public function ISO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISO, 0);
    }

    public function ISOLATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISOLATION, 0);
    }

    public function ISSUER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISSUER, 0);
    }

    public function JIS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JIS, 0);
    }

    public function JSON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON, 0);
    }

    public function KEY_BLOCK_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::KEY_BLOCK_SIZE, 0);
    }

    public function LAMBDA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAMBDA, 0);
    }

    public function LANGUAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LANGUAGE, 0);
    }

    public function LAST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAST, 0);
    }

    public function LATERAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LATERAL, 0);
    }

    public function LEAVES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEAVES, 0);
    }

    public function LESS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LESS, 0);
    }

    public function LEVEL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEVEL, 0);
    }

    public function LIST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LIST, 0);
    }

    public function LOCAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCAL, 0);
    }

    public function LOGFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGFILE, 0);
    }

    public function LOGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOGS, 0);
    }

    public function MASTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER, 0);
    }

    public function MASTER_AUTO_POSITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_AUTO_POSITION, 0);
    }

    public function MASTER_CONNECT_RETRY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_CONNECT_RETRY, 0);
    }

    public function MASTER_DELAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_DELAY, 0);
    }

    public function MASTER_HEARTBEAT_PERIOD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_HEARTBEAT_PERIOD, 0);
    }

    public function MASTER_HOST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_HOST, 0);
    }

    public function MASTER_LOG_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_LOG_FILE, 0);
    }

    public function MASTER_LOG_POS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_LOG_POS, 0);
    }

    public function MASTER_PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_PASSWORD, 0);
    }

    public function MASTER_PORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_PORT, 0);
    }

    public function MASTER_RETRY_COUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_RETRY_COUNT, 0);
    }

    public function MASTER_SSL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL, 0);
    }

    public function MASTER_SSL_CA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CA, 0);
    }

    public function MASTER_SSL_CAPATH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CAPATH, 0);
    }

    public function MASTER_SSL_CERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CERT, 0);
    }

    public function MASTER_SSL_CIPHER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CIPHER, 0);
    }

    public function MASTER_SSL_CRL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CRL, 0);
    }

    public function MASTER_SSL_CRLPATH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_CRLPATH, 0);
    }

    public function MASTER_SSL_KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_SSL_KEY, 0);
    }

    public function MASTER_TLS_VERSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_TLS_VERSION, 0);
    }

    public function MASTER_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_USER, 0);
    }

    public function MAX_CONNECTIONS_PER_HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_CONNECTIONS_PER_HOUR, 0);
    }

    public function MAX_QUERIES_PER_HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_QUERIES_PER_HOUR, 0);
    }

    public function MAX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX, 0);
    }

    public function MAX_ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_ROWS, 0);
    }

    public function MAX_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_SIZE, 0);
    }

    public function MAX_UPDATES_PER_HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_UPDATES_PER_HOUR, 0);
    }

    public function MAX_USER_CONNECTIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAX_USER_CONNECTIONS, 0);
    }

    public function MEDIUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEDIUM, 0);
    }

    public function MEMBER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEMBER, 0);
    }

    public function MEMORY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MEMORY, 0);
    }

    public function MERGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MERGE, 0);
    }

    public function MESSAGE_TEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MESSAGE_TEXT, 0);
    }

    public function MID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MID, 0);
    }

    public function MIGRATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MIGRATE, 0);
    }

    public function MIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MIN, 0);
    }

    public function MIN_ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MIN_ROWS, 0);
    }

    public function MODE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MODE, 0);
    }

    public function MODIFY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MODIFY, 0);
    }

    public function MUTEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MUTEX, 0);
    }

    public function MYSQL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MYSQL, 0);
    }

    public function MYSQL_ERRNO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MYSQL_ERRNO, 0);
    }

    public function NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NAME, 0);
    }

    public function NAMES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NAMES, 0);
    }

    public function NCHAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NCHAR, 0);
    }

    public function NDB_STORED_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NDB_STORED_USER, 0);
    }

    public function NESTED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NESTED, 0);
    }

    public function NEVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NEVER, 0);
    }

    public function NEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NEXT, 0);
    }

    public function NO(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NO, 0);
    }

    public function NOCOPY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOCOPY, 0);
    }

    public function NODEGROUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NODEGROUP, 0);
    }

    public function NONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NONE, 0);
    }

    public function NOWAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NOWAIT, 0);
    }

    public function NUMBER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NUMBER, 0);
    }

    public function ODBC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ODBC, 0);
    }

    public function OFFLINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OFFLINE, 0);
    }

    public function OFFSET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OFFSET, 0);
    }

    public function OF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OF, 0);
    }

    public function OJ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OJ, 0);
    }

    public function OLD_PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OLD_PASSWORD, 0);
    }

    public function ONE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONE, 0);
    }

    public function ONLINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONLINE, 0);
    }

    public function ONLY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ONLY, 0);
    }

    public function OPEN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPEN, 0);
    }

    public function OPTIMIZER_COSTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIMIZER_COSTS, 0);
    }

    public function OPTIONAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIONAL, 0);
    }

    public function OPTIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OPTIONS, 0);
    }

    public function ORDER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ORDER, 0);
    }

    public function ORDINALITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ORDINALITY, 0);
    }

    public function OWNER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OWNER, 0);
    }

    public function PACK_KEYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PACK_KEYS, 0);
    }

    public function PAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PAGE, 0);
    }

    public function PARSER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARSER, 0);
    }

    public function PARTIAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTIAL, 0);
    }

    public function PARTITIONING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITIONING, 0);
    }

    public function PARTITIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PARTITIONS, 0);
    }

    public function PASSWORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD, 0);
    }

    public function PASSWORDLESS_USER_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORDLESS_USER_ADMIN, 0);
    }

    public function PASSWORD_LOCK_TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PASSWORD_LOCK_TIME, 0);
    }

    public function PATH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PATH, 0);
    }

    public function PERSIST_RO_VARIABLES_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PERSIST_RO_VARIABLES_ADMIN, 0);
    }

    public function PHASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PHASE, 0);
    }

    public function PLUGINS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUGINS, 0);
    }

    public function PLUGIN_DIR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUGIN_DIR, 0);
    }

    public function PLUGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PLUGIN, 0);
    }

    public function PORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PORT, 0);
    }

    public function PRECEDES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRECEDES, 0);
    }

    public function PREPARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PREPARE, 0);
    }

    public function PRESERVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRESERVE, 0);
    }

    public function PREV(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PREV, 0);
    }

    public function PRIMARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PRIMARY, 0);
    }

    public function PROCESSLIST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROCESSLIST, 0);
    }

    public function PROFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROFILE, 0);
    }

    public function PROFILES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROFILES, 0);
    }

    public function PROXY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PROXY, 0);
    }

    public function QUERY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUERY, 0);
    }

    public function QUICK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUICK, 0);
    }

    public function REBUILD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REBUILD, 0);
    }

    public function RECOVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RECOVER, 0);
    }

    public function RECURSIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RECURSIVE, 0);
    }

    public function REDO_BUFFER_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REDO_BUFFER_SIZE, 0);
    }

    public function REDUNDANT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REDUNDANT, 0);
    }

    public function RELAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY, 0);
    }

    public function RELAYLOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAYLOG, 0);
    }

    public function RELAY_LOG_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY_LOG_FILE, 0);
    }

    public function RELAY_LOG_POS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELAY_LOG_POS, 0);
    }

    public function REMOVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REMOVE, 0);
    }

    public function REORGANIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REORGANIZE, 0);
    }

    public function REPAIR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPAIR, 0);
    }

    public function REPLICATE_DO_DB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_DO_DB, 0);
    }

    public function REPLICATE_DO_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_DO_TABLE, 0);
    }

    public function REPLICATE_IGNORE_DB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_IGNORE_DB, 0);
    }

    public function REPLICATE_IGNORE_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_IGNORE_TABLE, 0);
    }

    public function REPLICATE_REWRITE_DB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_REWRITE_DB, 0);
    }

    public function REPLICATE_WILD_DO_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_WILD_DO_TABLE, 0);
    }

    public function REPLICATE_WILD_IGNORE_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATE_WILD_IGNORE_TABLE, 0);
    }

    public function REPLICATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATION, 0);
    }

    public function REPLICATION_APPLIER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATION_APPLIER, 0);
    }

    public function REPLICATION_SLAVE_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REPLICATION_SLAVE_ADMIN, 0);
    }

    public function RESET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESET, 0);
    }

    public function RESOURCE_GROUP_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESOURCE_GROUP_ADMIN, 0);
    }

    public function RESOURCE_GROUP_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESOURCE_GROUP_USER, 0);
    }

    public function RESUME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RESUME, 0);
    }

    public function RETURNED_SQLSTATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RETURNED_SQLSTATE, 0);
    }

    public function RETURNS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RETURNS, 0);
    }

    public function REUSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REUSE, 0);
    }

    public function ROLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE, 0);
    }

    public function ROLE_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLE_ADMIN, 0);
    }

    public function ROLLBACK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLLBACK, 0);
    }

    public function ROLLUP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROLLUP, 0);
    }

    public function ROTATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROTATE, 0);
    }

    public function ROW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW, 0);
    }

    public function ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROWS, 0);
    }

    public function ROW_FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW_FORMAT, 0);
    }

    public function RTREE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RTREE, 0);
    }

    public function S3(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::S3, 0);
    }

    public function SAVEPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SAVEPOINT, 0);
    }

    public function SCHEDULE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEDULE, 0);
    }

    public function SCHEMA_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA_NAME, 0);
    }

    public function SECURITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECURITY, 0);
    }

    public function SECONDARY_ENGINE_ATTRIBUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECONDARY_ENGINE_ATTRIBUTE, 0);
    }

    public function SERIAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERIAL, 0);
    }

    public function SERVER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SERVER, 0);
    }

    public function SESSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SESSION, 0);
    }

    public function SESSION_VARIABLES_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SESSION_VARIABLES_ADMIN, 0);
    }

    public function SET_USER_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SET_USER_ID, 0);
    }

    public function SHARE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHARE, 0);
    }

    public function SHARED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHARED, 0);
    }

    public function SHOW_ROUTINE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHOW_ROUTINE, 0);
    }

    public function SIGNED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SIGNED, 0);
    }

    public function SIMPLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SIMPLE, 0);
    }

    public function SLAVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLAVE, 0);
    }

    public function SLOW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLOW, 0);
    }

    public function SKIP_QUERY_REWRITE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SKIP_QUERY_REWRITE, 0);
    }

    public function SNAPSHOT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SNAPSHOT, 0);
    }

    public function SOCKET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOCKET, 0);
    }

    public function SOME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOME, 0);
    }

    public function SONAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SONAME, 0);
    }

    public function SOUNDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOUNDS, 0);
    }

    public function SOURCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOURCE, 0);
    }

    public function SQL_AFTER_GTIDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_AFTER_GTIDS, 0);
    }

    public function SQL_AFTER_MTS_GAPS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_AFTER_MTS_GAPS, 0);
    }

    public function SQL_BEFORE_GTIDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_BEFORE_GTIDS, 0);
    }

    public function SQL_BUFFER_RESULT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_BUFFER_RESULT, 0);
    }

    public function SQL_CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_CACHE, 0);
    }

    public function SQL_NO_CACHE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_NO_CACHE, 0);
    }

    public function SQL_THREAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_THREAD, 0);
    }

    public function STACKED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STACKED, 0);
    }

    public function START(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::START, 0);
    }

    public function STARTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STARTS, 0);
    }

    public function STATS_AUTO_RECALC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATS_AUTO_RECALC, 0);
    }

    public function STATS_PERSISTENT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATS_PERSISTENT, 0);
    }

    public function STATS_SAMPLE_PAGES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATS_SAMPLE_PAGES, 0);
    }

    public function STATUS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STATUS, 0);
    }

    public function STD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STD, 0);
    }

    public function STDDEV(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STDDEV, 0);
    }

    public function STDDEV_POP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STDDEV_POP, 0);
    }

    public function STDDEV_SAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STDDEV_SAMP, 0);
    }

    public function STOP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STOP, 0);
    }

    public function STORAGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STORAGE, 0);
    }

    public function STRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRING, 0);
    }

    public function SUBCLASS_ORIGIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBCLASS_ORIGIN, 0);
    }

    public function SUBJECT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBJECT, 0);
    }

    public function SUBPARTITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBPARTITION, 0);
    }

    public function SUBPARTITIONS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBPARTITIONS, 0);
    }

    public function SUM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUM, 0);
    }

    public function SUSPEND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUSPEND, 0);
    }

    public function SWAPS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SWAPS, 0);
    }

    public function SWITCHES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SWITCHES, 0);
    }

    public function SYSTEM_VARIABLES_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SYSTEM_VARIABLES_ADMIN, 0);
    }

    public function TABLE_NAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE_NAME, 0);
    }

    public function TABLESPACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLESPACE, 0);
    }

    public function TABLE_ENCRYPTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE_ENCRYPTION_ADMIN, 0);
    }

    public function TABLE_TYPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TABLE_TYPE, 0);
    }

    public function TEMPORARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPORARY, 0);
    }

    public function TEMPTABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TEMPTABLE, 0);
    }

    public function THAN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::THAN, 0);
    }

    public function TP_CONNECTION_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TP_CONNECTION_ADMIN, 0);
    }

    public function TRADITIONAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRADITIONAL, 0);
    }

    public function TRANSACTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRANSACTION, 0);
    }

    public function TRANSACTIONAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRANSACTIONAL, 0);
    }

    public function TRIGGERS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRIGGERS, 0);
    }

    public function TRUNCATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TRUNCATE, 0);
    }

    public function UNBOUNDED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNBOUNDED, 0);
    }

    public function UNDEFINED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDEFINED, 0);
    }

    public function UNDOFILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDOFILE, 0);
    }

    public function UNDO_BUFFER_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNDO_BUFFER_SIZE, 0);
    }

    public function UNINSTALL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNINSTALL, 0);
    }

    public function UNKNOWN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNKNOWN, 0);
    }

    public function UNTIL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNTIL, 0);
    }

    public function UPGRADE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPGRADE, 0);
    }

    public function USA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USA, 0);
    }

    public function USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER, 0);
    }

    public function USE_FRM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USE_FRM, 0);
    }

    public function USER_RESOURCES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::USER_RESOURCES, 0);
    }

    public function VALIDATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALIDATION, 0);
    }

    public function VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALUE, 0);
    }

    public function VAR_POP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VAR_POP, 0);
    }

    public function VAR_SAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VAR_SAMP, 0);
    }

    public function VARIABLES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARIABLES, 0);
    }

    public function VARIANCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VARIANCE, 0);
    }

    public function VERSION_TOKEN_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VERSION_TOKEN_ADMIN, 0);
    }

    public function VIEW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VIEW, 0);
    }

    public function VIRTUAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VIRTUAL, 0);
    }

    public function WAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WAIT, 0);
    }

    public function WARNINGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WARNINGS, 0);
    }

    public function WITHOUT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITHOUT, 0);
    }

    public function WORK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WORK, 0);
    }

    public function WRAPPER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WRAPPER, 0);
    }

    public function X509(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::X509, 0);
    }

    public function XA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA, 0);
    }

    public function XA_RECOVER_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XA_RECOVER_ADMIN, 0);
    }

    public function XML(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::XML, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterKeywordsCanBeId($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitKeywordsCanBeId($this);
        }
    }
}

class FunctionNameBaseContext extends ParserRuleContext
{
    public function __construct(?ParserRuleContext $parent, ?int $invokingState = null)
    {
        parent::__construct($parent, $invokingState);
    }

    public function getRuleIndex(): int
    {
        return MySqlParser::RULE_functionNameBase;
    }

    public function ABS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ABS, 0);
    }

    public function ACOS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ACOS, 0);
    }

    public function ADDDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADDDATE, 0);
    }

    public function ADDTIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ADDTIME, 0);
    }

    public function AES_DECRYPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AES_DECRYPT, 0);
    }

    public function AES_ENCRYPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AES_ENCRYPT, 0);
    }

    public function AREA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::AREA, 0);
    }

    public function ASBINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASBINARY, 0);
    }

    public function ASIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASIN, 0);
    }

    public function ASTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASTEXT, 0);
    }

    public function ASWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASWKB, 0);
    }

    public function ASWKT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASWKT, 0);
    }

    public function ASYMMETRIC_DECRYPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASYMMETRIC_DECRYPT, 0);
    }

    public function ASYMMETRIC_DERIVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASYMMETRIC_DERIVE, 0);
    }

    public function ASYMMETRIC_ENCRYPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASYMMETRIC_ENCRYPT, 0);
    }

    public function ASYMMETRIC_SIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASYMMETRIC_SIGN, 0);
    }

    public function ASYMMETRIC_VERIFY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ASYMMETRIC_VERIFY, 0);
    }

    public function ATAN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ATAN, 0);
    }

    public function ATAN2(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ATAN2, 0);
    }

    public function BENCHMARK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BENCHMARK, 0);
    }

    public function BIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIN, 0);
    }

    public function BIT_COUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_COUNT, 0);
    }

    public function BIT_LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BIT_LENGTH, 0);
    }

    public function BUFFER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::BUFFER, 0);
    }

    public function CEIL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CEIL, 0);
    }

    public function CEILING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CEILING, 0);
    }

    public function CENTROID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CENTROID, 0);
    }

    public function CHARACTER_LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARACTER_LENGTH, 0);
    }

    public function CHARSET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHARSET, 0);
    }

    public function CHAR_LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CHAR_LENGTH, 0);
    }

    public function COERCIBILITY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COERCIBILITY, 0);
    }

    public function COLLATION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COLLATION, 0);
    }

    public function COMPRESS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COMPRESS, 0);
    }

    public function CONCAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONCAT, 0);
    }

    public function CONCAT_WS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONCAT_WS, 0);
    }

    public function CONNECTION_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONNECTION_ID, 0);
    }

    public function CONV(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONV, 0);
    }

    public function CONVERT_TZ(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CONVERT_TZ, 0);
    }

    public function COS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COS, 0);
    }

    public function COT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COT, 0);
    }

    public function COUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::COUNT, 0);
    }

    public function CRC32(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CRC32, 0);
    }

    public function CREATE_ASYMMETRIC_PRIV_KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY, 0);
    }

    public function CREATE_ASYMMETRIC_PUB_KEY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE_ASYMMETRIC_PUB_KEY, 0);
    }

    public function CREATE_DH_PARAMETERS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE_DH_PARAMETERS, 0);
    }

    public function CREATE_DIGEST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CREATE_DIGEST, 0);
    }

    public function CROSSES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CROSSES, 0);
    }

    public function CUME_DIST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::CUME_DIST, 0);
    }

    public function DATABASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATABASE, 0);
    }

    public function DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATE, 0);
    }

    public function DATEDIFF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATEDIFF, 0);
    }

    public function DATE_FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DATE_FORMAT, 0);
    }

    public function DAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAY, 0);
    }

    public function DAYNAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAYNAME, 0);
    }

    public function DAYOFMONTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAYOFMONTH, 0);
    }

    public function DAYOFWEEK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAYOFWEEK, 0);
    }

    public function DAYOFYEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DAYOFYEAR, 0);
    }

    public function DECODE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DECODE, 0);
    }

    public function DEGREES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DEGREES, 0);
    }

    public function DENSE_RANK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DENSE_RANK, 0);
    }

    public function DES_DECRYPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DES_DECRYPT, 0);
    }

    public function DES_ENCRYPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DES_ENCRYPT, 0);
    }

    public function DIMENSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DIMENSION, 0);
    }

    public function DISJOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::DISJOINT, 0);
    }

    public function ELT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ELT, 0);
    }

    public function ENCODE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCODE, 0);
    }

    public function ENCRYPT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENCRYPT, 0);
    }

    public function ENDPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENDPOINT, 0);
    }

    public function ENVELOPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ENVELOPE, 0);
    }

    public function EQUALS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EQUALS, 0);
    }

    public function EXP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXP, 0);
    }

    public function EXPORT_SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXPORT_SET, 0);
    }

    public function EXTERIORRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTERIORRING, 0);
    }

    public function EXTRACTVALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::EXTRACTVALUE, 0);
    }

    public function FIELD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIELD, 0);
    }

    public function FIND_IN_SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIND_IN_SET, 0);
    }

    public function FIRST_VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FIRST_VALUE, 0);
    }

    public function FLOOR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FLOOR, 0);
    }

    public function FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FORMAT, 0);
    }

    public function FOUND_ROWS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FOUND_ROWS, 0);
    }

    public function FROM_BASE64(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM_BASE64, 0);
    }

    public function FROM_DAYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM_DAYS, 0);
    }

    public function FROM_UNIXTIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::FROM_UNIXTIME, 0);
    }

    public function GEOMCOLLFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMCOLLFROMTEXT, 0);
    }

    public function GEOMCOLLFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMCOLLFROMWKB, 0);
    }

    public function GEOMETRYCOLLECTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRYCOLLECTION, 0);
    }

    public function GEOMETRYCOLLECTIONFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRYCOLLECTIONFROMTEXT, 0);
    }

    public function GEOMETRYCOLLECTIONFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRYCOLLECTIONFROMWKB, 0);
    }

    public function GEOMETRYFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRYFROMTEXT, 0);
    }

    public function GEOMETRYFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRYFROMWKB, 0);
    }

    public function GEOMETRYN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRYN, 0);
    }

    public function GEOMETRYTYPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMETRYTYPE, 0);
    }

    public function GEOMFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMFROMTEXT, 0);
    }

    public function GEOMFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GEOMFROMWKB, 0);
    }

    public function GET_FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GET_FORMAT, 0);
    }

    public function GET_LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GET_LOCK, 0);
    }

    public function GLENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GLENGTH, 0);
    }

    public function GREATEST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GREATEST, 0);
    }

    public function GTID_SUBSET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GTID_SUBSET, 0);
    }

    public function GTID_SUBTRACT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::GTID_SUBTRACT, 0);
    }

    public function HEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HEX, 0);
    }

    public function HOUR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::HOUR, 0);
    }

    public function IFNULL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IFNULL, 0);
    }

    public function INET6_ATON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INET6_ATON, 0);
    }

    public function INET6_NTOA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INET6_NTOA, 0);
    }

    public function INET_ATON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INET_ATON, 0);
    }

    public function INET_NTOA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INET_NTOA, 0);
    }

    public function INSTR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INSTR, 0);
    }

    public function INTERIORRINGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTERIORRINGN, 0);
    }

    public function INTERSECTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INTERSECTS, 0);
    }

    public function INVISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::INVISIBLE, 0);
    }

    public function ISCLOSED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISCLOSED, 0);
    }

    public function ISEMPTY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISEMPTY, 0);
    }

    public function ISNULL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISNULL, 0);
    }

    public function ISSIMPLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ISSIMPLE, 0);
    }

    public function IS_FREE_LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IS_FREE_LOCK, 0);
    }

    public function IS_IPV4(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IS_IPV4, 0);
    }

    public function IS_IPV4_COMPAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IS_IPV4_COMPAT, 0);
    }

    public function IS_IPV4_MAPPED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IS_IPV4_MAPPED, 0);
    }

    public function IS_IPV6(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IS_IPV6, 0);
    }

    public function IS_USED_LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::IS_USED_LOCK, 0);
    }

    public function LAG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAG, 0);
    }

    public function LAST_INSERT_ID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAST_INSERT_ID, 0);
    }

    public function LAST_VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LAST_VALUE, 0);
    }

    public function LCASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LCASE, 0);
    }

    public function LEAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEAD, 0);
    }

    public function LEAST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEAST, 0);
    }

    public function LEFT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LEFT, 0);
    }

    public function LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LENGTH, 0);
    }

    public function LINEFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINEFROMTEXT, 0);
    }

    public function LINEFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINEFROMWKB, 0);
    }

    public function LINESTRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINESTRING, 0);
    }

    public function LINESTRINGFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINESTRINGFROMTEXT, 0);
    }

    public function LINESTRINGFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LINESTRINGFROMWKB, 0);
    }

    public function LN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LN, 0);
    }

    public function LOAD_FILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOAD_FILE, 0);
    }

    public function LOCATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOCATE, 0);
    }

    public function LOG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOG, 0);
    }

    public function LOG10(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOG10, 0);
    }

    public function LOG2(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOG2, 0);
    }

    public function LOWER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LOWER, 0);
    }

    public function LPAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LPAD, 0);
    }

    public function LTRIM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::LTRIM, 0);
    }

    public function MAKEDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAKEDATE, 0);
    }

    public function MAKETIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAKETIME, 0);
    }

    public function MAKE_SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MAKE_SET, 0);
    }

    public function MASTER_POS_WAIT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MASTER_POS_WAIT, 0);
    }

    public function MBRCONTAINS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MBRCONTAINS, 0);
    }

    public function MBRDISJOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MBRDISJOINT, 0);
    }

    public function MBREQUAL(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MBREQUAL, 0);
    }

    public function MBRINTERSECTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MBRINTERSECTS, 0);
    }

    public function MBROVERLAPS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MBROVERLAPS, 0);
    }

    public function MBRTOUCHES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MBRTOUCHES, 0);
    }

    public function MBRWITHIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MBRWITHIN, 0);
    }

    public function MD5(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MD5, 0);
    }

    public function MICROSECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MICROSECOND, 0);
    }

    public function MINUTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MINUTE, 0);
    }

    public function MLINEFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MLINEFROMTEXT, 0);
    }

    public function MLINEFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MLINEFROMWKB, 0);
    }

    public function MOD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MOD, 0);
    }

    public function MONTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MONTH, 0);
    }

    public function MONTHNAME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MONTHNAME, 0);
    }

    public function MPOINTFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MPOINTFROMTEXT, 0);
    }

    public function MPOINTFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MPOINTFROMWKB, 0);
    }

    public function MPOLYFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MPOLYFROMTEXT, 0);
    }

    public function MPOLYFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MPOLYFROMWKB, 0);
    }

    public function MULTILINESTRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTILINESTRING, 0);
    }

    public function MULTILINESTRINGFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTILINESTRINGFROMTEXT, 0);
    }

    public function MULTILINESTRINGFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTILINESTRINGFROMWKB, 0);
    }

    public function MULTIPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTIPOINT, 0);
    }

    public function MULTIPOINTFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTIPOINTFROMTEXT, 0);
    }

    public function MULTIPOINTFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTIPOINTFROMWKB, 0);
    }

    public function MULTIPOLYGON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTIPOLYGON, 0);
    }

    public function MULTIPOLYGONFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTIPOLYGONFROMTEXT, 0);
    }

    public function MULTIPOLYGONFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::MULTIPOLYGONFROMWKB, 0);
    }

    public function NAME_CONST(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NAME_CONST, 0);
    }

    public function NTH_VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NTH_VALUE, 0);
    }

    public function NTILE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NTILE, 0);
    }

    public function NULLIF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NULLIF, 0);
    }

    public function NUMGEOMETRIES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NUMGEOMETRIES, 0);
    }

    public function NUMINTERIORRINGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NUMINTERIORRINGS, 0);
    }

    public function NUMPOINTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::NUMPOINTS, 0);
    }

    public function OCT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OCT, 0);
    }

    public function OCTET_LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OCTET_LENGTH, 0);
    }

    public function ORD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ORD, 0);
    }

    public function OVERLAPS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::OVERLAPS, 0);
    }

    public function PERCENT_RANK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PERCENT_RANK, 0);
    }

    public function PERIOD_ADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PERIOD_ADD, 0);
    }

    public function PERIOD_DIFF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PERIOD_DIFF, 0);
    }

    public function PI(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::PI, 0);
    }

    public function POINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POINT, 0);
    }

    public function POINTFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POINTFROMTEXT, 0);
    }

    public function POINTFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POINTFROMWKB, 0);
    }

    public function POINTN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POINTN, 0);
    }

    public function POLYFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POLYFROMTEXT, 0);
    }

    public function POLYFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POLYFROMWKB, 0);
    }

    public function POLYGON(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POLYGON, 0);
    }

    public function POLYGONFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POLYGONFROMTEXT, 0);
    }

    public function POLYGONFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POLYGONFROMWKB, 0);
    }

    public function POSITION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POSITION, 0);
    }

    public function POW(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POW, 0);
    }

    public function POWER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::POWER, 0);
    }

    public function QUARTER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUARTER, 0);
    }

    public function QUOTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::QUOTE, 0);
    }

    public function RADIANS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RADIANS, 0);
    }

    public function RAND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RAND, 0);
    }

    public function RANDOM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RANDOM, 0);
    }

    public function RANK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RANK, 0);
    }

    public function RANDOM_BYTES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RANDOM_BYTES, 0);
    }

    public function RELEASE_LOCK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RELEASE_LOCK, 0);
    }

    public function REVERSE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::REVERSE, 0);
    }

    public function RIGHT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RIGHT, 0);
    }

    public function ROUND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROUND, 0);
    }

    public function ROW_COUNT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW_COUNT, 0);
    }

    public function ROW_NUMBER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ROW_NUMBER, 0);
    }

    public function RPAD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RPAD, 0);
    }

    public function RTRIM(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::RTRIM, 0);
    }

    public function SCHEMA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SCHEMA, 0);
    }

    public function SECOND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SECOND, 0);
    }

    public function SEC_TO_TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SEC_TO_TIME, 0);
    }

    public function SESSION_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SESSION_USER, 0);
    }

    public function SESSION_VARIABLES_ADMIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SESSION_VARIABLES_ADMIN, 0);
    }

    public function SHA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHA, 0);
    }

    public function SHA1(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHA1, 0);
    }

    public function SHA2(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SHA2, 0);
    }

    public function SIGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SIGN, 0);
    }

    public function SIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SIN, 0);
    }

    public function SLEEP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SLEEP, 0);
    }

    public function SOUNDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SOUNDEX, 0);
    }

    public function SQL_THREAD_WAIT_AFTER_GTIDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS, 0);
    }

    public function SQRT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SQRT, 0);
    }

    public function SRID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SRID, 0);
    }

    public function STARTPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STARTPOINT, 0);
    }

    public function STRCMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STRCMP, 0);
    }

    public function STR_TO_DATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::STR_TO_DATE, 0);
    }

    public function ST_AREA(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_AREA, 0);
    }

    public function ST_ASBINARY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ASBINARY, 0);
    }

    public function ST_ASTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ASTEXT, 0);
    }

    public function ST_ASWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ASWKB, 0);
    }

    public function ST_ASWKT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ASWKT, 0);
    }

    public function ST_BUFFER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_BUFFER, 0);
    }

    public function ST_CENTROID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_CENTROID, 0);
    }

    public function ST_CONTAINS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_CONTAINS, 0);
    }

    public function ST_CROSSES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_CROSSES, 0);
    }

    public function ST_DIFFERENCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_DIFFERENCE, 0);
    }

    public function ST_DIMENSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_DIMENSION, 0);
    }

    public function ST_DISJOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_DISJOINT, 0);
    }

    public function ST_DISTANCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_DISTANCE, 0);
    }

    public function ST_ENDPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ENDPOINT, 0);
    }

    public function ST_ENVELOPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ENVELOPE, 0);
    }

    public function ST_EQUALS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_EQUALS, 0);
    }

    public function ST_EXTERIORRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_EXTERIORRING, 0);
    }

    public function ST_GEOMCOLLFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMCOLLFROMTEXT, 0);
    }

    public function ST_GEOMCOLLFROMTXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMCOLLFROMTXT, 0);
    }

    public function ST_GEOMCOLLFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMCOLLFROMWKB, 0);
    }

    public function ST_GEOMETRYCOLLECTIONFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT, 0);
    }

    public function ST_GEOMETRYCOLLECTIONFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB, 0);
    }

    public function ST_GEOMETRYFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMETRYFROMTEXT, 0);
    }

    public function ST_GEOMETRYFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMETRYFROMWKB, 0);
    }

    public function ST_GEOMETRYN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMETRYN, 0);
    }

    public function ST_GEOMETRYTYPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMETRYTYPE, 0);
    }

    public function ST_GEOMFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMFROMTEXT, 0);
    }

    public function ST_GEOMFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_GEOMFROMWKB, 0);
    }

    public function ST_INTERIORRINGN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_INTERIORRINGN, 0);
    }

    public function ST_INTERSECTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_INTERSECTION, 0);
    }

    public function ST_INTERSECTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_INTERSECTS, 0);
    }

    public function ST_ISCLOSED(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ISCLOSED, 0);
    }

    public function ST_ISEMPTY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ISEMPTY, 0);
    }

    public function ST_ISSIMPLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_ISSIMPLE, 0);
    }

    public function ST_LINEFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_LINEFROMTEXT, 0);
    }

    public function ST_LINEFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_LINEFROMWKB, 0);
    }

    public function ST_LINESTRINGFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_LINESTRINGFROMTEXT, 0);
    }

    public function ST_LINESTRINGFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_LINESTRINGFROMWKB, 0);
    }

    public function ST_NUMGEOMETRIES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_NUMGEOMETRIES, 0);
    }

    public function ST_NUMINTERIORRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_NUMINTERIORRING, 0);
    }

    public function ST_NUMINTERIORRINGS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_NUMINTERIORRINGS, 0);
    }

    public function ST_NUMPOINTS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_NUMPOINTS, 0);
    }

    public function ST_OVERLAPS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_OVERLAPS, 0);
    }

    public function ST_POINTFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_POINTFROMTEXT, 0);
    }

    public function ST_POINTFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_POINTFROMWKB, 0);
    }

    public function ST_POINTN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_POINTN, 0);
    }

    public function ST_POLYFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_POLYFROMTEXT, 0);
    }

    public function ST_POLYFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_POLYFROMWKB, 0);
    }

    public function ST_POLYGONFROMTEXT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_POLYGONFROMTEXT, 0);
    }

    public function ST_POLYGONFROMWKB(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_POLYGONFROMWKB, 0);
    }

    public function ST_SRID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_SRID, 0);
    }

    public function ST_STARTPOINT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_STARTPOINT, 0);
    }

    public function ST_SYMDIFFERENCE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_SYMDIFFERENCE, 0);
    }

    public function ST_TOUCHES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_TOUCHES, 0);
    }

    public function ST_UNION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_UNION, 0);
    }

    public function ST_WITHIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_WITHIN, 0);
    }

    public function ST_X(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_X, 0);
    }

    public function ST_Y(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::ST_Y, 0);
    }

    public function SUBDATE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBDATE, 0);
    }

    public function SUBSTRING_INDEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBSTRING_INDEX, 0);
    }

    public function SUBTIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SUBTIME, 0);
    }

    public function SYSTEM_USER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::SYSTEM_USER, 0);
    }

    public function TAN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TAN, 0);
    }

    public function TIME(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIME, 0);
    }

    public function TIMEDIFF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIMEDIFF, 0);
    }

    public function TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIMESTAMP, 0);
    }

    public function TIMESTAMPADD(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIMESTAMPADD, 0);
    }

    public function TIMESTAMPDIFF(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIMESTAMPDIFF, 0);
    }

    public function TIME_FORMAT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIME_FORMAT, 0);
    }

    public function TIME_TO_SEC(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TIME_TO_SEC, 0);
    }

    public function TOUCHES(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TOUCHES, 0);
    }

    public function TO_BASE64(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO_BASE64, 0);
    }

    public function TO_DAYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO_DAYS, 0);
    }

    public function TO_SECONDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::TO_SECONDS, 0);
    }

    public function UCASE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UCASE, 0);
    }

    public function UNCOMPRESS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNCOMPRESS, 0);
    }

    public function UNCOMPRESSED_LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNCOMPRESSED_LENGTH, 0);
    }

    public function UNHEX(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNHEX, 0);
    }

    public function UNIX_TIMESTAMP(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UNIX_TIMESTAMP, 0);
    }

    public function UPDATEXML(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPDATEXML, 0);
    }

    public function UPPER(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UPPER, 0);
    }

    public function UUID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UUID, 0);
    }

    public function UUID_SHORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::UUID_SHORT, 0);
    }

    public function VALIDATE_PASSWORD_STRENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VALIDATE_PASSWORD_STRENGTH, 0);
    }

    public function VERSION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VERSION, 0);
    }

    public function VISIBLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::VISIBLE, 0);
    }

    public function WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0);
    }

    public function WEEK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WEEK, 0);
    }

    public function WEEKDAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WEEKDAY, 0);
    }

    public function WEEKOFYEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WEEKOFYEAR, 0);
    }

    public function WEIGHT_STRING(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WEIGHT_STRING, 0);
    }

    public function WITHIN(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::WITHIN, 0);
    }

    public function YEAR(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::YEAR, 0);
    }

    public function YEARWEEK(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::YEARWEEK, 0);
    }

    public function Y_FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::Y_FUNCTION, 0);
    }

    public function X_FUNCTION(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::X_FUNCTION, 0);
    }

    public function JSON_ARRAY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_ARRAY, 0);
    }

    public function JSON_OBJECT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_OBJECT, 0);
    }

    public function JSON_QUOTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_QUOTE, 0);
    }

    public function JSON_CONTAINS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_CONTAINS, 0);
    }

    public function JSON_CONTAINS_PATH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_CONTAINS_PATH, 0);
    }

    public function JSON_EXTRACT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_EXTRACT, 0);
    }

    public function JSON_KEYS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_KEYS, 0);
    }

    public function JSON_OVERLAPS(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_OVERLAPS, 0);
    }

    public function JSON_SEARCH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_SEARCH, 0);
    }

    public function JSON_VALUE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_VALUE, 0);
    }

    public function JSON_ARRAY_APPEND(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_ARRAY_APPEND, 0);
    }

    public function JSON_ARRAY_INSERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_ARRAY_INSERT, 0);
    }

    public function JSON_INSERT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_INSERT, 0);
    }

    public function JSON_MERGE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_MERGE, 0);
    }

    public function JSON_MERGE_PATCH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_MERGE_PATCH, 0);
    }

    public function JSON_MERGE_PRESERVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_MERGE_PRESERVE, 0);
    }

    public function JSON_REMOVE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_REMOVE, 0);
    }

    public function JSON_REPLACE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_REPLACE, 0);
    }

    public function JSON_SET(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_SET, 0);
    }

    public function JSON_UNQUOTE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_UNQUOTE, 0);
    }

    public function JSON_DEPTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_DEPTH, 0);
    }

    public function JSON_LENGTH(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_LENGTH, 0);
    }

    public function JSON_TYPE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_TYPE, 0);
    }

    public function JSON_VALID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_VALID, 0);
    }

    public function JSON_TABLE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_TABLE, 0);
    }

    public function JSON_SCHEMA_VALID(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_SCHEMA_VALID, 0);
    }

    public function JSON_SCHEMA_VALIDATION_REPORT(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_SCHEMA_VALIDATION_REPORT, 0);
    }

    public function JSON_PRETTY(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_PRETTY, 0);
    }

    public function JSON_STORAGE_FREE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_STORAGE_FREE, 0);
    }

    public function JSON_STORAGE_SIZE(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_STORAGE_SIZE, 0);
    }

    public function JSON_ARRAYAGG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_ARRAYAGG, 0);
    }

    public function JSON_OBJECTAGG(): ?TerminalNode
    {
        return $this->getToken(MySqlParser::JSON_OBJECTAGG, 0);
    }

    public function enterRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->enterFunctionNameBase($this);
        }
    }

    public function exitRule(ParseTreeListener $listener): void
    {
        if ($listener instanceof MySqlParserListener) {
            $listener->exitFunctionNameBase($this);
        }
    }
}